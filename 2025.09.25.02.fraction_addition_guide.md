# CHUYÊN ĐỀ: CỘNG HAI PHÂN SỐ (ADDITION OF FRACTIONS)
## Dành cho học sinh lớp 10 Chuyên Tin

---

## 1. ĐỊNH NGHĨA VÀ KHÁI NIỆM CƠ BẢN

### 1.1. Định nghĩa phân số
**Phân số** là một số có dạng a/b, trong đó:
- **a** là tử số (numerator)
- **b** là mẫu số (denominator), b ≠ 0

### 1.2. Bài toán cộng hai phân số
Cho hai phân số a₁/b₁ và a₂/b₂, tìm tổng của chúng dưới dạng phân số tối giản.

### 1.3. Công thức toán học
```
a₁/b₁ + a₂/b₂ = (a₁ × b₂ + a₂ × b₁) / (b₁ × b₂)
```

Sau đó rút gọn phân số bằng cách chia cả tử và mẫu cho ước chung lớn nhất (GCD).

### 1.4. Minh họa bằng sơ đồ

```
Cộng hai phân số: 1/2 + 3/2

┌─────────────────────────────────────────┐
│  Bước 1: Kiểm tra mẫu số                │
│  1/2 + 3/2 → cùng mẫu số (2)           │
│                                         │
│  Bước 2: Cộng tử số                     │
│  (1 + 3)/2 = 4/2                       │
│                                         │
│  Bước 3: Rút gọn                        │
│  4/2 = 2/1 = 2                         │
└─────────────────────────────────────────┘

Cộng hai phân số: 1/3 + 3/9

┌─────────────────────────────────────────┐
│  Bước 1: Tìm mẫu chung                  │
│  LCM(3, 9) = 9                         │
│                                         │
│  Bước 2: Quy đồng mẫu                   │
│  1/3 = 3/9                             │
│  3/9 = 3/9                             │
│                                         │
│  Bước 3: Cộng tử số                     │
│  (3 + 3)/9 = 6/9                       │
│                                         │
│  Bước 4: Rút gọn                        │
│  GCD(6, 9) = 3                         │
│  6/9 = (6÷3)/(9÷3) = 2/3               │
└─────────────────────────────────────────┘
```

## 2. CÁC VÍ DỤ MINH HỌA

### Ví dụ 1: Cùng mẫu số
- **Input**: a = [1, 2], b = [3, 2]
- **Phân số**: 1/2 + 3/2
- **Tính toán**: (1 + 3)/2 = 4/2 = 2/1
- **Kết quả**: [2, 1]

### Ví dụ 2: Khác mẫu số - cần quy đồng
- **Input**: a = [1, 3], b = [3, 9]  
- **Phân số**: 1/3 + 3/9
- **LCM(3, 9)**: 9
- **Quy đồng**: 1/3 = 3/9, 3/9 = 3/9
- **Cộng**: (3 + 3)/9 = 6/9
- **Rút gọn**: GCD(6, 9) = 3 → 6/9 = 2/3
- **Kết quả**: [2, 3]

### Ví dụ 3: Trường hợp phức tạp hơn
- **Input**: a = [1, 5], b = [3, 15]
- **Phân số**: 1/5 + 3/15
- **LCM(5, 15)**: 15
- **Quy đồng**: 1/5 = 3/15, 3/15 = 3/15
- **Cộng**: (3 + 3)/15 = 6/15
- **Rút gọn**: GCD(6, 15) = 3 → 6/15 = 2/5
- **Kết quả**: [2, 5]

## 3. THUẬT TOÁN GIẢI QUYẾT

### 3.1. Các bước thuật toán

#### 3.1.1. Sơ đồ tổng quan
```
┌─────────────────────┐
│   Bắt đầu           │
└─────┬───────────────┘
      │
┌─────▼───────────────┐
│ Nhập 2 phân số      │
│ a₁/b₁ và a₂/b₂      │
└─────┬───────────────┘
      │
┌─────▼───────────────┐
│ Tìm LCM(b₁, b₂)     │
│ = (b₁×b₂)/GCD(b₁,b₂)│
└─────┬───────────────┘
      │
┌─────▼───────────────┐
│ Tính tử số mới      │
│ num = a₁×(LCM/b₁) + │
│       a₂×(LCM/b₂)   │
└─────┬───────────────┘
      │
┌─────▼───────────────┐
│ Tìm GCD(num, LCM)   │
└─────┬───────────────┘
      │
┌─────▼───────────────┐
│ Rút gọn phân số     │
│ final_num = num/GCD │
│ final_den = LCM/GCD │
└─────┬───────────────┘
      │
┌─────▼───────────────┐
│ Xuất kết quả        │
└─────┬───────────────┘
      │
┌─────▼───────────────┐
│   Kết thúc          │
└─────────────────────┘
```

#### 3.1.2. Chi tiết từng bước

**Bước 1**: Tìm ước chung lớn nhất (GCD) của hai mẫu số
**Bước 2**: Tính bội chung nhỏ nhất (LCM) = (b₁ × b₂) / GCD(b₁, b₂)
**Bước 3**: Quy đồng hai phân số về cùng mẫu LCM
**Bước 4**: Cộng hai tử số sau khi quy đồng
**Bước 5**: Tìm GCD của tử số và mẫu số kết quả
**Bước 6**: Rút gọn phân số cuối cùng

## 4. TRIỂN KHAI CODE

### 4.1. Hàm tìm ước chung lớn nhất (GCD)

#### 4.1.1. Thuật toán Euclid

**C++:**
```cpp
// Hàm tìm ước chung lớn nhất bằng thuật toán Euclid
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}
```

**Python:**
```python
# Hàm tìm ước chung lớn nhất bằng thuật toán Euclid
def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)
```

#### 4.1.2. Minh họa thuật toán Euclid
```
Tìm GCD(12, 8):
12 % 8 = 4  →  GCD(8, 4)
8 % 4 = 0   →  GCD(4, 0) = 4

Vậy GCD(12, 8) = 4
```

### 4.2. Chương trình chính

**C++:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

// Hàm tìm ước chung lớn nhất
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}

// Hàm cộng hai phân số
vector<int> addFraction(vector<int> frac1, vector<int> frac2) {
    // frac1[0]/frac1[1] + frac2[0]/frac2[1]
    int num1 = frac1[0], den1 = frac1[1];
    int num2 = frac2[0], den2 = frac2[1];
    
    // Tìm mẫu chung (LCM)
    int lcm_den = (den1 * den2) / gcd(den1, den2);
    
    // Quy đồng và cộng tử số
    int result_num = num1 * (lcm_den / den1) + num2 * (lcm_den / den2);
    int result_den = lcm_den;
    
    // Rút gọn phân số
    int common_factor = gcd(result_num, result_den);
    result_num /= common_factor;
    result_den /= common_factor;
    
    return {result_num, result_den};
}

// Hàm hiển thị phân số
void printFraction(vector<int> frac) {
    if (frac[1] == 1) {
        cout << frac[0];
    } else {
        cout << frac[0] << "/" << frac[1];
    }
}

int main() {
    vector<int> frac1, frac2;
    int num, den;
    
    // Nhập phân số thứ nhất
    cout << "Nhap phan so thu nhat (tu so, mau so): ";
    cin >> num >> den;
    frac1 = {num, den};
    
    // Nhập phân số thứ hai
    cout << "Nhap phan so thu hai (tu so, mau so): ";
    cin >> num >> den;
    frac2 = {num, den};
    
    // Tính tổng
    vector<int> result = addFraction(frac1, frac2);
    
    // In kết quả
    cout << "Ket qua: ";
    printFraction(frac1);
    cout << " + ";
    printFraction(frac2);
    cout << " = ";
    printFraction(result);
    cout << endl;
    
    return 0;
}
```

**Python:**
```python
from math import gcd

def add_fraction(frac1, frac2):
    """
    Cộng hai phân số
    frac1, frac2: list [tử số, mẫu số]
    Trả về: list [tử số kết quả, mẫu số kết quả]
    """
    num1, den1 = frac1[0], frac1[1]
    num2, den2 = frac2[0], frac2[1]
    
    # Tìm mẫu chung (LCM)
    lcm_den = (den1 * den2) // gcd(den1, den2)
    
    # Quy đồng và cộng tử số
    result_num = num1 * (lcm_den // den1) + num2 * (lcm_den // den2)
    result_den = lcm_den
    
    # Rút gọn phân số
    common_factor = gcd(result_num, result_den)
    result_num //= common_factor
    result_den //= common_factor
    
    return [result_num, result_den]

def print_fraction(frac):
    """Hiển thị phân số dạng đẹp"""
    if frac[1] == 1:
        return str(frac[0])
    else:
        return f"{frac[0]}/{frac[1]}"

def main():
    # Nhập dữ liệu
    print("Nhap phan so thu nhat:")
    num1 = int(input("Tu so: "))
    den1 = int(input("Mau so: "))
    frac1 = [num1, den1]
    
    print("Nhap phan so thu hai:")
    num2 = int(input("Tu so: "))
    den2 = int(input("Mau so: "))
    frac2 = [num2, den2]
    
    # Tính toán
    result = add_fraction(frac1, frac2)
    
    # In kết quả
    print(f"Ket qua: {print_fraction(frac1)} + {print_fraction(frac2)} = {print_fraction(result)}")
    print(f"Dang mang: {result}")

if __name__ == "__main__":
    main()
```

### 4.3. Chương trình demo với nhiều test case

**C++:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

vector<int> addFraction(vector<int> a, vector<int> b) {
    int lcm_den = (a[1] * b[1]) / gcd(a[1], b[1]);
    int result_num = a[0] * (lcm_den / a[1]) + b[0] * (lcm_den / b[1]);
    int common_factor = gcd(result_num, lcm_den);
    
    return {result_num / common_factor, lcm_den / common_factor};
}

void testCase(vector<int> a, vector<int> b, string description) {
    cout << "\n=== " << description << " ===" << endl;
    cout << "Input: [" << a[0] << ", " << a[1] << "] + [" << b[0] << ", " << b[1] << "]" << endl;
    cout << "Phan so: " << a[0] << "/" << a[1] << " + " << b[0] << "/" << b[1] << endl;
    
    vector<int> result = addFraction(a, b);
    cout << "Output: [" << result[0] << ", " << result[1] << "]" << endl;
    cout << "Ket qua: " << result[0];
    if (result[1] != 1) cout << "/" << result[1];
    cout << endl;
}

int main() {
    cout << "CHUONG TRINH DEMO CONG HAI PHAN SO" << endl;
    
    // Test case 1
    testCase({1, 2}, {3, 2}, "Cung mau so");
    
    // Test case 2  
    testCase({1, 3}, {3, 9}, "Khac mau so - can rut gon");
    
    // Test case 3
    testCase({1, 5}, {3, 15}, "Mau so co boi chung");
    
    // Test case 4
    testCase({2, 7}, {3, 14}, "Truong hop phuc tap");
    
    // Test case 5
    testCase({1, 4}, {1, 6}, "Phan so nho");
    
    return 0;
}
```

**Python:**
```python
from math import gcd

def add_fraction(a, b):
    lcm_den = (a[1] * b[1]) // gcd(a[1], b[1])
    result_num = a[0] * (lcm_den // a[1]) + b[0] * (lcm_den // b[1])
    common_factor = gcd(result_num, lcm_den)
    return [result_num // common_factor, lcm_den // common_factor]

def test_case(a, b, description):
    print(f"\n=== {description} ===")
    print(f"Input: {a} + {b}")
    print(f"Phan so: {a[0]}/{a[1]} + {b[0]}/{b[1]}")
    
    result = add_fraction(a, b)
    print(f"Output: {result}")
    if result[1] == 1:
        print(f"Ket qua: {result[0]}")
    else:
        print(f"Ket qua: {result[0]}/{result[1]}")

def main():
    print("CHUONG TRINH DEMO CONG HAI PHAN SO")
    
    # Các test case
    test_cases = [
        ([1, 2], [3, 2], "Cung mau so"),
        ([1, 3], [3, 9], "Khac mau so - can rut gon"), 
        ([1, 5], [3, 15], "Mau so co boi chung"),
        ([2, 7], [3, 14], "Truong hop phuc tap"),
        ([1, 4], [1, 6], "Phan so nho")
    ]
    
    for a, b, desc in test_cases:
        test_case(a, b, desc)

if __name__ == "__main__":
    main()
```

## 5. PHÂN TÍCH ĐỘ PHỨC TẠP

### 5.1. Độ phức tạp thời gian
- **Hàm GCD**: O(log(min(a, b)))
- **Thuật toán chính**: O(log(min(b₁, b₂))) 
- **Tổng cộng**: O(log(min(b₁, b₂)))

### 5.2. Độ phức tạp không gian
- **Không gian phụ**: O(1) (chỉ sử dụng biến tạm)
- **Đệ quy GCD**: O(log(min(a, b))) cho stack

## 6. CÁC TRƯỜNG HỢP ĐẶC BIỆT

### 6.1. Xử lý số âm
```cpp
// Xử lý dấu âm
if (result_den < 0) {
    result_num = -result_num;
    result_den = -result_den;
}
```

### 6.2. Xử lý mẫu số = 0
```cpp
if (den1 == 0 || den2 == 0) {
    cout << "Loi: Mau so khong the bang 0!" << endl;
    return {0, 1};
}
```

### 6.3. Kết quả là số nguyên
```cpp
if (result_den == 1) {
    cout << "Ket qua la so nguyen: " << result_num << endl;
}
```

## 7. BÀI TẬP THỰC HÀNH

### Bài tập 1 (Cơ bản)
Viết chương trình cộng hai phân số và hiển thị kết quả dưới dạng tối giản.

### Bài tập 2 (Nâng cao)
Mở rộng chương trình để thực hiện các phép toán: cộng, trừ, nhân, chia phân số.

### Bài tập 3 (Ứng dụng)
Viết chương trình tính tổng của n phân số (n ≤ 100).

### Bài tập 4 (Thử thách)
Tạo lớp Fraction với các toán tử overloading (+, -, *, /) trong C++.

### Bài tập 5 (Tư duy)
Viết chương trình tìm phân số có mẫu số nhỏ nhất mà tổng của k phân số đã cho bằng phân số đó.

## 8. GỢI Ý GIẢI BÀI TẬP

### Bài tập 1:
- Sử dụng hàm addFraction() đã viết
- Thêm kiểm tra input hợp lệ
- Format output đẹp mắt

### Bài tập 2:
```cpp
// Gợi ý cấu trúc
struct Fraction {
    int num, den;
    Fraction add(Fraction other);
    Fraction subtract(Fraction other);
    Fraction multiply(Fraction other);
    Fraction divide(Fraction other);
};
```

### Bài tập 3:
```python
# Gợi ý Python
def sum_fractions(fractions_list):
    result = [0, 1]  # Bắt đầu từ 0/1
    for frac in fractions_list:
        result = add_fraction(result, frac)
    return result
```

### Bài tập 4:
```cpp
// Gợi ý operator overloading
class Fraction {
public:
    Fraction operator+(const Fraction& other);
    Fraction operator-(const Fraction& other);
    // ... các toán tử khác
};
```

## 9. MỞ RỘNG VÀ ỨNG DỤNG

### 9.1. Ứng dụng trong thực tế
- Tính toán tài chính (lãi suất, tỷ lệ)
- Đo lường và nấu ăn (tỷ lệ nguyên liệu)
- Âm nhạc (nhịp điệu, tần số)
- Xác suất và thống kê

### 9.2. Kết hợp với cấu trúc dữ liệu
- Sử dụng vector/array để lưu nhiều phân số
- Tạo danh sách liên kết các phân số
- Sắp xếp mảng phân số

### 9.3. Tối ưu hóa
- Sử dụng thuật toán GCD Binary (hiệu quả hơn với số lớn)
- Cache kết quả GCD để tránh tính lại
- Xử lý số lớn với BigInteger
