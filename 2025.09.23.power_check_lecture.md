# CHUYÃŠN Äá»€: KIá»‚M TRA LÅ¨Y THá»ªA

**DÃ nh cho há»c sinh lá»›p 10 chuyÃªn Tin há»c**

---

## ğŸ“‹ Má»¤C Lá»¤C
1. [Giá»›i thiá»‡u bÃ i toÃ¡n](#1-giá»›i-thiá»‡u-bÃ i-toÃ¡n)
2. [PhÃ¢n tÃ­ch bÃ i toÃ¡n](#2-phÃ¢n-tÃ­ch-bÃ i-toÃ¡n)
3. [CÃ¡c phÆ°Æ¡ng phÃ¡p giáº£i](#3-cÃ¡c-phÆ°Æ¡ng-phÃ¡p-giáº£i)
4. [Code minh há»a](#4-code-minh-há»a)
5. [So sÃ¡nh cÃ¡c phÆ°Æ¡ng phÃ¡p](#5-so-sÃ¡nh-cÃ¡c-phÆ°Æ¡ng-phÃ¡p)
6. [BÃ i táº­p thá»±c hÃ nh](#6-bÃ i-táº­p-thá»±c-hÃ nh)

---

## 1. GIá»šI THIá»†U BÃ€I TOÃN

### ğŸ“ PhÃ¡t biá»ƒu bÃ i toÃ¡n
Cho hai sá»‘ nguyÃªn dÆ°Æ¡ng x vÃ  y, kiá»ƒm tra xem y cÃ³ pháº£i lÃ  lÅ©y thá»«a cá»§a x hay khÃ´ng.

NÃ³i cÃ¡ch khÃ¡c: CÃ³ tá»“n táº¡i sá»‘ nguyÃªn k â‰¥ 0 sao cho x^k = y?

### ğŸ“Š VÃ­ dá»¥ tá»« GeeksforGeeks
```
Input: x = 10, y = 1
Output: True
Giáº£i thÃ­ch: 10^0 = 1

Input: x = 10, y = 1000  
Output: True
Giáº£i thÃ­ch: 10^3 = 1000

Input: x = 10, y = 1001
Output: False
Giáº£i thÃ­ch: KhÃ´ng cÃ³ k nÃ o Ä‘á»ƒ 10^k = 1001
```

### ğŸ¯ CÃ¡c trÆ°á»ng há»£p Ä‘áº·c biá»‡t
- **x = 1**: Chá»‰ cÃ³ 1^k = 1 vá»›i má»i k, nÃªn chá»‰ y = 1 má»›i Ä‘Ãºng
- **y = 1**: LuÃ´n Ä‘Ãºng vÃ¬ x^0 = 1 vá»›i má»i x > 0
- **x > y > 1**: KhÃ´ng thá»ƒ cÃ³ x^k = y vá»›i k â‰¥ 1

---

## 2. PHÃ‚N TÃCH BÃ€I TOÃN

### ğŸ” Ã tÆ°á»Ÿng cÆ¡ báº£n
Äá»ƒ kiá»ƒm tra y cÃ³ pháº£i lÅ©y thá»«a cá»§a x:
1. **NhÃ¢n dáº§n**: Báº¯t Ä‘áº§u tá»« 1, nhÃ¢n vá»›i x cho Ä‘áº¿n khi â‰¥ y
2. **So sÃ¡nh**: Náº¿u báº±ng y thÃ¬ Ä‘Ãºng, náº¿u vÆ°á»£t quÃ¡ thÃ¬ sai

### ğŸ¯ QuÃ¡ trÃ¬nh tÃ­nh toÃ¡n
VÃ­ dá»¥ vá»›i x = 2, y = 8:
```
BÆ°á»›c 1: pow = 1      (2^0 = 1 < 8)
BÆ°á»›c 2: pow = 1Ã—2 = 2   (2^1 = 2 < 8)  
BÆ°á»›c 3: pow = 2Ã—2 = 4   (2^2 = 4 < 8)
BÆ°á»›c 4: pow = 4Ã—2 = 8   (2^3 = 8 = 8) âœ“
```

### ğŸ”§ Äiá»u kiá»‡n dá»«ng
- **TÃ¬m tháº¥y**: pow = y â†’ Tráº£ vá» true
- **VÆ°á»£t quÃ¡**: pow > y â†’ Tráº£ vá» false

---

## 3. CÃC PHÆ¯Æ NG PHÃP GIáº¢I

### 3.1. PhÆ°Æ¡ng phÃ¡p Naive (NhÃ¢n dáº§n)
**Äá»™ phá»©c táº¡p**: O(log_x(y))

**Ã tÆ°á»Ÿng**: NhÃ¢n x liÃªn tiáº¿p cho Ä‘áº¿n khi Ä‘áº¡t hoáº·c vÆ°á»£t y.

### 3.2. PhÆ°Æ¡ng phÃ¡p Logarithm
**Äá»™ phá»©c táº¡p**: O(1)

**Ã tÆ°á»Ÿng**: Sá»­ dá»¥ng cÃ´ng thá»©c log_x(y) = log(y)/log(x). Náº¿u káº¿t quáº£ lÃ  sá»‘ nguyÃªn thÃ¬ y lÃ  lÅ©y thá»«a cá»§a x.

### 3.3. PhÆ°Æ¡ng phÃ¡p Binary Search (NÃ¢ng cao)
**Äá»™ phá»©c táº¡p**: O(log log y)

**Ã tÆ°á»Ÿng**: Káº¿t há»£p bÃ¬nh phÆ°Æ¡ng nhanh vÃ  tÃ¬m kiáº¿m nhá»‹ phÃ¢n.

---

## 4. CODE MINH Há»ŒA

### 4.1. Code C++

```cpp
#include <iostream>
#include <cmath>
#include <chrono>
using namespace std;

/**
 * PhÆ°Æ¡ng phÃ¡p 1: Naive - NhÃ¢n dáº§n
 * Äá»™ phá»©c táº¡p: O(log_x(y))
 */
bool isPowerNaive(int x, long long y) {
    // TrÆ°á»ng há»£p Ä‘áº·c biá»‡t: x = 1
    if (x == 1) {
        return (y == 1);
    }
    
    // NhÃ¢n dáº§n x cho Ä‘áº¿n khi Ä‘áº¡t hoáº·c vÆ°á»£t y
    long long pow = 1;
    while (pow < y) {
        pow *= x;
    }
    
    // Kiá»ƒm tra cÃ³ Ä‘Ãºng báº±ng y khÃ´ng
    return (pow == y);
}

/**
 * PhÆ°Æ¡ng phÃ¡p 2: Sá»­ dá»¥ng Logarithm
 * Äá»™ phá»©c táº¡p: O(1)
 */
bool isPowerLogarithm(int x, long long y) {
    // TrÆ°á»ng há»£p Ä‘áº·c biá»‡t
    if (x == 1) {
        return (y == 1);
    }
    if (y == 1) {
        return true;  // x^0 = 1
    }
    
    // TÃ­nh log_x(y) = log(y) / log(x)
    double result = log(y) / log(x);
    
    // Kiá»ƒm tra cÃ³ pháº£i sá»‘ nguyÃªn khÃ´ng
    return (result == floor(result));
}

/**
 * PhÆ°Æ¡ng phÃ¡p 3: Logarithm cáº£i tiáº¿n (xá»­ lÃ½ floating point)
 * Äá»™ phá»©c táº¡p: O(1)
 */
bool isPowerImproved(int x, long long y) {
    // TrÆ°á»ng há»£p Ä‘áº·c biá»‡t
    if (x == 1) {
        return (y == 1);
    }
    if (y == 1) {
        return true;
    }
    
    // TÃ­nh log_x(y) = log(y) / log(x)
    double result = log(y) / log(x);
    
    // LÃ m trÃ²n Ä‘á»ƒ trÃ¡nh lá»—i floating point
    int k = round(result);
    
    // Kiá»ƒm tra x^k cÃ³ báº±ng y khÃ´ng
    long long power = 1;
    for (int i = 0; i < k; i++) {
        power *= x;
        if (power > y) return false;  // TrÃ¡nh overflow
    }
    
    return (power == y);
}

/**
 * HÃ m demo vá»›i giáº£i thÃ­ch chi tiáº¿t
 */
void demoPowerCheck(int x, long long y) {
    cout << "\n=== DEMO: Kiá»ƒm tra " << y << " cÃ³ pháº£i lÅ©y thá»«a cá»§a " << x << " ===" << endl;
    
    // Hiá»ƒn thá»‹ quÃ¡ trÃ¬nh tÃ­nh báº±ng phÆ°Æ¡ng phÃ¡p naive
    cout << "\nPhÆ°Æ¡ng phÃ¡p 1 - NhÃ¢n dáº§n:" << endl;
    
    if (x == 1) {
        cout << "  TrÆ°á»ng há»£p Ä‘áº·c biá»‡t: x = 1" << endl;
        cout << "  Chá»‰ cÃ³ 1^k = 1 vá»›i má»i k" << endl;
        cout << "  Káº¿t quáº£: " << (y == 1 ? "true" : "false") << endl;
    } else {
        long long pow = 1;
        int k = 0;
        
        cout << "  Báº¯t Ä‘áº§u: pow = 1 (= " << x << "^0)" << endl;
        
        while (pow < y) {
            pow *= x;
            k++;
            cout << "  BÆ°á»›c " << k << ": pow = " << pow 
                 << " (= " << x << "^" << k << ")";
            
            if (pow == y) {
                cout << " âœ“ TÃ¬m tháº¥y!" << endl;
                break;
            } else if (pow > y) {
                cout << " âœ— VÆ°á»£t quÃ¡!" << endl;
                break;
            } else {
                cout << " (tiáº¿p tá»¥c...)" << endl;
            }
        }
    }
    
    // So sÃ¡nh káº¿t quáº£ cÃ¡c phÆ°Æ¡ng phÃ¡p
    cout << "\nSo sÃ¡nh káº¿t quáº£:" << endl;
    cout << "  Naive Method:       " << (isPowerNaive(x, y) ? "true" : "false") << endl;
    cout << "  Logarithm Method:   " << (isPowerLogarithm(x, y) ? "true" : "false") << endl;
    cout << "  Improved Method:    " << (isPowerImproved(x, y) ? "true" : "false") << endl;
    
    // Hiá»ƒn thá»‹ cÃ´ng thá»©c logarithm
    if (x != 1 && y != 1) {
        double logResult = log(y) / log(x);
        cout << "\nPhÃ¢n tÃ­ch Logarithm:" << endl;
        cout << "  log_" << x << "(" << y << ") = log(" << y << ")/log(" << x 
             << ") = " << logResult << endl;
        cout << "  CÃ³ pháº£i sá»‘ nguyÃªn? " << (logResult == floor(logResult) ? "CÃ³" : "KhÃ´ng") << endl;
    }
}

/**
 * HÃ m so sÃ¡nh hiá»‡u suáº¥t
 */
void comparePerformance() {
    cout << "\nâ±ï¸ SO SÃNH HIá»†U SUáº¤T:" << endl;
    
    const int iterations = 100000;
    vector<pair<int, long long>> testCases = {
        {2, 1024}, {3, 729}, {10, 1000000}, {5, 3125}
    };
    
    for (auto& test : testCases) {
        int x = test.first;
        long long y = test.second;
        
        cout << "\nTest case: x=" << x << ", y=" << y << endl;
        
        // Test Naive Method
        auto start = chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            isPowerNaive(x, y);
        }
        auto end = chrono::high_resolution_clock::now();
        auto duration1 = chrono::duration_cast<chrono::microseconds>(end - start);
        
        // Test Logarithm Method
        start = chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            isPowerLogarithm(x, y);
        }
        end = chrono::high_resolution_clock::now();
        auto duration2 = chrono::duration_cast<chrono::microseconds>(end - start);
        
        cout << "  Naive:     " << duration1.count() << " Î¼s" << endl;
        cout << "  Logarithm: " << duration2.count() << " Î¼s" << endl;
        cout << "  TÄƒng tá»‘c:  " << (double)duration1.count() / duration2.count() << "x" << endl;
    }
}

int main() {
    cout << "CHUYÃŠN Äá»€: KIá»‚M TRA LÅ¨Y THá»ªA" << endl;
    cout << "==============================" << endl;
    
    // Test vá»›i cÃ¡c vÃ­ dá»¥ tá»« GeeksforGeeks
    demoPowerCheck(10, 1);     // true (10^0 = 1)
    demoPowerCheck(10, 1000);  // true (10^3 = 1000)
    demoPowerCheck(10, 1001);  // false
    demoPowerCheck(2, 128);    // true (2^7 = 128)
    demoPowerCheck(2, 30);     // false
    demoPowerCheck(1, 20);     // false (chá»‰ 1^k = 1)
    
    // So sÃ¡nh hiá»‡u suáº¥t
    comparePerformance();
    
    return 0;
}
```

### 4.2. Code Python

```python
import math
import time

def is_power_naive(x, y):
    """
    PhÆ°Æ¡ng phÃ¡p 1: Naive - NhÃ¢n dáº§n
    Äá»™ phá»©c táº¡p: O(log_x(y))
    """
    # TrÆ°á»ng há»£p Ä‘áº·c biá»‡t: x = 1
    if x == 1:
        return y == 1
    
    # NhÃ¢n dáº§n x cho Ä‘áº¿n khi Ä‘áº¡t hoáº·c vÆ°á»£t y
    pow = 1
    while pow < y:
        pow *= x
    
    # Kiá»ƒm tra cÃ³ Ä‘Ãºng báº±ng y khÃ´ng
    return pow == y

def is_power_logarithm(x, y):
    """
    PhÆ°Æ¡ng phÃ¡p 2: Sá»­ dá»¥ng Logarithm
    Äá»™ phá»©c táº¡p: O(1)
    """
    # TrÆ°á»ng há»£p Ä‘áº·c biá»‡t
    if x == 1:
        return y == 1
    if y == 1:
        return True  # x^0 = 1
    
    # TÃ­nh log_x(y) = log(y) / log(x)
    result = math.log(y) / math.log(x)
    
    # Kiá»ƒm tra cÃ³ pháº£i sá»‘ nguyÃªn khÃ´ng
    return result == math.floor(result)

def is_power_improved(x, y):
    """
    PhÆ°Æ¡ng phÃ¡p 3: Logarithm cáº£i tiáº¿n (xá»­ lÃ½ floating point)
    Äá»™ phá»©c táº¡p: O(1)
    """
    # TrÆ°á»ng há»£p Ä‘áº·c biá»‡t
    if x == 1:
        return y == 1
    if y == 1:
        return True
    
    # TÃ­nh log_x(y) = log(y) / log(x)
    result = math.log(y) / math.log(x)
    
    # LÃ m trÃ²n Ä‘á»ƒ trÃ¡nh lá»—i floating point
    k = round(result)
    
    # Kiá»ƒm tra x^k cÃ³ báº±ng y khÃ´ng
    return x ** k == y

def demo_power_check(x, y):
    """Demo vá»›i giáº£i thÃ­ch chi tiáº¿t"""
    print(f"\n=== DEMO: Kiá»ƒm tra {y} cÃ³ pháº£i lÅ©y thá»«a cá»§a {x} ===")
    
    # Hiá»ƒn thá»‹ quÃ¡ trÃ¬nh tÃ­nh báº±ng phÆ°Æ¡ng phÃ¡p naive
    print(f"\nPhÆ°Æ¡ng phÃ¡p 1 - NhÃ¢n dáº§n:")
    
    if x == 1:
        print(f"  TrÆ°á»ng há»£p Ä‘áº·c biá»‡t: x = 1")
        print(f"  Chá»‰ cÃ³ 1^k = 1 vá»›i má»i k")
        print(f"  Káº¿t quáº£: {y == 1}")
    else:
        pow = 1
        k = 0
        
        print(f"  Báº¯t Ä‘áº§u: pow = 1 (= {x}^0)")
        
        while pow < y:
            pow *= x
            k += 1
            print(f"  BÆ°á»›c {k}: pow = {pow} (= {x}^{k})", end="")
            
            if pow == y:
                print(f" âœ“ TÃ¬m tháº¥y!")
                break
            elif pow > y:
                print(f" âœ— VÆ°á»£t quÃ¡!")
                break
            else:
                print(f" (tiáº¿p tá»¥c...)")
    
    # So sÃ¡nh káº¿t quáº£ cÃ¡c phÆ°Æ¡ng phÃ¡p
    print(f"\nSo sÃ¡nh káº¿t quáº£:")
    print(f"  Naive Method:       {is_power_naive(x, y)}")
    print(f"  Logarithm Method:   {is_power_logarithm(x, y)}")
    print(f"  Improved Method:    {is_power_improved(x, y)}")
    
    # Hiá»ƒn thá»‹ cÃ´ng thá»©c logarithm
    if x != 1 and y != 1:
        log_result = math.log(y) / math.log(x)
        print(f"\nPhÃ¢n tÃ­ch Logarithm:")
        print(f"  log_{x}({y}) = log({y})/log({x}) = {log_result:.6f}")
        print(f"  CÃ³ pháº£i sá»‘ nguyÃªn? {'CÃ³' if log_result == math.floor(log_result) else 'KhÃ´ng'}")

def compare_performance():
    """So sÃ¡nh hiá»‡u suáº¥t cÃ¡c phÆ°Æ¡ng phÃ¡p"""
    print(f"\nâ±ï¸ SO SÃNH HIá»†U SUáº¤T:")
    
    iterations = 100000
    test_cases = [
        (2, 1024), (3, 729), (10, 1000000), (5, 3125)
    ]
    
    for x, y in test_cases:
        print(f"\nTest case: x={x}, y={y}")
        
        # Test Naive Method
        start = time.perf_counter()
        for _ in range(iterations):
            is_power_naive(x, y)
        duration1 = (time.perf_counter() - start) * 1000  # ms
        
        # Test Logarithm Method
        start = time.perf_counter()
        for _ in range(iterations):
            is_power_logarithm(x, y)
        duration2 = (time.perf_counter() - start) * 1000  # ms
        
        print(f"  Naive:     {duration1:.2f} ms")
        print(f"  Logarithm: {duration2:.2f} ms")
        if duration2 > 0:
            print(f"  TÄƒng tá»‘c:  {duration1/duration2:.1f}x")

def find_all_powers(x, max_y):
    """TÃ¬m táº¥t cáº£ lÅ©y thá»«a cá»§a x khÃ´ng vÆ°á»£t quÃ¡ max_y"""
    powers = []
    power = 1
    k = 0
    
    while power <= max_y:
        powers.append((k, power))
        power *= x
        k += 1
    
    return powers

def main():
    print("CHUYÃŠN Äá»€: KIá»‚M TRA LÅ¨Y THá»ªA")
    print("==============================")
    
    # Test vá»›i cÃ¡c vÃ­ dá»¥ tá»« GeeksforGeeks
    demo_power_check(10, 1)     # true (10^0 = 1)
    demo_power_check(10, 1000)  # true (10^3 = 1000)
    demo_power_check(10, 1001)  # false
    demo_power_check(2, 128)    # true (2^7 = 128)
    demo_power_check(2, 30)     # false
    demo_power_check(1, 20)     # false (chá»‰ 1^k = 1)
    
    # So sÃ¡nh hiá»‡u suáº¥t
    compare_performance()
    
    # TÃ¬m táº¥t cáº£ lÅ©y thá»«a cá»§a 2 khÃ´ng vÆ°á»£t quÃ¡ 1000
    print(f"\nğŸ”¢ Táº¤T Cáº¢ LÅ¨Y THá»ªA Cá»¦A 2 KHÃ”NG VÆ¯á»¢T QUÃ 1000:")
    powers_of_2 = find_all_powers(2, 1000)
    for k, power in powers_of_2:
        print(f"  2^{k} = {power}")

if __name__ == "__main__":
    main()
```

---

## 5. SO SÃNH CÃC PHÆ¯Æ NG PHÃP

### ğŸ“Š Báº£ng so sÃ¡nh

| PhÆ°Æ¡ng phÃ¡p | Äá»™ phá»©c táº¡p | Äá»™ chÃ­nh xÃ¡c | Æ¯u Ä‘iá»ƒm | NhÆ°á»£c Ä‘iá»ƒm |
|-------------|-------------|--------------|---------|------------|
| **Naive** | O(log_x(y)) | 100% | ChÃ­nh xÃ¡c tuyá»‡t Ä‘á»‘i | Cháº­m vá»›i y lá»›n |
| **Logarithm** | O(1) | ~99% | Ráº¥t nhanh | Lá»—i floating point |
| **Improved** | O(log_x(y)) | 100% | Nhanh + chÃ­nh xÃ¡c | Phá»©c táº¡p hÆ¡n |

### ğŸ¯ PhÃ¢n tÃ­ch chi tiáº¿t

#### 1. PhÆ°Æ¡ng phÃ¡p Naive:
```cpp
long long pow = 1;
while (pow < y) {
    pow *= x;  // NhÃ¢n tá»«ng bÆ°á»›c
}
return (pow == y);
```
**Æ¯u Ä‘iá»ƒm**: LuÃ´n chÃ­nh xÃ¡c, khÃ´ng cÃ³ lá»—i floating point.
**NhÆ°á»£c Ä‘iá»ƒm**: Cháº­m khi y ráº¥t lá»›n.

#### 2. PhÆ°Æ¡ng phÃ¡p Logarithm:
```cpp
double result = log(y) / log(x);
return (result == floor(result));
```
**Æ¯u Ä‘iá»ƒm**: Ráº¥t nhanh, O(1).
**NhÆ°á»£c Ä‘iá»ƒm**: CÃ³ thá»ƒ cÃ³ lá»—i do Ä‘á»™ chÃ­nh xÃ¡c floating point.

#### 3. PhÆ°Æ¡ng phÃ¡p Improved:
```cpp
double result = log(y) / log(x);
int k = round(result);
return (pow(x, k) == y);
```
**Æ¯u Ä‘iá»ƒm**: Káº¿t há»£p tá»‘c Ä‘á»™ vÃ  Ä‘á»™ chÃ­nh xÃ¡c.

### âš ï¸ Váº¥n Ä‘á» Floating Point

```python
# VÃ­ dá»¥ vá» lá»—i floating point
import math

x, y = 3, 27
result = math.log(y) / math.log(x)
print(f"log_3(27) = {result}")          # 2.9999999999999996
print(f"CÃ³ pháº£i 3.0? {result == 3.0}")  # False!

# Giáº£i phÃ¡p: sá»­ dá»¥ng round()
k = round(result)
print(f"LÃ m trÃ²n: {k}")                 # 3
print(f"3^3 = {3**k}")                  # 27
```

---

## 6. BÃ€I Táº¬P THá»°C HÃ€NH

### ğŸ“ BÃ i táº­p cÆ¡ báº£n

**BÃ i 1**: Viáº¿t chÆ°Æ¡ng trÃ¬nh nháº­p x vÃ  y, kiá»ƒm tra y cÃ³ pháº£i lÅ©y thá»«a cá»§a x khÃ´ng.

**BÃ i 2**: TÃ¬m táº¥t cáº£ lÅ©y thá»«a cá»§a 2 tá»« 2^0 Ä‘áº¿n 2^20.

**BÃ i 3**: Cho má»™t sá»‘ n, tÃ¬m x nhá» nháº¥t sao cho x^k = n vá»›i k â‰¥ 2.

### ğŸ”¥ BÃ i táº­p nÃ¢ng cao

**BÃ i 4**: **Perfect Power**: Kiá»ƒm tra má»™t sá»‘ cÃ³ pháº£i lÃ  lÅ©y thá»«a báº­c k cá»§a má»™t sá»‘ nguyÃªn nÃ o Ä‘Ã³ khÃ´ng.
```cpp
// VÃ­ dá»¥: 8 = 2^3 (perfect cube), 16 = 2^4 (perfect 4th power)
bool isPerfectPower(int n, int k) {
    int root = round(pow(n, 1.0/k));
    return pow(root, k) == n;
}
```

**BÃ i 5**: **Power Tower**: TÃ­nh x^(x^(x^...)) vá»›i chiá»u cao h.
```cpp
// VÃ­ dá»¥: 2^(2^2) = 2^4 = 16
long long powerTower(int x, int height) {
    if (height == 1) return x;
    return pow(x, powerTower(x, height - 1));
}
```

**BÃ i 6**: **Largest Power**: TÃ¬m lÅ©y thá»«a lá»›n nháº¥t cá»§a x khÃ´ng vÆ°á»£t quÃ¡ n.

### ğŸ’¡ BÃ i táº­p á»©ng dá»¥ng

**BÃ i 7**: **Binary Representation**: Kiá»ƒm tra má»™t sá»‘ cÃ³ pháº£i lÃ  lÅ©y thá»«a cá»§a 2 khÃ´ng (bit manipulation).
```cpp
bool isPowerOf2(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```

**BÃ i 8**: **Scientific Notation**: Chuyá»ƒn Ä‘á»•i sá»‘ thÃ nh dáº¡ng a Ã— 10^b.

**BÃ i 9**: **Logarithmic Scale**: Váº½ biá»ƒu Ä‘á»“ logarithmic vá»›i cÃ¡c má»©c 10^k.

### ğŸš€ BÃ i táº­p thÃ¡ch thá»©c

**BÃ i 10**: **Fast Exponentiation**: Implement thuáº­t toÃ¡n tÃ­nh x^n nhanh báº±ng binary exponentiation.

**BÃ i 11**: **Modular Exponentiation**: TÃ­nh (x^n) mod m hiá»‡u quáº£.

**BÃ i 12**: **Power Sum**: TÃ¬m táº¥t cáº£ cÃ¡ch biá»ƒu diá»…n n dÆ°á»›i dáº¡ng tá»•ng cÃ¡c lÅ©y thá»«a.
```
VÃ­ dá»¥: 100 = 10^2 = 1^4 + 3^4 + 5^4 + 6^4
```

---

## 7. TÃ“M Táº®T

### ğŸ¯ Nhá»¯ng Ä‘iá»u cáº§n nhá»›

1. **Ba phÆ°Æ¡ng phÃ¡p chÃ­nh**: Naive (chÃ­nh xÃ¡c), Logarithm (nhanh), Improved (cÃ¢n báº±ng)
2. **TrÆ°á»ng há»£p Ä‘áº·c biá»‡t**: x=1 (chá»‰ y=1), y=1 (luÃ´n Ä‘Ãºng vá»›i x^0=1)
3. **CÃ´ng thá»©c logarithm**: log_x(y) = log(y)/log(x)
4. **Váº¥n Ä‘á» floating point**: Cáº§n lÃ m trÃ²n káº¿t quáº£

### ğŸš€ Ká»¹ nÄƒng Ä‘Ã£ há»c

- Hiá»ƒu vá» lÅ©y thá»«a vÃ  logarithm
- Xá»­ lÃ½ cÃ¡c trÆ°á»ng há»£p Ä‘áº·c biá»‡t
- So sÃ¡nh hiá»‡u suáº¥t cÃ¡c thuáº­t toÃ¡n
- Giáº£i quyáº¿t váº¥n Ä‘á» floating point precision

### ğŸ“ˆ á»¨ng dá»¥ng thá»±c táº¿

- **Computer Graphics**: Scaling, transformations
- **Cryptography**: RSA, Diffie-Hellman key exchange
- **Scientific Computing**: Exponential models, growth rates
- **Data Analysis**: Logarithmic scales, power laws

### ğŸ“š BÆ°á»›c tiáº¿p theo

- Thá»±c hÃ nh cÃ¡c bÃ i táº­p trong chuyÃªn Ä‘á»
- TÃ¬m hiá»ƒu vá» fast exponentiation vÃ  modular arithmetic
- Ãp dá»¥ng vÃ o bÃ i toÃ¡n cryptography
- NghiÃªn cá»©u vá» numerical methods vÃ  precision

---

**ğŸ“ ChÃºc cÃ¡c em náº¯m vá»¯ng kiáº¿n thá»©c vá» lÅ©y thá»«a vÃ  logarithm!**