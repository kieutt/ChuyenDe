# CHUY√äN ƒê·ªÄ: KI·ªÇM TRA L≈®Y TH·ª™A

**D√†nh cho h·ªçc sinh l·ªõp 10 chuy√™n Tin h·ªçc**

---

## üìã M·ª§C L·ª§C
1. [Gi·ªõi thi·ªáu b√†i to√°n](#1-gi·ªõi-thi·ªáu-b√†i-to√°n)
2. [Ph√¢n t√≠ch b√†i to√°n](#2-ph√¢n-t√≠ch-b√†i-to√°n)
3. [C√°c ph∆∞∆°ng ph√°p gi·∫£i](#3-c√°c-ph∆∞∆°ng-ph√°p-gi·∫£i)
4. [Code minh h·ªça](#4-code-minh-h·ªça)
5. [So s√°nh c√°c ph∆∞∆°ng ph√°p](#5-so-s√°nh-c√°c-ph∆∞∆°ng-ph√°p)
6. [B√†i t·∫≠p th·ª±c h√†nh](#6-b√†i-t·∫≠p-th·ª±c-h√†nh)

---

## 1. GI·ªöI THI·ªÜU B√ÄI TO√ÅN

### üìù Ph√°t bi·ªÉu b√†i to√°n
Cho hai s·ªë nguy√™n d∆∞∆°ng x v√† y, ki·ªÉm tra xem y c√≥ ph·∫£i l√† l≈©y th·ª´a c·ªßa x hay kh√¥ng.

N√≥i c√°ch kh√°c: C√≥ t·ªìn t·∫°i s·ªë nguy√™n k ‚â• 0 sao cho x^k = y?

### üìä V√≠ d·ª• t·ª´ GeeksforGeeks
```
Input: x = 10, y = 1
Output: True
Gi·∫£i th√≠ch: 10^0 = 1

Input: x = 10, y = 1000  
Output: True
Gi·∫£i th√≠ch: 10^3 = 1000

Input: x = 10, y = 1001
Output: False
Gi·∫£i th√≠ch: Kh√¥ng c√≥ k n√†o ƒë·ªÉ 10^k = 1001
```

### üéØ C√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
- **x = 1**: Ch·ªâ c√≥ 1^k = 1 v·ªõi m·ªçi k, n√™n ch·ªâ y = 1 m·ªõi ƒë√∫ng
- **y = 1**: Lu√¥n ƒë√∫ng v√¨ x^0 = 1 v·ªõi m·ªçi x > 0
- **x > y > 1**: Kh√¥ng th·ªÉ c√≥ x^k = y v·ªõi k ‚â• 1

---

## 2. PH√ÇN T√çCH B√ÄI TO√ÅN

### üîç √ù t∆∞·ªüng c∆° b·∫£n
ƒê·ªÉ ki·ªÉm tra y c√≥ ph·∫£i l≈©y th·ª´a c·ªßa x:
1. **Nh√¢n d·∫ßn**: B·∫Øt ƒë·∫ßu t·ª´ 1, nh√¢n v·ªõi x cho ƒë·∫øn khi ‚â• y
2. **So s√°nh**: N·∫øu b·∫±ng y th√¨ ƒë√∫ng, n·∫øu v∆∞·ª£t qu√° th√¨ sai

### üéØ Qu√° tr√¨nh t√≠nh to√°n
V√≠ d·ª• v·ªõi x = 2, y = 8:
```
B∆∞·ªõc 1: pow = 1      (2^0 = 1 < 8)
B∆∞·ªõc 2: pow = 1√ó2 = 2   (2^1 = 2 < 8)  
B∆∞·ªõc 3: pow = 2√ó2 = 4   (2^2 = 4 < 8)
B∆∞·ªõc 4: pow = 4√ó2 = 8   (2^3 = 8 = 8) ‚úì
```

### üîß ƒêi·ªÅu ki·ªán d·ª´ng
- **T√¨m th·∫•y**: pow = y ‚Üí Tr·∫£ v·ªÅ true
- **V∆∞·ª£t qu√°**: pow > y ‚Üí Tr·∫£ v·ªÅ false

---

## 3. C√ÅC PH∆Ø∆†NG PH√ÅP GI·∫¢I

### 3.1. Ph∆∞∆°ng ph√°p Naive (Nh√¢n d·∫ßn)
**ƒê·ªô ph·ª©c t·∫°p**: O(log_x(y))

**√ù t∆∞·ªüng**: Nh√¢n x li√™n ti·∫øp cho ƒë·∫øn khi ƒë·∫°t ho·∫∑c v∆∞·ª£t y.

### 3.2. Ph∆∞∆°ng ph√°p Logarithm
**ƒê·ªô ph·ª©c t·∫°p**: O(1)

**√ù t∆∞·ªüng**: S·ª≠ d·ª•ng c√¥ng th·ª©c log_x(y) = log(y)/log(x). N·∫øu k·∫øt qu·∫£ l√† s·ªë nguy√™n th√¨ y l√† l≈©y th·ª´a c·ªßa x.

### 3.3. Ph∆∞∆°ng ph√°p Binary Search (N√¢ng cao)
**ƒê·ªô ph·ª©c t·∫°p**: O(log log y)

**√ù t∆∞·ªüng**: K·∫øt h·ª£p b√¨nh ph∆∞∆°ng nhanh v√† t√¨m ki·∫øm nh·ªã ph√¢n.

---

## 4. CODE MINH H·ªåA

### 4.1. Code C++

```cpp
#include <iostream>
#include <cmath>
#include <chrono>
using namespace std;

/**
 * Ph∆∞∆°ng ph√°p 1: Naive - Nh√¢n d·∫ßn
 * ƒê·ªô ph·ª©c t·∫°p: O(log_x(y))
 */
bool isPowerNaive(int x, long long y) {
    // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát: x = 1
    if (x == 1) {
        return (y == 1);
    }
    
    // Nh√¢n d·∫ßn x cho ƒë·∫øn khi ƒë·∫°t ho·∫∑c v∆∞·ª£t y
    long long pow = 1;
    while (pow < y) {
        pow *= x;
    }
    
    // Ki·ªÉm tra c√≥ ƒë√∫ng b·∫±ng y kh√¥ng
    return (pow == y);
}

/**
 * Ph∆∞∆°ng ph√°p 2: S·ª≠ d·ª•ng Logarithm
 * ƒê·ªô ph·ª©c t·∫°p: O(1)
 */
bool isPowerLogarithm(int x, long long y) {
    // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if (x == 1) {
        return (y == 1);
    }
    if (y == 1) {
        return true;  // x^0 = 1
    }
    
    // T√≠nh log_x(y) = log(y) / log(x)
    double result = log(y) / log(x);
    
    // Ki·ªÉm tra c√≥ ph·∫£i s·ªë nguy√™n kh√¥ng
    return (result == floor(result));
}

/**
 * Ph∆∞∆°ng ph√°p 3: Logarithm c·∫£i ti·∫øn (x·ª≠ l√Ω floating point)
 * ƒê·ªô ph·ª©c t·∫°p: O(1)
 */
bool isPowerImproved(int x, long long y) {
    // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if (x == 1) {
        return (y == 1);
    }
    if (y == 1) {
        return true;
    }
    
    // T√≠nh log_x(y) = log(y) / log(x)
    double result = log(y) / log(x);
    
    // L√†m tr√≤n ƒë·ªÉ tr√°nh l·ªói floating point
    int k = round(result);
    
    // Ki·ªÉm tra x^k c√≥ b·∫±ng y kh√¥ng
    long long power = 1;
    for (int i = 0; i < k; i++) {
        power *= x;
        if (power > y) return false;  // Tr√°nh overflow
    }
    
    return (power == y);
}

/**
 * H√†m demo v·ªõi gi·∫£i th√≠ch chi ti·∫øt
 */
void demoPowerCheck(int x, long long y) {
    cout << "\n=== DEMO: Ki·ªÉm tra " << y << " c√≥ ph·∫£i l≈©y th·ª´a c·ªßa " << x << " ===" << endl;
    
    // Hi·ªÉn th·ªã qu√° tr√¨nh t√≠nh b·∫±ng ph∆∞∆°ng ph√°p naive
    cout << "\nPh∆∞∆°ng ph√°p 1 - Nh√¢n d·∫ßn:" << endl;
    
    if (x == 1) {
        cout << "  Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát: x = 1" << endl;
        cout << "  Ch·ªâ c√≥ 1^k = 1 v·ªõi m·ªçi k" << endl;
        cout << "  K·∫øt qu·∫£: " << (y == 1 ? "true" : "false") << endl;
    } else {
        long long pow = 1;
        int k = 0;
        
        cout << "  B·∫Øt ƒë·∫ßu: pow = 1 (= " << x << "^0)" << endl;
        
        while (pow < y) {
            pow *= x;
            k++;
            cout << "  B∆∞·ªõc " << k << ": pow = " << pow 
                 << " (= " << x << "^" << k << ")";
            
            if (pow == y) {
                cout << " ‚úì T√¨m th·∫•y!" << endl;
                break;
            } else if (pow > y) {
                cout << " ‚úó V∆∞·ª£t qu√°!" << endl;
                break;
            } else {
                cout << " (ti·∫øp t·ª•c...)" << endl;
            }
        }
    }
    
    // So s√°nh k·∫øt qu·∫£ c√°c ph∆∞∆°ng ph√°p
    cout << "\nSo s√°nh k·∫øt qu·∫£:" << endl;
    cout << "  Naive Method:       " << (isPowerNaive(x, y) ? "true" : "false") << endl;
    cout << "  Logarithm Method:   " << (isPowerLogarithm(x, y) ? "true" : "false") << endl;
    cout << "  Improved Method:    " << (isPowerImproved(x, y) ? "true" : "false") << endl;
    
    // Hi·ªÉn th·ªã c√¥ng th·ª©c logarithm
    if (x != 1 && y != 1) {
        double logResult = log(y) / log(x);
        cout << "\nPh√¢n t√≠ch Logarithm:" << endl;
        cout << "  log_" << x << "(" << y << ") = log(" << y << ")/log(" << x 
             << ") = " << logResult << endl;
        cout << "  C√≥ ph·∫£i s·ªë nguy√™n? " << (logResult == floor(logResult) ? "C√≥" : "Kh√¥ng") << endl;
    }
}

/**
 * H√†m so s√°nh hi·ªáu su·∫•t
 */
void comparePerformance() {
    cout << "\n‚è±Ô∏è SO S√ÅNH HI·ªÜU SU·∫§T:" << endl;
    
    const int iterations = 100000;
    vector<pair<int, long long>> testCases = {
        {2, 1024}, {3, 729}, {10, 1000000}, {5, 3125}
    };
    
    for (auto& test : testCases) {
        int x = test.first;
        long long y = test.second;
        
        cout << "\nTest case: x=" << x << ", y=" << y << endl;
        
        // Test Naive Method
        auto start = chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            isPowerNaive(x, y);
        }
        auto end = chrono::high_resolution_clock::now();
        auto duration1 = chrono::duration_cast<chrono::microseconds>(end - start);
        
        // Test Logarithm Method
        start = chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            isPowerLogarithm(x, y);
        }
        end = chrono::high_resolution_clock::now();
        auto duration2 = chrono::duration_cast<chrono::microseconds>(end - start);
        
        cout << "  Naive:     " << duration1.count() << " Œºs" << endl;
        cout << "  Logarithm: " << duration2.count() << " Œºs" << endl;
        cout << "  TƒÉng t·ªëc:  " << (double)duration1.count() / duration2.count() << "x" << endl;
    }
}

int main() {
    cout << "CHUY√äN ƒê·ªÄ: KI·ªÇM TRA L≈®Y TH·ª™A" << endl;
    cout << "==============================" << endl;
    
    // Test v·ªõi c√°c v√≠ d·ª• t·ª´ GeeksforGeeks
    demoPowerCheck(10, 1);     // true (10^0 = 1)
    demoPowerCheck(10, 1000);  // true (10^3 = 1000)
    demoPowerCheck(10, 1001);  // false
    demoPowerCheck(2, 128);    // true (2^7 = 128)
    demoPowerCheck(2, 30);     // false
    demoPowerCheck(1, 20);     // false (ch·ªâ 1^k = 1)
    
    // So s√°nh hi·ªáu su·∫•t
    comparePerformance();
    
    return 0;
}
```

### 4.2. Code Python

```python
import math
import time

def is_power_naive(x, y):
    """
    Ph∆∞∆°ng ph√°p 1: Naive - Nh√¢n d·∫ßn
    ƒê·ªô ph·ª©c t·∫°p: O(log_x(y))
    """
    # Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát: x = 1
    if x == 1:
        return y == 1
    
    # Nh√¢n d·∫ßn x cho ƒë·∫øn khi ƒë·∫°t ho·∫∑c v∆∞·ª£t y
    pow = 1
    while pow < y:
        pow *= x
    
    # Ki·ªÉm tra c√≥ ƒë√∫ng b·∫±ng y kh√¥ng
    return pow == y

def is_power_logarithm(x, y):
    """
    Ph∆∞∆°ng ph√°p 2: S·ª≠ d·ª•ng Logarithm
    ƒê·ªô ph·ª©c t·∫°p: O(1)
    """
    # Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if x == 1:
        return y == 1
    if y == 1:
        return True  # x^0 = 1
    
    # T√≠nh log_x(y) = log(y) / log(x)
    result = math.log(y) / math.log(x)
    
    # Ki·ªÉm tra c√≥ ph·∫£i s·ªë nguy√™n kh√¥ng
    return result == math.floor(result)

def is_power_improved(x, y):
    """
    Ph∆∞∆°ng ph√°p 3: Logarithm c·∫£i ti·∫øn (x·ª≠ l√Ω floating point)
    ƒê·ªô ph·ª©c t·∫°p: O(1)
    """
    # Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if x == 1:
        return y == 1
    if y == 1:
        return True
    
    # T√≠nh log_x(y) = log(y) / log(x)
    result = math.log(y) / math.log(x)
    
    # L√†m tr√≤n ƒë·ªÉ tr√°nh l·ªói floating point
    k = round(result)
    
    # Ki·ªÉm tra x^k c√≥ b·∫±ng y kh√¥ng
    return x ** k == y

def demo_power_check(x, y):
    """Demo v·ªõi gi·∫£i th√≠ch chi ti·∫øt"""
    print(f"\n=== DEMO: Ki·ªÉm tra {y} c√≥ ph·∫£i l≈©y th·ª´a c·ªßa {x} ===")
    
    # Hi·ªÉn th·ªã qu√° tr√¨nh t√≠nh b·∫±ng ph∆∞∆°ng ph√°p naive
    print(f"\nPh∆∞∆°ng ph√°p 1 - Nh√¢n d·∫ßn:")
    
    if x == 1:
        print(f"  Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát: x = 1")
        print(f"  Ch·ªâ c√≥ 1^k = 1 v·ªõi m·ªçi k")
        print(f"  K·∫øt qu·∫£: {y == 1}")
    else:
        pow = 1
        k = 0
        
        print(f"  B·∫Øt ƒë·∫ßu: pow = 1 (= {x}^0)")
        
        while pow < y:
            pow *= x
            k += 1
            print(f"  B∆∞·ªõc {k}: pow = {pow} (= {x}^{k})", end="")
            
            if pow == y:
                print(f" ‚úì T√¨m th·∫•y!")
                break
            elif pow > y:
                print(f" ‚úó V∆∞·ª£t qu√°!")
                break
            else:
                print(f" (ti·∫øp t·ª•c...)")
    
    # So s√°nh k·∫øt qu·∫£ c√°c ph∆∞∆°ng ph√°p
    print(f"\nSo s√°nh k·∫øt qu·∫£:")
    print(f"  Naive Method:       {is_power_naive(x, y)}")
    print(f"  Logarithm Method:   {is_power_logarithm(x, y)}")
    print(f"  Improved Method:    {is_power_improved(x, y)}")
    
    # Hi·ªÉn th·ªã c√¥ng th·ª©c logarithm
    if x != 1 and y != 1:
        log_result = math.log(y) / math.log(x)
        print(f"\nPh√¢n t√≠ch Logarithm:")
        print(f"  log_{x}({y}) = log({y})/log({x}) = {log_result:.6f}")
        print(f"  C√≥ ph·∫£i s·ªë nguy√™n? {'C√≥' if log_result == math.floor(log_result) else 'Kh√¥ng'}")

def compare_performance():
    """So s√°nh hi·ªáu su·∫•t c√°c ph∆∞∆°ng ph√°p"""
    print(f"\n‚è±Ô∏è SO S√ÅNH HI·ªÜU SU·∫§T:")
    
    iterations = 100000
    test_cases = [
        (2, 1024), (3, 729), (10, 1000000), (5, 3125)
    ]
    
    for x, y in test_cases:
        print(f"\nTest case: x={x}, y={y}")
        
        # Test Naive Method
        start = time.perf_counter()
        for _ in range(iterations):
            is_power_naive(x, y)
        duration1 = (time.perf_counter() - start) * 1000  # ms
        
        # Test Logarithm Method
        start = time.perf_counter()
        for _ in range(iterations):
            is_power_logarithm(x, y)
        duration2 = (time.perf_counter() - start) * 1000  # ms
        
        print(f"  Naive:     {duration1:.2f} ms")
        print(f"  Logarithm: {duration2:.2f} ms")
        if duration2 > 0:
            print(f"  TƒÉng t·ªëc:  {duration1/duration2:.1f}x")

def find_all_powers(x, max_y):
    """T√¨m t·∫•t c·∫£ l≈©y th·ª´a c·ªßa x kh√¥ng v∆∞·ª£t qu√° max_y"""
    powers = []
    power = 1
    k = 0
    
    while power <= max_y:
        powers.append((k, power))
        power *= x
        k += 1
    
    return powers

def main():
    print("CHUY√äN ƒê·ªÄ: KI·ªÇM TRA L≈®Y TH·ª™A")
    print("==============================")
    
    # Test v·ªõi c√°c v√≠ d·ª• t·ª´ GeeksforGeeks
    demo_power_check(10, 1)     # true (10^0 = 1)
    demo_power_check(10, 1000)  # true (10^3 = 1000)
    demo_power_check(10, 1001)  # false
    demo_power_check(2, 128)    # true (2^7 = 128)
    demo_power_check(2, 30)     # false
    demo_power_check(1, 20)     # false (ch·ªâ 1^k = 1)
    
    # So s√°nh hi·ªáu su·∫•t
    compare_performance()
    
    # T√¨m t·∫•t c·∫£ l≈©y th·ª´a c·ªßa 2 kh√¥ng v∆∞·ª£t qu√° 1000
    print(f"\nüî¢ T·∫§T C·∫¢ L≈®Y TH·ª™A C·ª¶A 2 KH√îNG V∆Ø·ª¢T QU√Å 1000:")
    powers_of_2 = find_all_powers(2, 1000)
    for k, power in powers_of_2:
        print(f"  2^{k} = {power}")

if __name__ == "__main__":
    main()
```

---

## 5. SO S√ÅNH C√ÅC PH∆Ø∆†NG PH√ÅP

### üìä B·∫£ng so s√°nh

| Ph∆∞∆°ng ph√°p | ƒê·ªô ph·ª©c t·∫°p | ƒê·ªô ch√≠nh x√°c | ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm |
|-------------|-------------|--------------|---------|------------|
| **Naive** | O(log_x(y)) | 100% | Ch√≠nh x√°c tuy·ªát ƒë·ªëi | Ch·∫≠m v·ªõi y l·ªõn |
| **Logarithm** | O(1) | ~99% | R·∫•t nhanh | L·ªói floating point |
| **Improved** | O(log_x(y)) | 100% | Nhanh + ch√≠nh x√°c | Ph·ª©c t·∫°p h∆°n |

### üéØ Ph√¢n t√≠ch chi ti·∫øt

#### 1. Ph∆∞∆°ng ph√°p Naive:
```cpp
long long pow = 1;
while (pow < y) {
    pow *= x;  // Nh√¢n t·ª´ng b∆∞·ªõc
}
return (pow == y);
```
**∆Øu ƒëi·ªÉm**: Lu√¥n ch√≠nh x√°c, kh√¥ng c√≥ l·ªói floating point.
**Nh∆∞·ª£c ƒëi·ªÉm**: Ch·∫≠m khi y r·∫•t l·ªõn.

#### 2. Ph∆∞∆°ng ph√°p Logarithm:
```cpp
double result = log(y) / log(x);
return (result == floor(result));
```
**∆Øu ƒëi·ªÉm**: R·∫•t nhanh, O(1).
**Nh∆∞·ª£c ƒëi·ªÉm**: C√≥ th·ªÉ c√≥ l·ªói do ƒë·ªô ch√≠nh x√°c floating point.

#### 3. Ph∆∞∆°ng ph√°p Improved:
```cpp
double result = log(y) / log(x);
int k = round(result);
return (pow(x, k) == y);
```
**∆Øu ƒëi·ªÉm**: K·∫øt h·ª£p t·ªëc ƒë·ªô v√† ƒë·ªô ch√≠nh x√°c.

### ‚ö†Ô∏è V·∫•n ƒë·ªÅ Floating Point

```python
# V√≠ d·ª• v·ªÅ l·ªói floating point
import math

x, y = 3, 27
result = math.log(y) / math.log(x)
print(f"log_3(27) = {result}")          # 2.9999999999999996
print(f"C√≥ ph·∫£i 3.0? {result == 3.0}")  # False!

# Gi·∫£i ph√°p: s·ª≠ d·ª•ng round()
k = round(result)
print(f"L√†m tr√≤n: {k}")                 # 3
print(f"3^3 = {3**k}")                  # 27
```

---

## 6. B√ÄI T·∫¨P TH·ª∞C H√ÄNH

### üìù B√†i t·∫≠p c∆° b·∫£n

**B√†i 1**: Vi·∫øt ch∆∞∆°ng tr√¨nh nh·∫≠p x v√† y, ki·ªÉm tra y c√≥ ph·∫£i l≈©y th·ª´a c·ªßa x kh√¥ng.

**B√†i 2**: T√¨m t·∫•t c·∫£ l≈©y th·ª´a c·ªßa 2 t·ª´ 2^0 ƒë·∫øn 2^20.

**B√†i 3**: Cho m·ªôt s·ªë n, t√¨m x nh·ªè nh·∫•t sao cho x^k = n v·ªõi k ‚â• 2.

### üî• B√†i t·∫≠p n√¢ng cao

**B√†i 4**: **Perfect Power**: Ki·ªÉm tra m·ªôt s·ªë c√≥ ph·∫£i l√† l≈©y th·ª´a b·∫≠c k c·ªßa m·ªôt s·ªë nguy√™n n√†o ƒë√≥ kh√¥ng.
```cpp
// V√≠ d·ª•: 8 = 2^3 (perfect cube), 16 = 2^4 (perfect 4th power)
bool isPerfectPower(int n, int k) {
    int root = round(pow(n, 1.0/k));
    return pow(root, k) == n;
}
```

**B√†i 5**: **Power Tower**: T√≠nh x^(x^(x^...)) v·ªõi chi·ªÅu cao h.
```cpp
// V√≠ d·ª•: 2^(2^2) = 2^4 = 16
long long powerTower(int x, int height) {
    if (height == 1) return x;
    return pow(x, powerTower(x, height - 1));
}
```

**B√†i 6**: **Largest Power**: T√¨m l≈©y th·ª´a l·ªõn nh·∫•t c·ªßa x kh√¥ng v∆∞·ª£t qu√° n.

### üí° B√†i t·∫≠p ·ª©ng d·ª•ng

**B√†i 7**: **Binary Representation**: Ki·ªÉm tra m·ªôt s·ªë c√≥ ph·∫£i l√† l≈©y th·ª´a c·ªßa 2 kh√¥ng (bit manipulation).
```cpp
bool isPowerOf2(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```

**B√†i 8**: **Scientific Notation**: Chuy·ªÉn ƒë·ªïi s·ªë th√†nh d·∫°ng a √ó 10^b.

**B√†i 9**: **Logarithmic Scale**: V·∫Ω bi·ªÉu ƒë·ªì logarithmic v·ªõi c√°c m·ª©c 10^k.

### üöÄ B√†i t·∫≠p th√°ch th·ª©c

**B√†i 10**: **Fast Exponentiation**: Implement thu·∫≠t to√°n t√≠nh x^n nhanh b·∫±ng binary exponentiation.

**B√†i 11**: **Modular Exponentiation**: T√≠nh (x^n) mod m hi·ªáu qu·∫£.

**B√†i 12**: **Power Sum**: T√¨m t·∫•t c·∫£ c√°ch bi·ªÉu di·ªÖn n d∆∞·ªõi d·∫°ng t·ªïng c√°c l≈©y th·ª´a.
```
V√≠ d·ª•: 100 = 10^2 = 1^4 + 3^4 + 5^4 + 6^4
```

---

## 7. T√ìM T·∫ÆT

### üéØ Nh·ªØng ƒëi·ªÅu c·∫ßn nh·ªõ

1. **Ba ph∆∞∆°ng ph√°p ch√≠nh**: Naive (ch√≠nh x√°c), Logarithm (nhanh), Improved (c√¢n b·∫±ng)
2. **Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát**: x=1 (ch·ªâ y=1), y=1 (lu√¥n ƒë√∫ng v·ªõi x^0=1)
3. **C√¥ng th·ª©c logarithm**: log_x(y) = log(y)/log(x)
4. **V·∫•n ƒë·ªÅ floating point**: C·∫ßn l√†m tr√≤n k·∫øt qu·∫£

### üöÄ K·ªπ nƒÉng ƒë√£ h·ªçc

- Hi·ªÉu v·ªÅ l≈©y th·ª´a v√† logarithm
- X·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
- So s√°nh hi·ªáu su·∫•t c√°c thu·∫≠t to√°n
- Gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ floating point precision

### üìà ·ª®ng d·ª•ng th·ª±c t·∫ø

- **Computer Graphics**: Scaling, transformations
- **Cryptography**: RSA, Diffie-Hellman key exchange
- **Scientific Computing**: Exponential models, growth rates
- **Data Analysis**: Logarithmic scales, power laws

### üìö B∆∞·ªõc ti·∫øp theo

- Th·ª±c h√†nh c√°c b√†i t·∫≠p trong chuy√™n ƒë·ªÅ
- T√¨m hi·ªÉu v·ªÅ fast exponentiation v√† modular arithmetic
- √Åp d·ª•ng v√†o b√†i to√°n cryptography
- Nghi√™n c·ª©u v·ªÅ numerical methods v√† precision

---

**üéì Ch√∫c c√°c em n·∫Øm v·ªØng ki·∫øn th·ª©c v·ªÅ l≈©y th·ª´a v√† logarithm!**