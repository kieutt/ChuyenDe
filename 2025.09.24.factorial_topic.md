# CHUYÊN ĐỀ: TÍNH GIAI THỪA CỦA MỘT SỐ

## 1. MỤC TIÊU HỌC TẬP

Sau khi hoàn thành chuyên đề này, học sinh sẽ có thể:
- Hiểu khái niệm giai thừa và ứng dụng trong toán học
- So sánh hai phương pháp: iterative và recursive
- Phân tích độ phức tạp thời gian và không gian
- Xử lý các vấn đề về overflow và big numbers
- Áp dụng vào các bài toán tổ hợp và xác suất

## 2. CƠ SỞ LÝ THUYẾT

### 2.1. Định nghĩa giai thừa
**Giai thừa** của một số nguyên không âm n, ký hiệu là n!, được định nghĩa như sau:

```
n! = n × (n-1) × (n-2) × ... × 2 × 1
```

**Các trường hợp đặc biệt:**
- 0! = 1 (theo quy ước toán học)
- 1! = 1
- n! = n × (n-1)! với n > 1

### 2.2. Công thức toán học
**Định nghĩa đệ quy:**
```
factorial(n) = {
    1              nếu n = 0 hoặc n = 1
    n × factorial(n-1)   nếu n > 1
}
```

**Tính chất quan trọng:**
- Hàm số tăng rất nhanh: 10! = 3,628,800
- Chỉ định nghĩa với số nguyên không âm
- Có ứng dụng rộng rãi trong tổ hợp, xác suất

### 2.3. Ví dụ minh họa
```
5! = 5 × 4 × 3 × 2 × 1 = 120
4! = 4 × 3 × 2 × 1 = 24
3! = 3 × 2 × 1 = 6
2! = 2 × 1 = 2
1! = 1
0! = 1
```

## 3. CÁC VÍ DỤ MINH HỌA

### Ví dụ 1:
**Input:** n = 5
**Tính toán:** 5! = 5 × 4 × 3 × 2 × 1 = 120
**Output:** 120

### Ví dụ 2:
**Input:** n = 4  
**Tính toán:** 4! = 4 × 3 × 2 × 1 = 24
**Output:** 24

### Ví dụ 3:
**Input:** n = 0
**Tính toán:** 0! = 1 (theo định nghĩa)
**Output:** 1

## 4. HIỆN THỰC THUẬT TOÁN

### 4.1. Phương pháp 1: Iterative (Lặp)

**Thuật toán:**
```
INPUT: n (số nguyên không âm)
BEGIN
    result = 1
    FOR i = 2 TO n DO
        result = result × i
    END FOR
    RETURN result
END
```

**Code C++:**
```cpp
#include <iostream>
using namespace std;

// Tính giai thừa bằng phương pháp lặp
long long factorialIterative(int n) {
    // Xử lý trường hợp đặc biệt
    if (n < 0) {
        cout << "Lỗi: Giai thừa không định nghĩa cho số âm!\n";
        return -1;
    }
    
    long long result = 1;
    
    // Tính giai thừa từ 2 đến n
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    
    return result;
}

// Tính giai thừa với kiểm tra overflow
bool factorialSafe(int n, long long &result) {
    if (n < 0) return false;
    
    result = 1;
    for (int i = 2; i <= n; i++) {
        // Kiểm tra overflow trước khi nhân
        if (result > LLONG_MAX / i) {
            return false; // Overflow sẽ xảy ra
        }
        result *= i;
    }
    return true;
}

// Chương trình chính
int main() {
    cout << "=== TÍNH GIAI THỪA - PHƯƠNG PHÁP LẶP ===\n\n";
    
    // Test với các ví dụ
    int test_cases[] = {0, 1, 4, 5, 10, 15};
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    for (int i = 0; i < num_tests; i++) {
        int n = test_cases[i];
        long long result;
        
        if (factorialSafe(n, result)) {
            cout << n << "! = " << result << endl;
        } else {
            cout << n << "! = OVERFLOW (quá lớn để lưu trữ)\n";
        }
    }
    
    // Nhập từ người dùng
    cout << "\nNhập một số để tính giai thừa: ";
    int n;
    cin >> n;
    
    long long result;
    if (factorialSafe(n, result)) {
        cout << n << "! = " << result << endl;
        
        // Hiển thị quá trình tính toán
        cout << "\nQuá trình tính toán:\n";
        cout << n << "! = ";
        for (int i = n; i >= 1; i--) {
            cout << i;
            if (i > 1) cout << " × ";
        }
        cout << " = " << result << endl;
    } else {
        cout << "Không thể tính " << n << "! (số âm hoặc overflow)\n";
    }
    
    return 0;
}
```

### 4.2. Phương pháp 2: Recursive (Đệ quy)

**Code Python:**
```python
import sys

# Tăng giới hạn đệ quy để tránh lỗi với số lớn
sys.setrecursionlimit(2000)

def factorial_recursive(n):
    """
    Tính giai thừa bằng phương pháp đệ quy
    
    Args:
        n: Số nguyên không âm
    
    Returns:
        Giai thừa của n, hoặc None nếu input không hợp lệ
    """
    # Base case: Trường hợp cơ sở
    if n < 0:
        print("Lỗi: Giai thừa không định nghĩa cho số âm!")
        return None
    
    if n == 0 or n == 1:
        return 1
    
    # Recursive case: Trường hợp đệ quy
    return n * factorial_recursive(n - 1)

def factorial_iterative(n):
    """Tính giai thừa bằng phương pháp lặp để so sánh"""
    if n < 0:
        return None
    
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def factorial_with_steps(n):
    """Hiển thị các bước tính toán giai thừa"""
    if n < 0:
        return None
    
    print(f"\nTính {n}! bằng đệ quy:")
    
    def helper(num, depth=0):
        indent = "  " * depth
        
        if num == 0 or num == 1:
            print(f"{indent}{num}! = 1")
            return 1
        
        print(f"{indent}{num}! = {num} × {num-1}!")
        sub_result = helper(num - 1, depth + 1)
        result = num * sub_result
        print(f"{indent}{num}! = {num} × {sub_result} = {result}")
        return result
    
    return helper(n)

def compare_methods(n):
    """So sánh hiệu suất giữa hai phương pháp"""
    import time
    
    print(f"\n=== SO SÁNH HIỆU SUẤT CHO {n}! ===")
    
    # Đo thời gian phương pháp lặp
    start_time = time.time()
    result_iter = factorial_iterative(n)
    iter_time = time.time() - start_time
    
    # Đo thời gian phương pháp đệ quy
    start_time = time.time()
    result_rec = factorial_recursive(n)
    rec_time = time.time() - start_time
    
    print(f"Phương pháp lặp:  {result_iter} (Thời gian: {iter_time:.8f}s)")
    print(f"Phương pháp đệ quy: {result_rec} (Thời gian: {rec_time:.8f}s)")
    print(f"Đệ quy chậm hơn: {rec_time/iter_time:.2f} lần")

# Chương trình chính
def main():
    print("=== TÍNH GIAI THỪA - PHƯƠNG PHÁP ĐỆ QUY ===\n")
    
    # Test với các ví dụ
    test_cases = [0, 1, 4, 5, 10]
    
    print("Kết quả tính giai thừa:")
    for n in test_cases:
        result = factorial_recursive(n)
        if result is not None:
            print(f"{n}! = {result}")
    
    # Demo các bước tính toán
    factorial_with_steps(5)
    
    # So sánh hiệu suất
    compare_methods(15)
    
    # Nhập từ người dùng
    print("\n" + "="*50)
    try:
        n = int(input("\nNhập một số để tính giai thừa: "))
        
        if n > 20:
            print("Cảnh báo: Số quá lớn có thể gây chậm với đệ quy!")
            choice = input("Bạn có muốn tiếp tục? (y/n): ")
            if choice.lower() != 'y':
                return
        
        result_rec = factorial_recursive(n)
        result_iter = factorial_iterative(n)
        
        if result_rec is not None:
            print(f"\nKết quả đệ quy: {n}! = {result_rec}")
            print(f"Kết quả lặp:    {n}! = {result_iter}")
            print(f"Kiểm tra: {result_rec == result_iter}")
            
            if n <= 8:  # Chỉ hiển thị steps với số nhỏ
                factorial_with_steps(n)
        
    except ValueError:
        print("Lỗi: Vui lòng nhập số nguyên hợp lệ!")

if __name__ == "__main__":
    main()
```

## 5. PHÂN TÍCH ĐỘ PHỨC TẠP

### 5.1. Phương pháp Iterative
- **Độ phức tạp thời gian:** O(n)
- **Độ phức tạp không gian:** O(1)
- **Ưu điểm:** Hiệu quả về bộ nhớ, nhanh hơn
- **Nhược điểm:** Code có thể khó hiểu hơn với một số người

### 5.2. Phương pháp Recursive  
- **Độ phức tạp thời gian:** O(n)
- **Độ phức tạp không gian:** O(n) - do call stack
- **Ưu điểm:** Code dễ hiểu, tự nhiên theo định nghĩa
- **Nhược điểm:** Tốn bộ nhớ, có thể gây stack overflow

### 5.3. So sánh chi tiết

| Tiêu chí | Iterative | Recursive |
|----------|-----------|-----------|
| **Thời gian** | O(n) | O(n) |
| **Không gian** | O(1) | O(n) |
| **Tốc độ** | Nhanh hơn | Chậm hơn |
| **Bộ nhớ** | Ít | Nhiều |
| **Dễ hiểu** | Trung bình | Cao |
| **Stack overflow** | Không | Có thể |

## 6. XỬ LÝ CÁC VẤN ĐỀ NÂNG CAO

### 6.1. Vấn đề Overflow
```cpp
#include <climits>

// Kiểm tra overflow trước khi tính
bool willOverflow(long long current, int next) {
    return current > LLONG_MAX / next;
}

string factorialBigInt(int n) {
    if (n < 0) return "ERROR";
    if (n <= 1) return "1";
    
    // Sử dụng string để lưu số lớn
    string result = "1";
    
    for (int i = 2; i <= n; i++) {
        result = multiplyStrings(result, to_string(i));
    }
    
    return result;
}
```

### 6.2. Đếm số chữ số 0 cuối
```cpp
// Đếm số chữ số 0 ở cuối của n!
int countTrailingZeros(int n) {
    int count = 0;
    
    // Đếm số lần 5 xuất hiện trong các thừa số
    for (int i = 5; n / i > 0; i *= 5) {
        count += n / i;
    }
    
    return count;
}
```

### 6.3. Giai thừa modulo
```cpp
// Tính n! mod p (với p là số nguyên tố)
long long factorialMod(int n, int p) {
    long long result = 1;
    
    for (int i = 2; i <= n; i++) {
        result = (result * i) % p;
    }
    
    return result;
}
```

## 7. BÀI TẬP THỰC HÀNH

### Bài tập 1: Cơ bản
Viết chương trình tính giai thừa của các số từ 1 đến n và hiển thị dưới dạng bảng.

### Bài tập 2: Tối ưu hóa
Implement thuật toán tính giai thừa cho số rất lớn (sử dụng array/string).

### Bài tập 3: Ứng dụng
Sử dụng giai thừa để tính:
- Số hoán vị của n phần tử
- Số tổ hợp C(n,k) = n!/(k!(n-k)!)

### Bài tập 4: Nâng cao
Tính giai thừa kép (double factorial): n!! = n × (n-2) × (n-4) × ...

## 8. MỞ RỘNG VÀ ỨNG DỤNG

### 8.1. Ứng dụng trong Tổ hợp
```cpp
// Tính số tổ hợp C(n,k)
long long combination(int n, int k) {
    if (k > n - k) k = n - k; // Tối ưu: C(n,k) = C(n,n-k)
    
    long long result = 1;
    for (int i = 0; i < k; i++) {
        result = result * (n - i) / (i + 1);
    }
    
    return result;
}
```

### 8.2. Ứng dụng trong Xác suất
```cpp
// Xác suất sắp xếp ngẫu nhiên
double probabilityArrangement(int n, int k) {
    // P = k! / n! (xác suất k phần tử đầu đúng vị trí)
    return (double)factorial(k) / factorial(n);
}
```

### 8.3. Gamma Function Extension
```cpp
#include <cmath>

// Mở rộng giai thừa cho số thực bằng Gamma function
// Γ(n) = (n-1)! cho số nguyên dương n
double gammaFactorial(double x) {
    return tgamma(x + 1); // tgamma(x) = Γ(x)
}
```

### 8.4. Stirling's Approximation
```cpp
// Xấp xỉ Stirling cho giai thừa lớn
// n! ≈ √(2πn) * (n/e)^n
double stirlingApproximation(int n) {
    if (n == 0) return 1;
    
    const double PI = 3.14159265359;
    const double E = 2.71828182846;
    
    return sqrt(2 * PI * n) * pow(n / E, n);
}
```

## 9. BẢNG GIÁ TRỊ THAM KHẢO

| n | n! | Số chữ số | Số chữ số 0 cuối |
|---|-----|-----------|------------------|
| 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 0 |
| 5 | 120 | 3 | 1 |
| 10 | 3,628,800 | 7 | 2 |
| 15 | 1,307,674,368,000 | 13 | 3 |
| 20 | 2.4×10¹⁸ | 19 | 4 |

## 10. KẾT LUẬN

Bài toán tính giai thừa là một ví dụ điển hình về:

- **Sự khác biệt giữa iterative và recursive**: Hiểu rõ trade-offs
- **Quản lý bộ nhớ**: Overflow handling và big integer arithmetic  
- **Tối ưu hóa thuật toán**: Từ định nghĩa đến implementation hiệu quả
- **Ứng dụng thực tế**: Tổ hợp, xác suất, và nhiều lĩnh vực khác

**Khuyến nghị:**
- Sử dụng **iterative** cho production code (hiệu quả hơn)
- Sử dụng **recursive** cho mục đích giáo dục (dễ hiểu hơn)
- Luôn xử lý **overflow** khi làm việc với số lớn
- Tìm hiểu các **thuật toán nâng cao** cho big integer arithmetic

Đây là kiến thức nền tảng quan trọng trong lập trình và toán học, với nhiều ứng dụng trong algorithms, data structures, và computational mathematics.