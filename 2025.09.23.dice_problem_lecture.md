# CHUY√äN ƒê·ªÄ: B√ÄI TO√ÅN X√öC X·∫ÆC - T√åM M·∫∂T ƒê·ªêI DI·ªÜN

**D√†nh cho h·ªçc sinh l·ªõp chuy√™n Tin h·ªçc**

---

## üìã M·ª§C L·ª§C
1. [Gi·ªõi thi·ªáu b√†i to√°n](#1-gi·ªõi-thi·ªáu-b√†i-to√°n)
2. [Ph√¢n t√≠ch to√°n h·ªçc](#2-ph√¢n-t√≠ch-to√°n-h·ªçc) 
3. [C√°c ph∆∞∆°ng ph√°p gi·∫£i](#3-c√°c-ph∆∞∆°ng-ph√°p-gi·∫£i)
4. [Code minh h·ªça](#4-code-minh-h·ªça)
5. [B√†i to√°n m·ªü r·ªông](#5-b√†i-to√°n-m·ªü-r·ªông)
6. [·ª®ng d·ª•ng th·ª±c t·∫ø](#6-·ª©ng-d·ª•ng-th·ª±c-t·∫ø)
7. [B√†i t·∫≠p th·ª±c h√†nh](#7-b√†i-t·∫≠p-th·ª±c-h√†nh)

---

## 1. GI·ªöI THI·ªÜU B√ÄI TO√ÅN

### üìù Ph√°t bi·ªÉu b√†i to√°n
Cho m·ªôt x√∫c x·∫Øc h√¨nh l·∫≠p ph∆∞∆°ng c√≥ 6 m·∫∑t, m·ªói m·∫∑t c√≥ m·ªôt s·ªë t·ª´ 1 ƒë·∫øn 6. Bi·∫øt s·ªë tr√™n m·ªôt m·∫∑t c·ªßa x√∫c x·∫Øc, h√£y t√¨m s·ªë tr√™n m·∫∑t ƒë·ªëi di·ªán v·ªõi n√≥.

### üé≤ C·∫•u tr√∫c x√∫c x·∫Øc chu·∫©n
Trong m·ªôt x√∫c x·∫Øc chu·∫©n:
```
M·∫∑t 1 ‚Üî M·∫∑t 6
M·∫∑t 2 ‚Üî M·∫∑t 5  
M·∫∑t 3 ‚Üî M·∫∑t 4
```

### üìö V√≠ d·ª• minh h·ªça
```
Input: n = 2  ‚Üí Output: 5
Input: n = 6  ‚Üí Output: 1
Input: n = 3  ‚Üí Output: 4
```

---

## 2. PH√ÇN T√çCH TO√ÅN H·ªåC

### üîç Quan s√°t then ch·ªët
**T√≠nh ch·∫•t quan tr·ªçng**: T·ªïng hai m·∫∑t ƒë·ªëi di·ªán c·ªßa x√∫c x·∫Øc lu√¥n b·∫±ng **7**

Ch·ª©ng minh:
- 1 + 6 = 7
- 2 + 5 = 7  
- 3 + 4 = 7

### üßÆ C√¥ng th·ª©c to√°n h·ªçc
```
N·∫øu m·∫∑t hi·ªán t·∫°i l√† n, th√¨ m·∫∑t ƒë·ªëi di·ªán l√†: 7 - n
```

### üìä B·∫£ng tra c·ª©u
| M·∫∑t cho tr∆∞·ªõc | M·∫∑t ƒë·ªëi di·ªán | T·ªïng |
|---------------|--------------|------|
| 1             | 6            | 7    |
| 2             | 5            | 7    |
| 3             | 4            | 7    |
| 4             | 3            | 7    |
| 5             | 2            | 7    |
| 6             | 1            | 7    |

---

## 3. C√ÅC PH∆Ø∆†NG PH√ÅP GI·∫¢I

### 3.1. Ph∆∞∆°ng ph√°p Naive - If-Else
**ƒê·ªô ph·ª©c t·∫°p**: O(1)  
**√ù t∆∞·ªüng**: S·ª≠ d·ª•ng chu·ªói if-else ƒë·ªÉ ki·ªÉm tra t·ª´ng tr∆∞·ªùng h·ª£p

**∆Øu ƒëi·ªÉm**:
- D·ªÖ hi·ªÉu, d·ªÖ implement
- C√≥ th·ªÉ m·ªü r·ªông cho x√∫c x·∫Øc kh√¥ng chu·∫©n

**Nh∆∞·ª£c ƒëi·ªÉm**:
- Code d√†i, kh√≥ b·∫£o tr√¨
- Kh√¥ng t·∫≠n d·ª•ng ƒë∆∞·ª£c t√≠nh ch·∫•t to√°n h·ªçc

### 3.2. Ph∆∞∆°ng ph√°p Optimal - C√¥ng th·ª©c to√°n h·ªçc  
**ƒê·ªô ph·ª©c t·∫°p**: O(1)  
**√ù t∆∞·ªüng**: S·ª≠ d·ª•ng c√¥ng th·ª©c `result = 7 - n`

**∆Øu ƒëi·ªÉm**:
- Code ng·∫Øn g·ªçn, elegant
- T·∫≠n d·ª•ng t√≠nh ch·∫•t to√°n h·ªçc
- D·ªÖ nh·ªõ, d·ªÖ √°p d·ª•ng

**Nh∆∞·ª£c ƒëi·ªÉm**:
- Ch·ªâ √°p d·ª•ng ƒë∆∞·ª£c cho x√∫c x·∫Øc chu·∫©n

---

## 4. CODE MINH H·ªåA

### 4.1. Ph∆∞∆°ng ph√°p Naive - C++

```cpp
#include <iostream>
#include <vector>
using namespace std;

/**
 * Ph∆∞∆°ng ph√°p Naive: S·ª≠ d·ª•ng if-else
 * ƒê·ªô ph·ª©c t·∫°p: O(1) - nh∆∞ng code d√†i
 */
int oppositeFaceNaive(int n) {
    // Ki·ªÉm tra t·ª´ng tr∆∞·ªùng h·ª£p c·ª• th·ªÉ
    if (n == 1) {
        return 6;
    } else if (n == 2) {
        return 5;
    } else if (n == 3) {
        return 4;
    } else if (n == 4) {
        return 3;
    } else if (n == 5) {
        return 2;
    } else { // n == 6
        return 1;
    }
}

/**
 * Ph∆∞∆°ng ph√°p Optimal: S·ª≠ d·ª•ng c√¥ng th·ª©c to√°n h·ªçc
 * ƒê·ªô ph·ª©c t·∫°p: O(1) - code ng·∫Øn g·ªçn
 */
int oppositeFaceOptimal(int n) {
    // T·∫≠n d·ª•ng t√≠nh ch·∫•t: t·ªïng hai m·∫∑t ƒë·ªëi di·ªán = 7
    return 7 - n;
}

/**
 * H√†m ki·ªÉm tra t√≠nh ƒë√∫ng ƒë·∫Øn c·ªßa hai ph∆∞∆°ng ph√°p
 */
void validateMethods() {
    cout << "=== KI·ªÇM TRA T√çNH ƒê√öNG ƒê·∫ÆN ===" << endl;
    cout << "M·∫∑t | Naive | Optimal | K·∫øt qu·∫£" << endl;
    cout << "----|-------|---------|--------" << endl;
    
    bool allCorrect = true;
    for (int i = 1; i <= 6; i++) {
        int naive = oppositeFaceNaive(i);
        int optimal = oppositeFaceOptimal(i);
        bool correct = (naive == optimal);
        
        cout << " " << i << "  |   " << naive << "   |    " 
             << optimal << "    |   " << (correct ? "‚úì" : "‚úó") << endl;
        
        if (!correct) allCorrect = false;
    }
    
    cout << "\nK·∫øt lu·∫≠n: " << (allCorrect ? "C·∫£ hai ph∆∞∆°ng ph√°p ƒë·ªÅu ch√≠nh x√°c!" 
                                          : "C√≥ l·ªói trong implementation!") << endl;
}

/**
 * H√†m demo v·ªõi gi·∫£i th√≠ch chi ti·∫øt
 */
void demonstrateWithExplanation(int n) {
    cout << "\n=== DEMO CHI TI·∫æT ===" << endl;
    cout << "Input: M·∫∑t x√∫c x·∫Øc = " << n << endl;
    
    // Ph∆∞∆°ng ph√°p Naive
    cout << "\n1. Ph∆∞∆°ng ph√°p Naive (if-else):" << endl;
    int naiveResult = oppositeFaceNaive(n);
    cout << "   ‚Üí Ki·ªÉm tra if-else ‚Üí K·∫øt qu·∫£: " << naiveResult << endl;
    
    // Ph∆∞∆°ng ph√°p Optimal  
    cout << "\n2. Ph∆∞∆°ng ph√°p Optimal (c√¥ng th·ª©c):" << endl;
    cout << "   ‚Üí √Åp d·ª•ng c√¥ng th·ª©c: 7 - " << n << " = ";
    int optimalResult = oppositeFaceOptimal(n);
    cout << optimalResult << endl;
    
    // Ki·ªÉm tra
    cout << "\n3. Ki·ªÉm tra:" << endl;
    cout << "   ‚Üí T·ªïng: " << n << " + " << optimalResult << " = " 
         << (n + optimalResult) << endl;
    cout << "   ‚Üí " << (n + optimalResult == 7 ? "‚úì ƒê√∫ng quy t·∫Øc!" 
                                               : "‚úó Sai quy t·∫Øc!") << endl;
}

int main() {
    cout << "üé≤ CHUY√äN ƒê·ªÄ: B√ÄI TO√ÅN X√öC X·∫ÆC üé≤" << endl;
    
    // Ki·ªÉm tra t√≠nh ƒë√∫ng ƒë·∫Øn
    validateMethods();
    
    // Demo chi ti·∫øt
    vector<int> testCases = {1, 2, 3, 4, 5, 6};
    for (int testCase : testCases) {
        demonstrateWithExplanation(testCase);
    }
    
    return 0;
}
```

### 4.2. Ph∆∞∆°ng ph√°p Optimal - Python

```python
def opposite_face_naive(n):
    """
    Ph∆∞∆°ng ph√°p Naive: S·ª≠ d·ª•ng if-else
    
    Args:
        n (int): S·ªë tr√™n m·∫∑t x√∫c x·∫Øc (1-6)
    
    Returns:
        int: S·ªë tr√™n m·∫∑t ƒë·ªëi di·ªán
    """
    # Ki·ªÉm tra t·ª´ng tr∆∞·ªùng h·ª£p c·ª• th·ªÉ
    if n == 1:
        return 6
    elif n == 2:
        return 5
    elif n == 3:
        return 4
    elif n == 4:
        return 3
    elif n == 5:
        return 2
    else:  # n == 6
        return 1

def opposite_face_optimal(n):
    """
    Ph∆∞∆°ng ph√°p Optimal: S·ª≠ d·ª•ng c√¥ng th·ª©c to√°n h·ªçc
    
    Args:
        n (int): S·ªë tr√™n m·∫∑t x√∫c x·∫Øc (1-6)
    
    Returns:
        int: S·ªë tr√™n m·∫∑t ƒë·ªëi di·ªán
    """
    # T·∫≠n d·ª•ng t√≠nh ch·∫•t: t·ªïng hai m·∫∑t ƒë·ªëi di·ªán = 7
    return 7 - n

def validate_methods():
    """Ki·ªÉm tra t√≠nh ƒë√∫ng ƒë·∫Øn c·ªßa hai ph∆∞∆°ng ph√°p"""
    print("=== KI·ªÇM TRA T√çNH ƒê√öNG ƒê·∫ÆN ===")
    print("M·∫∑t | Naive | Optimal | K·∫øt qu·∫£")
    print("----|-------|---------|--------")
    
    all_correct = True
    for i in range(1, 7):
        naive = opposite_face_naive(i)
        optimal = opposite_face_optimal(i)
        correct = (naive == optimal)
        
        print(f" {i}  |   {naive}   |    {optimal}    |   {'‚úì' if correct else '‚úó'}")
        
        if not correct:
            all_correct = False
    
    print(f"\nK·∫øt lu·∫≠n: {'C·∫£ hai ph∆∞∆°ng ph√°p ƒë·ªÅu ch√≠nh x√°c!' if all_correct else 'C√≥ l·ªói trong implementation!'}")

def demonstrate_with_explanation(n):
    """Demo v·ªõi gi·∫£i th√≠ch chi ti·∫øt"""
    print(f"\n=== DEMO CHI TI·∫æT ===")
    print(f"Input: M·∫∑t x√∫c x·∫Øc = {n}")
    
    # Ph∆∞∆°ng ph√°p Naive
    print(f"\n1. Ph∆∞∆°ng ph√°p Naive (if-else):")
    naive_result = opposite_face_naive(n)
    print(f"   ‚Üí Ki·ªÉm tra if-else ‚Üí K·∫øt qu·∫£: {naive_result}")
    
    # Ph∆∞∆°ng ph√°p Optimal
    print(f"\n2. Ph∆∞∆°ng ph√°p Optimal (c√¥ng th·ª©c):")
    print(f"   ‚Üí √Åp d·ª•ng c√¥ng th·ª©c: 7 - {n} = ", end="")
    optimal_result = opposite_face_optimal(n)
    print(optimal_result)
    
    # Ki·ªÉm tra
    print(f"\n3. Ki·ªÉm tra:")
    total = n + optimal_result
    print(f"   ‚Üí T·ªïng: {n} + {optimal_result} = {total}")
    print(f"   ‚Üí {'‚úì ƒê√∫ng quy t·∫Øc!' if total == 7 else '‚úó Sai quy t·∫Øc!'}")

class DiceProblemSolver:
    """Class ƒë·ªÉ gi·∫£i b√†i to√°n x√∫c x·∫Øc v·ªõi nhi·ªÅu t√≠nh nƒÉng"""
    
    def __init__(self):
        self.dice_pairs = {1: 6, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
    
    def get_opposite_face(self, n, method="optimal"):
        """
        T√¨m m·∫∑t ƒë·ªëi di·ªán c·ªßa x√∫c x·∫Øc
        
        Args:
            n (int): S·ªë tr√™n m·∫∑t x√∫c x·∫Øc (1-6)
            method (str): Ph∆∞∆°ng ph√°p gi·∫£i ("naive" ho·∫∑c "optimal")
        
        Returns:
            int: S·ªë tr√™n m·∫∑t ƒë·ªëi di·ªán
        """
        if not (1 <= n <= 6):
            raise ValueError("S·ªë tr√™n m·∫∑t x√∫c x·∫Øc ph·∫£i t·ª´ 1 ƒë·∫øn 6")
        
        if method == "naive":
            return opposite_face_naive(n)
        elif method == "optimal":
            return opposite_face_optimal(n)
        else:
            raise ValueError("Ph∆∞∆°ng ph√°p ph·∫£i l√† 'naive' ho·∫∑c 'optimal'")
    
    def get_all_pairs(self):
        """Tr·∫£ v·ªÅ t·∫•t c·∫£ c√°c c·∫∑p m·∫∑t ƒë·ªëi di·ªán"""
        return self.dice_pairs
    
    def visualize_dice(self, n):
        """Hi·ªÉn th·ªã tr·ª±c quan x√∫c x·∫Øc"""
        opposite = self.get_opposite_face(n)
        
        print(f"\nüé≤ TR·ª∞C QUAN X√öC X·∫ÆC:")
        print(f"   M·∫∑t tr√™n: {n}")
        print(f"   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
        print(f"   ‚îÇ  {n}  ‚îÇ")
        print(f"   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
        print(f"   M·∫∑t d∆∞·ªõi: {opposite}")
        print(f"   (kh√¥ng nh√¨n th·∫•y)")

# Ch∆∞∆°ng tr√¨nh ch√≠nh
if __name__ == "__main__":
    print("üé≤ CHUY√äN ƒê·ªÄ: B√ÄI TO√ÅN X√öC X·∫ÆC üé≤")
    
    # Ki·ªÉm tra t√≠nh ƒë√∫ng ƒë·∫Øn
    validate_methods()
    
    # Demo chi ti·∫øt cho t·∫•t c·∫£ test cases
    test_cases = [1, 2, 3, 4, 5, 6]
    for test_case in test_cases:
        demonstrate_with_explanation(test_case)
    
    # Demo s·ª≠ d·ª•ng class
    print("\n" + "="*50)
    print("DEMO S·ª¨ D·ª§NG CLASS")
    print("="*50)
    
    solver = DiceProblemSolver()
    
    # Hi·ªÉn th·ªã t·∫•t c·∫£ c·∫∑p
    print("\nT·∫•t c·∫£ c√°c c·∫∑p m·∫∑t ƒë·ªëi di·ªán:")
    for face, opposite in solver.get_all_pairs().items():
        print(f"  M·∫∑t {face} ‚Üî M·∫∑t {opposite}")
    
    # Tr·ª±c quan h√≥a
    for i in [2, 5]:
        solver.visualize_dice(i)
```

---

## 5. B√ÄI TO√ÅN M·ªû R·ªòNG

### 5.1. X√∫c x·∫Øc kh√¥ng chu·∫©n
**B√†i to√°n**: Cho x√∫c x·∫Øc c√≥ 6 m·∫∑t v·ªõi c√°c s·ªë b·∫•t k·ª≥, bi·∫øt c√°c c·∫∑p m·∫∑t ƒë·ªëi di·ªán. T√¨m m·∫∑t ƒë·ªëi di·ªán c·ªßa m·ªôt m·∫∑t cho tr∆∞·ªõc.

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

class CustomDice {
private:
    unordered_map<int, int> oppositeMap;
    
public:
    /**
     * Constructor: Kh·ªüi t·∫°o x√∫c x·∫Øc v·ªõi c√°c c·∫∑p m·∫∑t ƒë·ªëi di·ªán
     * @param pairs: Vector ch·ª©a c√°c c·∫∑p (m·∫∑t1, m·∫∑t2)
     */
    CustomDice(vector<pair<int, int>>& pairs) {
        for (auto& p : pairs) {
            oppositeMap[p.first] = p.second;
            oppositeMap[p.second] = p.first;
        }
    }
    
    /**
     * T√¨m m·∫∑t ƒë·ªëi di·ªán
     * @param face: M·∫∑t hi·ªán t·∫°i
     * @return: M·∫∑t ƒë·ªëi di·ªán, -1 n·∫øu kh√¥ng t√¨m th·∫•y
     */
    int getOppositeFace(int face) {
        if (oppositeMap.find(face) != oppositeMap.end()) {
            return oppositeMap[face];
        }
        return -1; // Kh√¥ng t√¨m th·∫•y
    }
    
    /**
     * Hi·ªÉn th·ªã t·∫•t c·∫£ c√°c c·∫∑p m·∫∑t ƒë·ªëi di·ªán
     */
    void displayPairs() {
        cout << "C√°c c·∫∑p m·∫∑t ƒë·ªëi di·ªán:" << endl;
        set<pair<int, int>> displayed;
        
        for (auto& p : oppositeMap) {
            pair<int, int> current = {min(p.first, p.second), 
                                    max(p.first, p.second)};
            if (displayed.find(current) == displayed.end()) {
                cout << "  " << current.first << " ‚Üî " 
                     << current.second << endl;
                displayed.insert(current);
            }
        }
    }
};

int main() {
    // V√≠ d·ª•: X√∫c x·∫Øc v·ªõi c√°c s·ªë {2, 4, 6, 8, 10, 12}
    vector<pair<int, int>> customPairs = {
        {2, 12},   // 2 ƒë·ªëi di·ªán 12
        {4, 10},   // 4 ƒë·ªëi di·ªán 10  
        {6, 8}     // 6 ƒë·ªëi di·ªán 8
    };
    
    CustomDice customDice(customPairs);
    
    cout << "üé≤ X√öC X·∫ÆC KH√îNG CHU·∫®N üé≤" << endl;
    customDice.displayPairs();
    
    // Test
    vector<int> testFaces = {2, 4, 6, 8, 10, 12};
    cout << "\nKi·ªÉm tra:" << endl;
    for (int face : testFaces) {
        int opposite = customDice.getOppositeFace(face);
        cout << "M·∫∑t " << face << " ‚Üí M·∫∑t ƒë·ªëi di·ªán: " << opposite << endl;
    }
    
    return 0;
}
```

### 5.2. X√∫c x·∫Øc ƒëa chi·ªÅu
**B√†i to√°n**: M·ªü r·ªông cho x√∫c x·∫Øc n-chi·ªÅu (n m·∫∑t)

```python
class NDimensionalDice:
    """X√∫c x·∫Øc n-chi·ªÅu v·ªõi n m·∫∑t"""
    
    def __init__(self, n):
        """
        Kh·ªüi t·∫°o x√∫c x·∫Øc n-chi·ªÅu
        Args:
            n (int): S·ªë m·∫∑t c·ªßa x√∫c x·∫Øc (ph·∫£i l√† s·ªë ch·∫µn)
        """
        if n % 2 != 0:
            raise ValueError("S·ªë m·∫∑t ph·∫£i l√† s·ªë ch·∫µn ƒë·ªÉ c√≥ th·ªÉ gh√©p c·∫∑p")
        
        self.n = n
        self.sum_constant = n + 1  # T·ªïng c·ªßa hai m·∫∑t ƒë·ªëi di·ªán
        
    def get_opposite_face(self, face):
        """
        T√¨m m·∫∑t ƒë·ªëi di·ªán
        Args:
            face (int): M·∫∑t hi·ªán t·∫°i (1 ƒë·∫øn n)
        Returns:
            int: M·∫∑t ƒë·ªëi di·ªán
        """
        if not (1 <= face <= self.n):
            raise ValueError(f"M·∫∑t ph·∫£i t·ª´ 1 ƒë·∫øn {self.n}")
        
        return self.sum_constant - face
    
    def get_all_pairs(self):
        """Tr·∫£ v·ªÅ t·∫•t c·∫£ c√°c c·∫∑p m·∫∑t ƒë·ªëi di·ªán"""
        pairs = []
        for i in range(1, self.n // 2 + 1):
            opposite = self.get_opposite_face(i)
            pairs.append((i, opposite))
        return pairs
    
    def visualize(self):
        """Hi·ªÉn th·ªã c·∫•u tr√∫c x√∫c x·∫Øc"""
        print(f"\nüé≤ X√öC X·∫ÆC {self.n}-CHI·ªÄU:")
        print(f"   T·ªïng hai m·∫∑t ƒë·ªëi di·ªán: {self.sum_constant}")
        print("   C√°c c·∫∑p m·∫∑t ƒë·ªëi di·ªán:")
        
        for face1, face2 in self.get_all_pairs():
            print(f"     M·∫∑t {face1} ‚Üî M·∫∑t {face2}")

# Demo
if __name__ == "__main__":
    # Test v·ªõi c√°c x√∫c x·∫Øc kh√°c nhau
    dice_types = [6, 8, 10, 12, 20]  # C√°c lo·∫°i x√∫c x·∫Øc ph·ªï bi·∫øn
    
    print("üé≤ X√öC X·∫ÆC ƒêA CHI·ªÄU üé≤")
    
    for n in dice_types:
        dice = NDimensionalDice(n)
        dice.visualize()
        
        # Test m·ªôt v√†i m·∫∑t
        test_faces = [1, n//2, n]
        print(f"   Ki·ªÉm tra:")
        for face in test_faces:
            opposite = dice.get_opposite_face(face)
            print(f"     M·∫∑t {face} ‚Üí M·∫∑t {opposite} (t·ªïng: {face + opposite})")
        print()
```

---

## 6. ·ª®NG D·ª§NG TH·ª∞C T·∫æ

### 6.1. Game Development
```cpp
/**
 * ·ª®ng d·ª•ng trong ph√°t tri·ªÉn game
 * T√≠nh to√°n x√°c su·∫•t v√† logic game
 */
class GameDice {
private:
    int currentTop;
    int currentBottom;
    
public:
    GameDice() : currentTop(1), currentBottom(6) {}
    
    void rollToFace(int newTop) {
        currentTop = newTop;
        currentBottom = 7 - newTop;
    }
    
    int getCurrentTop() { return currentTop; }
    int getCurrentBottom() { return currentBottom; }
    
    // T√≠nh x√°c su·∫•t xu·∫•t hi·ªán m·∫∑t ƒë·ªëi di·ªán
    double probabilityOfOpposite() {
        return 1.0 / 6.0; // 1/6 cho x√∫c x·∫Øc chu·∫©n
    }
};
```

### 6.2. Cryptography v√† Random Number Generation
```python
class DiceCrypto:
    """S·ª≠ d·ª•ng t√≠nh ch·∫•t x√∫c x·∫Øc trong m√£ h√≥a"""
    
    @staticmethod
    def simple_encrypt(message, key_face):
        """
        M√£ h√≥a ƒë∆°n gi·∫£n s·ª≠ d·ª•ng t√≠nh ch·∫•t x√∫c x·∫Øc
        Args:
            message (str): Th√¥ng ƒëi·ªáp c·∫ßn m√£ h√≥a
            key_face (int): M·∫∑t x√∫c x·∫Øc l√†m kh√≥a (1-6)
        Returns:
            str: Th√¥ng ƒëi·ªáp ƒë√£ m√£ h√≥a
        """
        opposite_face = 7 - key_face
        shift = opposite_face
        
        encrypted = ""
        for char in message:
            if char.isalpha():
                # Shift k√Ω t·ª± theo alphabet
                base = ord('A') if char.isupper() else ord('a')
                shifted = (ord(char) - base + shift) % 26
                encrypted += chr(base + shifted)
            else:
                encrypted += char
        
        return encrypted
    
    @staticmethod
    def simple_decrypt(encrypted_message, key_face):
        """Gi·∫£i m√£ th√¥ng ƒëi·ªáp"""
        opposite_face = 7 - key_face
        shift = -opposite_face  # Shift ng∆∞·ª£c l·∫°i
        
        decrypted = ""
        for char in encrypted_message:
            if char.isalpha():
                base = ord('A') if char.isupper() else ord('a')
                shifted = (ord(char) - base + shift) % 26
                decrypted += chr(base + shifted)
            else:
                decrypted += char
        
        return decrypted

# Demo m√£ h√≥a
crypto = DiceCrypto()
message = "HELLO WORLD"
key = 3

encrypted = crypto.simple_encrypt(message, key)
decrypted = crypto.simple_decrypt(encrypted, key)

print(f"Th√¥ng ƒëi·ªáp g·ªëc: {message}")
print(f"Kh√≥a (m·∫∑t x√∫c x·∫Øc): {key}")
print(f"M·∫∑t ƒë·ªëi di·ªán: {7 - key}")
print(f"Th√¥ng ƒëi·ªáp m√£ h√≥a: {encrypted}")
print(f"Th√¥ng ƒëi·ªáp gi·∫£i m√£: {decrypted}")
```

---

## 7. B√ÄI T·∫¨P TH·ª∞C H√ÄNH

### üìù B√†i t·∫≠p c∆° b·∫£n

**B√†i 1**: Vi·∫øt ch∆∞∆°ng tr√¨nh nh·∫≠p m·ªôt s·ªë t·ª´ 1 ƒë·∫øn 6, xu·∫•t ra m·∫∑t ƒë·ªëi di·ªán v√† gi·∫£i th√≠ch.

**B√†i 2**: So s√°nh hi·ªáu su·∫•t c·ªßa ph∆∞∆°ng ph√°p Naive v√† Optimal b·∫±ng c√°ch ch·∫°y 1 tri·ªáu l·∫ßn.

**B√†i 3**: Vi·∫øt h√†m ki·ªÉm tra xem m·ªôt c·∫∑p s·ªë c√≥ ph·∫£i l√† m·∫∑t ƒë·ªëi di·ªán c·ªßa x√∫c x·∫Øc chu·∫©n kh√¥ng.

### üî• B√†i t·∫≠p n√¢ng cao

**B√†i 4**: Cho tr∆∞·ªõc t·∫•t c·∫£ 6 m·∫∑t c·ªßa x√∫c x·∫Øc d∆∞·ªõi d·∫°ng m·∫£ng, s·∫Øp x·∫øp ch√∫ng th√†nh 3 c·∫∑p ƒë·ªëi di·ªán.

**B√†i 5**: Vi·∫øt class `DiceSimulator` m√¥ ph·ªèng vi·ªác tung x√∫c x·∫Øc nhi·ªÅu l·∫ßn v√† th·ªëng k√™ t·∫ßn su·∫•t xu·∫•t hi·ªán c·ªßa t·ª´ng c·∫∑p m·∫∑t ƒë·ªëi di·ªán.

**B√†i 6**: Thi·∫øt k·∫ø thu·∫≠t to√°n ƒë·ªÉ x√°c ƒë·ªãnh xem hai x√∫c x·∫Øc c√≥ gi·ªëng nhau kh√¥ng (c√πng c√°ch s·∫Øp x·∫øp c√°c s·ªë).

### üöÄ B√†i t·∫≠p th√°ch th·ª©c

**B√†i 7**: Vi·∫øt ch∆∞∆°ng tr√¨nh gi·∫£i b√†i to√°n "Dice Unfolding": Cho m·ªôt h√¨nh tri·ªÉn khai 2D c·ªßa x√∫c x·∫Øc, x√°c ƒë·ªãnh s·ªë tr√™n m·ªói m·∫∑t khi g·∫•p l·∫°i.

**B√†i 8**: T·ªëi ∆∞u h√≥a b√†i to√°n x√∫c x·∫Øc cho tr∆∞·ªùng h·ª£p c√≥ n x√∫c x·∫Øc, t√¨m t·ªïng c√°c m·∫∑t ƒë·ªëi di·ªán nhanh nh·∫•t.

**B√†i 9**: Vi·∫øt thu·∫≠t to√°n AI ƒë·ªÉ d·ª± ƒëo√°n m·∫∑t ti·∫øp theo c·ªßa x√∫c x·∫Øc d·ª±a tr√™n l·ªãch s·ª≠ c√°c l·∫ßn tung tr∆∞·ªõc (m√¥ ph·ªèng x√∫c x·∫Øc kh√¥ng c√¥ng b·∫±ng).

---

## 8. T√ìM T·∫ÆT V√Ä K·∫æT LU·∫¨N

### üéØ ƒêi·ªÉm quan tr·ªçng c·∫ßn nh·ªõ

1. **T√≠nh ch·∫•t c·ªët l√µi**: T·ªïng hai m·∫∑t ƒë·ªëi di·ªán c·ªßa x√∫c x·∫Øc chu·∫©n = 7
2. **C√¥ng th·ª©c t·ªëi ∆∞u**: `opposite = 7 - current`
3. **ƒê·ªô ph·ª©c t·∫°p**: O(1) cho c·∫£ th·ªùi gian v√† kh√¥ng gian
4. **T√≠nh ·ª©ng d·ª•ng**: R·ªông r√£i trong game, m√£ h√≥a, m√¥ ph·ªèng

### üîß K·ªπ nƒÉng ƒë√£ h·ªçc

- **T∆∞ duy to√°n h·ªçc**: Nh·∫≠n ra quy lu·∫≠t t·ª´ d·ªØ li·ªáu c·ª• th·ªÉ
- **T·ªëi ∆∞u h√≥a code**: T·ª´ gi·∫£i ph√°p naive ƒë·∫øn optimal
- **Thi·∫øt k·∫ø class**: OOP cho b√†i to√°n m·ªü r·ªông
- **·ª®ng d·ª•ng th·ª±c t·∫ø**: K·∫øt n·ªëi l√Ω thuy·∫øt v·ªõi th·ª±c ti·ªÖn

### üìà B∆∞·ªõc ti·∫øp theo

1. √Åp d·ª•ng t∆∞ duy t∆∞∆°ng t·ª± cho c√°c b√†i to√°n kh√°c
2. Nghi√™n c·ª©u th√™m v·ªÅ c√°c t√≠nh ch·∫•t h√¨nh h·ªçc c·ªßa ƒëa di·ªán
3. T√¨m hi·ªÉu ·ª©ng d·ª•ng trong machine learning v√† AI
4. Th·ª±c h√†nh v·ªõi c√°c b√†i t·∫≠p n√¢ng cao

---

**üéì K·∫øt th√∫c chuy√™n ƒë·ªÅ. Ch√∫c c√°c em h·ªçc t·ªët v√† √°p d·ª•ng hi·ªáu qu·∫£!**
