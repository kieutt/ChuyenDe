# CHUY√äN ƒê·ªÄ: KI·ªÇM TRA S·ªê NGUY√äN T·ªê

**D√†nh cho h·ªçc sinh l·ªõp 10 chuy√™n Tin h·ªçc**

---

## üìã M·ª§C L·ª§C
1. [Gi·ªõi thi·ªáu s·ªë nguy√™n t·ªë](#1-gi·ªõi-thi·ªáu-s·ªë-nguy√™n-t·ªë)
2. [Ph√¢n t√≠ch b√†i to√°n](#2-ph√¢n-t√≠ch-b√†i-to√°n)
3. [C√°c ph∆∞∆°ng ph√°p ki·ªÉm tra](#3-c√°c-ph∆∞∆°ng-ph√°p-ki·ªÉm-tra)
4. [Code minh h·ªça](#4-code-minh-h·ªça)
5. [So s√°nh c√°c ph∆∞∆°ng ph√°p](#5-so-s√°nh-c√°c-ph∆∞∆°ng-ph√°p)
6. [B√†i t·∫≠p th·ª±c h√†nh](#6-b√†i-t·∫≠p-th·ª±c-h√†nh)

---

## 1. GI·ªöI THI·ªÜU S·ªê NGUY√äN T·ªê

### üìù ƒê·ªãnh nghƒ©a
**S·ªë nguy√™n t·ªë** l√† s·ªë t·ª± nhi√™n l·ªõn h∆°n 1, ch·ªâ c√≥ ƒë√∫ng hai ∆∞·ªõc s·ªë l√† 1 v√† ch√≠nh n√≥.

### üìä V√≠ d·ª•
```
S·ªë nguy√™n t·ªë: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...

Kh√¥ng ph·∫£i s·ªë nguy√™n t·ªë:
- 1 (ch·ªâ c√≥ 1 ∆∞·ªõc s·ªë)
- 4 = 2 √ó 2 (c√≥ ∆∞·ªõc s·ªë 2)
- 6 = 2 √ó 3 (c√≥ ∆∞·ªõc s·ªë 2, 3)
- 8 = 2 √ó 4 (c√≥ ∆∞·ªõc s·ªë 2, 4)
- 9 = 3 √ó 3 (c√≥ ∆∞·ªõc s·ªë 3)
```

### üéØ B√†i to√°n
Cho m·ªôt s·ªë nguy√™n d∆∞∆°ng n, ki·ªÉm tra n c√≥ ph·∫£i l√† s·ªë nguy√™n t·ªë kh√¥ng.

**Test cases t·ª´ GeeksforGeeks**:
```
Input: n = 11 ‚Üí Output: true
Input: n = 15 ‚Üí Output: false  
Input: n = 1  ‚Üí Output: false
```

---

## 2. PH√ÇN T√çCH B√ÄI TO√ÅN

### üîç √ù t∆∞·ªüng c∆° b·∫£n
ƒê·ªÉ ki·ªÉm tra n c√≥ ph·∫£i s·ªë nguy√™n t·ªë:
1. N·∫øu n ‚â§ 1: **kh√¥ng ph·∫£i** s·ªë nguy√™n t·ªë
2. N·∫øu n = 2: **l√†** s·ªë nguy√™n t·ªë (s·ªë nguy√™n t·ªë ch·∫µn duy nh·∫•t)
3. N·∫øu n > 2: Ki·ªÉm tra c√≥ ∆∞·ªõc s·ªë n√†o t·ª´ 2 ƒë·∫øn n-1 kh√¥ng

### üéØ Quan s√°t quan tr·ªçng
N·∫øu n c√≥ ∆∞·ªõc s·ªë d > ‚àön, th√¨ n c≈©ng ph·∫£i c√≥ ∆∞·ªõc s·ªë n/d < ‚àön.

**V√≠ d·ª•**: n = 36
- ∆Ø·ªõc s·ªë 9 > ‚àö36 = 6
- ∆Ø·ªõc s·ªë t∆∞∆°ng ·ª©ng: 36/9 = 4 < 6

**K·∫øt lu·∫≠n**: Ch·ªâ c·∫ßn ki·ªÉm tra ƒë·∫øn ‚àön thay v√¨ n-1.

---

## 3. C√ÅC PH∆Ø∆†NG PH√ÅP KI·ªÇM TRA

### 3.1. Ph∆∞∆°ng ph√°p School Method (C∆° b·∫£n)
**ƒê·ªô ph·ª©c t·∫°p**: O(n)

**√ù t∆∞·ªüng**: Ki·ªÉm tra t·∫•t c·∫£ s·ªë t·ª´ 2 ƒë·∫øn n-1.

### 3.2. Ph∆∞∆°ng ph√°p Optimized School Method
**ƒê·ªô ph·ª©c t·∫°p**: O(‚àön)

**√ù t∆∞·ªüng**: Ch·ªâ ki·ªÉm tra t·ª´ 2 ƒë·∫øn ‚àön.

### 3.3. Ph∆∞∆°ng ph√°p 6k¬±1 Optimization
**ƒê·ªô ph·ª©c t·∫°p**: O(‚àön) nh∆∞ng nhanh g·∫•p 3 l·∫ßn

**√ù t∆∞·ªüng**: T·∫•t c·∫£ s·ªë nguy√™n t·ªë > 3 ƒë·ªÅu c√≥ d·∫°ng 6k¬±1.

---

## 4. CODE MINH H·ªåA

### 4.1. Code C++

```cpp
#include <iostream>
#include <cmath>
#include <chrono>
using namespace std;

/**
 * Ph∆∞∆°ng ph√°p 1: School Method (C∆° b·∫£n)
 * ƒê·ªô ph·ª©c t·∫°p: O(n)
 */
bool isPrimeBasic(int n) {
    // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if (n <= 1) {
        return false;
    }
    
    // Ki·ªÉm tra t·ª´ 2 ƒë·∫øn n-1
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            return false;  // T√¨m th·∫•y ∆∞·ªõc s·ªë
        }
    }
    
    return true;
}

/**
 * Ph∆∞∆°ng ph√°p 2: Optimized School Method
 * ƒê·ªô ph·ª©c t·∫°p: O(‚àön)
 */
bool isPrimeOptimized(int n) {
    // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if (n <= 1) {
        return false;
    }
    
    // Ki·ªÉm tra t·ª´ 2 ƒë·∫øn ‚àön
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) {
            return false;  // T√¨m th·∫•y ∆∞·ªõc s·ªë
        }
    }
    
    return true;
}

/**
 * Ph∆∞∆°ng ph√°p 3: 6k¬±1 Optimization
 * ƒê·ªô ph·ª©c t·∫°p: O(‚àön), nhanh g·∫•p 3 l·∫ßn
 */
bool isPrime6k(int n) {
    // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if (n == 2 || n == 3) {
        return true;
    }
    
    if (n <= 1 || n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    
    // Ki·ªÉm tra c√°c s·ªë c√≥ d·∫°ng 6k¬±1
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    
    return true;
}

/**
 * H√†m demo v·ªõi gi·∫£i th√≠ch chi ti·∫øt
 */
void demoPrimalityTest(int n) {
    cout << "\n=== DEMO: Ki·ªÉm tra " << n << " c√≥ ph·∫£i s·ªë nguy√™n t·ªë ===" << endl;
    
    // Ph∆∞∆°ng ph√°p c∆° b·∫£n v·ªõi chi ti·∫øt
    cout << "\nPh∆∞∆°ng ph√°p 1 - School Method:" << endl;
    cout << "Ki·ªÉm tra c√°c ∆∞·ªõc s·ªë t·ª´ 2 ƒë·∫øn " << (n-1) << ":" << endl;
    
    bool isBasicPrime = true;
    for (int i = 2; i < n && i <= 10; i++) {  // Ch·ªâ hi·ªÉn th·ªã 10 b∆∞·ªõc ƒë·∫ßu
        if (n % i == 0) {
            cout << "  " << n << " % " << i << " = 0 ‚Üí T√¨m th·∫•y ∆∞·ªõc s·ªë!" << endl;
            isBasicPrime = false;
            break;
        } else {
            cout << "  " << n << " % " << i << " = " << (n % i) << endl;
        }
    }
    
    if (isBasicPrime && n > 11) {
        cout << "  ... (ti·∫øp t·ª•c ki·ªÉm tra ƒë·∫øn " << (n-1) << ")" << endl;
    }
    
    // So s√°nh k·∫øt qu·∫£ c√°c ph∆∞∆°ng ph√°p
    cout << "\nSo s√°nh k·∫øt qu·∫£:" << endl;
    cout << "  School Method:      " << (isPrimeBasic(n) ? "true" : "false") << endl;
    cout << "  Optimized Method:   " << (isPrimeOptimized(n) ? "true" : "false") << endl;
    cout << "  6k¬±1 Method:        " << (isPrime6k(n) ? "true" : "false") << endl;
    
    // Gi·∫£i th√≠ch t·∫°i sao ch·ªâ c·∫ßn ki·ªÉm tra ƒë·∫øn ‚àön
    if (n > 4) {
        cout << "\nGi·∫£i th√≠ch t·ªëi ∆∞u h√≥a:" << endl;
        cout << "  ‚àö" << n << " ‚âà " << (int)sqrt(n) << endl;
        cout << "  ‚Üí Ch·ªâ c·∫ßn ki·ªÉm tra ƒë·∫øn " << (int)sqrt(n) 
             << " thay v√¨ " << (n-1) << endl;
    }
}

/**
 * H√†m so s√°nh hi·ªáu su·∫•t
 */
void comparePerformance(int n) {
    cout << "\n‚è±Ô∏è SO S√ÅNH HI·ªÜU SU·∫§T cho n = " << n << ":" << endl;
    
    const int iterations = 10000;
    
    // Test Basic Method
    auto start = chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; i++) {
        isPrimeBasic(n);
    }
    auto end = chrono::high_resolution_clock::now();
    auto duration1 = chrono::duration_cast<chrono::microseconds>(end - start);
    
    // Test Optimized Method
    start = chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; i++) {
        isPrimeOptimized(n);
    }
    end = chrono::high_resolution_clock::now();
    auto duration2 = chrono::duration_cast<chrono::microseconds>(end - start);
    
    // Test 6k¬±1 Method
    start = chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; i++) {
        isPrime6k(n);
    }
    end = chrono::high_resolution_clock::now();
    auto duration3 = chrono::duration_cast<chrono::microseconds>(end - start);
    
    cout << "  Basic Method:     " << duration1.count() << " Œºs" << endl;
    cout << "  Optimized Method: " << duration2.count() << " Œºs" << endl;
    cout << "  6k¬±1 Method:      " << duration3.count() << " Œºs" << endl;
    
    cout << "\nTƒÉng t·ªëc so v·ªõi Basic Method:" << endl;
    cout << "  Optimized: " << (double)duration1.count() / duration2.count() << "x" << endl;
    cout << "  6k¬±1:      " << (double)duration1.count() / duration3.count() << "x" << endl;
}

int main() {
    cout << "CHUY√äN ƒê·ªÄ: KI·ªÇM TRA S·ªê NGUY√äN T·ªê" << endl;
    cout << "==================================" << endl;
    
    // Test v·ªõi c√°c v√≠ d·ª• t·ª´ GeeksforGeeks
    demoPrimalityTest(11);  // true
    demoPrimalityTest(15);  // false
    demoPrimalityTest(1);   // false
    demoPrimalityTest(29);  // true
    
    // So s√°nh hi·ªáu su·∫•t
    comparePerformance(997);  // S·ªë nguy√™n t·ªë l·ªõn
    
    return 0;
}
```

### 4.2. Code Python

```python
import math
import time

def is_prime_basic(n):
    """
    Ph∆∞∆°ng ph√°p 1: School Method (C∆° b·∫£n)
    ƒê·ªô ph·ª©c t·∫°p: O(n)
    """
    # Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if n <= 1:
        return False
    
    # Ki·ªÉm tra t·ª´ 2 ƒë·∫øn n-1
    for i in range(2, n):
        if n % i == 0:
            return False  # T√¨m th·∫•y ∆∞·ªõc s·ªë
    
    return True

def is_prime_optimized(n):
    """
    Ph∆∞∆°ng ph√°p 2: Optimized School Method
    ƒê·ªô ph·ª©c t·∫°p: O(‚àön)
    """
    # Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if n <= 1:
        return False
    
    # Ki·ªÉm tra t·ª´ 2 ƒë·∫øn ‚àön
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False  # T√¨m th·∫•y ∆∞·ªõc s·ªë
    
    return True

def is_prime_6k(n):
    """
    Ph∆∞∆°ng ph√°p 3: 6k¬±1 Optimization
    ƒê·ªô ph·ª©c t·∫°p: O(‚àön), nhanh g·∫•p 3 l·∫ßn
    """
    # Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    if n == 2 or n == 3:
        return True
    
    if n <= 1 or n % 2 == 0 or n % 3 == 0:
        return False
    
    # Ki·ªÉm tra c√°c s·ªë c√≥ d·∫°ng 6k¬±1
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    
    return True

def demo_primality_test(n):
    """Demo v·ªõi gi·∫£i th√≠ch chi ti·∫øt"""
    print(f"\n=== DEMO: Ki·ªÉm tra {n} c√≥ ph·∫£i s·ªë nguy√™n t·ªë ===")
    
    # Ph∆∞∆°ng ph√°p c∆° b·∫£n v·ªõi chi ti·∫øt
    print(f"\nPh∆∞∆°ng ph√°p 1 - School Method:")
    print(f"Ki·ªÉm tra c√°c ∆∞·ªõc s·ªë t·ª´ 2 ƒë·∫øn {n-1}:")
    
    is_basic_prime = True
    for i in range(2, min(n, 11)):  # Ch·ªâ hi·ªÉn th·ªã 10 b∆∞·ªõc ƒë·∫ßu
        if n % i == 0:
            print(f"  {n} % {i} = 0 ‚Üí T√¨m th·∫•y ∆∞·ªõc s·ªë!")
            is_basic_prime = False
            break
        else:
            print(f"  {n} % {i} = {n % i}")
    
    if is_basic_prime and n > 11:
        print(f"  ... (ti·∫øp t·ª•c ki·ªÉm tra ƒë·∫øn {n-1})")
    
    # So s√°nh k·∫øt qu·∫£ c√°c ph∆∞∆°ng ph√°p
    print(f"\nSo s√°nh k·∫øt qu·∫£:")
    print(f"  School Method:      {is_prime_basic(n)}")
    print(f"  Optimized Method:   {is_prime_optimized(n)}")
    print(f"  6k¬±1 Method:        {is_prime_6k(n)}")
    
    # Gi·∫£i th√≠ch t·∫°i sao ch·ªâ c·∫ßn ki·ªÉm tra ƒë·∫øn ‚àön
    if n > 4:
        sqrt_n = int(math.sqrt(n))
        print(f"\nGi·∫£i th√≠ch t·ªëi ∆∞u h√≥a:")
        print(f"  ‚àö{n} ‚âà {sqrt_n}")
        print(f"  ‚Üí Ch·ªâ c·∫ßn ki·ªÉm tra ƒë·∫øn {sqrt_n} thay v√¨ {n-1}")

def compare_performance(n):
    """So s√°nh hi·ªáu su·∫•t c√°c ph∆∞∆°ng ph√°p"""
    print(f"\n‚è±Ô∏è SO S√ÅNH HI·ªÜU SU·∫§T cho n = {n}:")
    
    iterations = 10000
    
    # Test Basic Method
    start = time.perf_counter()
    for _ in range(iterations):
        is_prime_basic(n)
    duration1 = (time.perf_counter() - start) * 1000  # ms
    
    # Test Optimized Method
    start = time.perf_counter()
    for _ in range(iterations):
        is_prime_optimized(n)
    duration2 = (time.perf_counter() - start) * 1000  # ms
    
    # Test 6k¬±1 Method
    start = time.perf_counter()
    for _ in range(iterations):
        is_prime_6k(n)
    duration3 = (time.perf_counter() - start) * 1000  # ms
    
    print(f"  Basic Method:     {duration1:.2f} ms")
    print(f"  Optimized Method: {duration2:.2f} ms")
    print(f"  6k¬±1 Method:      {duration3:.2f} ms")
    
    print(f"\nTƒÉng t·ªëc so v·ªõi Basic Method:")
    if duration2 > 0:
        print(f"  Optimized: {duration1/duration2:.1f}x")
    if duration3 > 0:
        print(f"  6k¬±1:      {duration1/duration3:.1f}x")

def find_primes_in_range(start, end):
    """T√¨m t·∫•t c·∫£ s·ªë nguy√™n t·ªë trong kho·∫£ng [start, end]"""
    primes = []
    for n in range(start, end + 1):
        if is_prime_optimized(n):
            primes.append(n)
    return primes

def main():
    print("CHUY√äN ƒê·ªÄ: KI·ªÇM TRA S·ªê NGUY√äN T·ªê")
    print("==================================")
    
    # Test v·ªõi c√°c v√≠ d·ª• t·ª´ GeeksforGeeks
    demo_primality_test(11)  # true
    demo_primality_test(15)  # false
    demo_primality_test(1)   # false
    demo_primality_test(29)  # true
    
    # So s√°nh hi·ªáu su·∫•t
    compare_performance(997)  # S·ªë nguy√™n t·ªë l·ªõn
    
    # T√¨m s·ªë nguy√™n t·ªë trong kho·∫£ng
    print(f"\nüî¢ C√ÅC S·ªê NGUY√äN T·ªê T·ª™ 1 ƒê·∫æN 50:")
    primes = find_primes_in_range(1, 50)
    print(f"  {primes}")
    print(f"  T·ªïng c·ªông: {len(primes)} s·ªë nguy√™n t·ªë")

if __name__ == "__main__":
    main()
```

---

## 5. SO S√ÅNH C√ÅC PH∆Ø∆†NG PH√ÅP

### üìä B·∫£ng so s√°nh

| Ph∆∞∆°ng ph√°p | ƒê·ªô ph·ª©c t·∫°p | S·ªë ph√©p to√°n (n=100) | ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm |
|-------------|-------------|---------------------|---------|------------|
| **School Method** | O(n) | ~98 | D·ªÖ hi·ªÉu | Ch·∫≠m v·ªõi s·ªë l·ªõn |
| **Optimized** | O(‚àön) | ~10 | Nhanh h∆°n nhi·ªÅu | C·∫ßn hi·ªÉu ‚àön |
| **6k¬±1** | O(‚àön) | ~3 | Nhanh nh·∫•t | Ph·ª©c t·∫°p h∆°n |

### üéØ Ph√¢n t√≠ch chi ti·∫øt

#### School Method (C∆° b·∫£n):
```cpp
for (int i = 2; i < n; i++)  // Ki·ªÉm tra n-2 s·ªë
```

#### Optimized Method:
```cpp  
for (int i = 2; i <= sqrt(n); i++)  // Ch·ªâ ki·ªÉm tra ‚àön s·ªë
```

#### 6k¬±1 Method:
```cpp
for (int i = 5; i*i <= n; i += 6)  // Ch·ªâ ki·ªÉm tra c√°c s·ªë d·∫°ng 6k¬±1
```

### üí° T·∫°i sao ph∆∞∆°ng ph√°p 6k¬±1 hi·ªáu qu·∫£?

T·∫•t c·∫£ s·ªë nguy√™n c√≥ th·ªÉ vi·∫øt d∆∞·ªõi d·∫°ng **6k + i** v·ªõi i = 0, 1, 2, 3, 4, 5:
- **6k + 0**: Chia h·∫øt cho 6 ‚Üí kh√¥ng nguy√™n t·ªë
- **6k + 1**: C√≥ th·ªÉ nguy√™n t·ªë ‚úì
- **6k + 2**: Chia h·∫øt cho 2 ‚Üí kh√¥ng nguy√™n t·ªë  
- **6k + 3**: Chia h·∫øt cho 3 ‚Üí kh√¥ng nguy√™n t·ªë
- **6k + 4**: Chia h·∫øt cho 2 ‚Üí kh√¥ng nguy√™n t·ªë
- **6k + 5 = 6k - 1**: C√≥ th·ªÉ nguy√™n t·ªë ‚úì

**K·∫øt lu·∫≠n**: Ch·ªâ c·∫ßn ki·ªÉm tra c√°c s·ªë d·∫°ng **6k¬±1**.

---

## 6. B√ÄI T·∫¨P TH·ª∞C H√ÄNH

### üìù B√†i t·∫≠p c∆° b·∫£n

**B√†i 1**: Vi·∫øt ch∆∞∆°ng tr√¨nh nh·∫≠p m·ªôt s·ªë v√† ki·ªÉm tra c√≥ ph·∫£i s·ªë nguy√™n t·ªë kh√¥ng.

**B√†i 2**: T√¨m t·∫•t c·∫£ s·ªë nguy√™n t·ªë t·ª´ 1 ƒë·∫øn 100 v√† ƒë·∫øm c√≥ bao nhi√™u s·ªë.

**B√†i 3**: T√¨m s·ªë nguy√™n t·ªë l·ªõn nh·∫•t nh·ªè h∆°n n cho tr∆∞·ªõc.

### üî• B√†i t·∫≠p n√¢ng cao

**B√†i 4**: **Twin Primes**: T√¨m c√°c c·∫∑p s·ªë nguy√™n t·ªë sinh ƒë√¥i (p, p+2).
```
V√≠ d·ª•: (3,5), (5,7), (11,13), (17,19), (29,31)
```

**B√†i 5**: **Goldbach Conjecture**: Ki·ªÉm tra m·ªçi s·ªë ch·∫µn > 2 ƒë·ªÅu c√≥ th·ªÉ bi·ªÉu di·ªÖn th√†nh t·ªïng c·ªßa hai s·ªë nguy√™n t·ªë.
```cpp
// V√≠ d·ª•: 4 = 2+2, 6 = 3+3, 8 = 3+5, 10 = 3+7 = 5+5
bool checkGoldbach(int n) {
    for (int i = 2; i <= n/2; i++) {
        if (isPrime(i) && isPrime(n - i)) {
            cout << n << " = " << i << " + " << (n-i) << endl;
            return true;
        }
    }
    return false;
}
```

**B√†i 6**: **Sieve of Eratosthenes**: Implement thu·∫≠t to√°n s√†ng ƒë·ªÉ t√¨m t·∫•t c·∫£ s·ªë nguy√™n t·ªë ‚â§ n.

### üí° B√†i t·∫≠p ·ª©ng d·ª•ng

**B√†i 7**: **Prime Factorization**: Ph√¢n t√≠ch m·ªôt s·ªë th√†nh th·ª´a s·ªë nguy√™n t·ªë.
```
V√≠ d·ª•: 60 = 2¬≤ √ó 3 √ó 5
```

**B√†i 8**: **RSA Cryptography**: M√¥ ph·ªèng ƒë∆°n gi·∫£n thu·∫≠t to√°n RSA s·ª≠ d·ª•ng hai s·ªë nguy√™n t·ªë.

**B√†i 9**: **Prime Gaps**: T√¨m kho·∫£ng c√°ch l·ªõn nh·∫•t gi·ªØa hai s·ªë nguy√™n t·ªë li√™n ti·∫øp trong m·ªôt ƒëo·∫°n.

### üöÄ B√†i t·∫≠p th√°ch th·ª©c

**B√†i 10**: **Miller-Rabin Test**: Implement thu·∫≠t to√°n ki·ªÉm tra nguy√™n t·ªë x√°c su·∫•t.

**B√†i 11**: **Segmented Sieve**: T√¨m s·ªë nguy√™n t·ªë trong ƒëo·∫°n [L, R] v·ªõi R-L ‚â§ 10‚Å∂ v√† R ‚â§ 10¬π¬≤.

**B√†i 12**: **Prime Counting**: ƒê·∫øm s·ªë l∆∞·ª£ng s·ªë nguy√™n t·ªë ‚â§ n (Prime counting function œÄ(n)).

---

## 7. T√ìM T·∫ÆT

### üéØ Nh·ªØng ƒëi·ªÅu c·∫ßn nh·ªõ

1. **ƒê·ªãnh nghƒ©a**: S·ªë nguy√™n t·ªë > 1, ch·ªâ c√≥ ∆∞·ªõc 1 v√† ch√≠nh n√≥
2. **Ba ph∆∞∆°ng ph√°p**: School (O(n)), Optimized (O(‚àön)), 6k¬±1 (O(‚àön) nhanh h∆°n)
3. **T·ªëi ∆∞u quan tr·ªçng**: Ch·ªâ c·∫ßn ki·ªÉm tra ƒë·∫øn ‚àön
4. **Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát**: n ‚â§ 1 kh√¥ng ph·∫£i s·ªë nguy√™n t·ªë

### üöÄ K·ªπ nƒÉng ƒë√£ h·ªçc

- Hi·ªÉu b·∫£n ch·∫•t c·ªßa s·ªë nguy√™n t·ªë
- Ph√¢n t√≠ch v√† t·ªëi ∆∞u thu·∫≠t to√°n t·ª´ O(n) ‚Üí O(‚àön)
- √Åp d·ª•ng t√≠nh ch·∫•t to√°n h·ªçc (6k¬±1) ƒë·ªÉ tƒÉng t·ªëc
- So s√°nh hi·ªáu su·∫•t c√°c thu·∫≠t to√°n

### üìà ·ª®ng d·ª•ng th·ª±c t·∫ø

- **M√£ h√≥a**: RSA, Diffie-Hellman
- **Hash functions**: S·ª≠ d·ª•ng s·ªë nguy√™n t·ªë ƒë·ªÉ gi·∫£m collision
- **Random number generation**: T·∫°o s·ªë ng·∫´u nhi√™n ch·∫•t l∆∞·ª£ng cao
- **Number theory**: C∆° s·ªü cho nhi·ªÅu ƒë·ªãnh l√Ω to√°n h·ªçc

### üìö B∆∞·ªõc ti·∫øp theo

- Th·ª±c h√†nh c√°c b√†i t·∫≠p trong chuy√™n ƒë·ªÅ
- T√¨m hi·ªÉu Sieve of Eratosthenes v√† c√°c thu·∫≠t to√°n n√¢ng cao
- √Åp d·ª•ng v√†o b√†i to√°n ph√¢n t√≠ch th·ª´a s·ªë nguy√™n t·ªë
- Nghi√™n c·ª©u v·ªÅ cryptography v√† ·ª©ng d·ª•ng s·ªë nguy√™n t·ªë

---

**üéì Ch√∫c c√°c em n·∫Øm v·ªØng ki·∫øn th·ª©c v·ªÅ s·ªë nguy√™n t·ªë v√† √°p d·ª•ng hi·ªáu qu·∫£!**