# CHUYÊN ĐỀ: DIGITAL ROOT (REPEATED DIGITAL SUM)

**Dành cho lớp 10 chuyên Tin học**

---

## 1. KHÁI NIỆM CƠ BẢN

### 1.1. Định nghĩa
Digital Root (còn gọi là Repeated Digital Sum) là kết quả cuối cùng sau khi liên tục tính tổng các chữ số của một số nguyên dương cho đến khi thu được một chữ số duy nhất.

**Quy trình:**
1. Tính tổng tất cả các chữ số của số
2. Nếu kết quả là một chữ số (< 10) → Kết thúc
3. Nếu kết quả có nhiều hơn một chữ số → Lặp lại bước 1 với số mới

### 1.2. Ví dụ minh họa

**Ví dụ 1:** n = 1234
- Bước 1: 1 + 2 + 3 + 4 = 10
- Bước 2: 1 + 0 = 1
- **Kết quả:** Digital Root = 1

**Ví dụ 2:** n = 5674
- Bước 1: 5 + 6 + 7 + 4 = 22
- Bước 2: 2 + 2 = 4
- **Kết quả:** Digital Root = 4

**Ví dụ 3:** n = 999
- Bước 1: 9 + 9 + 9 = 27
- Bước 2: 2 + 7 = 9
- **Kết quả:** Digital Root = 9

---

## 2. PHÂN TÍCH BÀI TOÁN

### 2.1. Đề bài
Cho một số nguyên dương n (có thể rất lớn, được biểu diễn dưới dạng chuỗi), hãy tìm Digital Root của số đó.

**Input:** Chuỗi ký tự biểu diễn số nguyên dương
**Output:** Digital Root của số đó (một chữ số từ 1-9, hoặc 0 nếu input là 0)

### 2.2. Ví dụ test case
```
Test case 1:
Input: "1234"
Output: 1

Test case 2:
Input: "5674" 
Output: 4

Test case 3:
Input: "999"
Output: 9

Test case 4:
Input: "0"
Output: 0
```

---

## 3. CÁC PHƯƠNG PHÁP GIẢI

### 3.1. Phương pháp 1: Simulation (Mô phỏng)

#### 3.1.1. Ý tưởng
Thực hiện đúng theo định nghĩa: liên tục tính tổng các chữ số cho đến khi được một chữ số.

#### 3.1.2. Thuật toán
```
Bước 1: Đọc số dưới dạng chuỗi
Bước 2: Trong khi chuỗi có độ dài > 1:
        - Tính tổng tất cả các chữ số
        - Chuyển tổng thành chuỗi mới
Bước 3: Trả về chữ số cuối cùng
```

#### 3.1.3. Cài đặt C++
```cpp
#include <iostream>
#include <string>
using namespace std;

// Hàm tính tổng các chữ số trong chuỗi
int sumDigits(string num) {
    int sum = 0;
    for (char digit : num) {
        sum += digit - '0';
    }
    return sum;
}

// Hàm tính Digital Root bằng phương pháp mô phỏng
int digitalRootSimulation(string num) {
    // Xử lý trường hợp đặc biệt
    if (num == "0") return 0;
    
    while (num.length() > 1) {
        int sum = sumDigits(num);
        num = to_string(sum);
    }
    
    return stoi(num);
}

int main() {
    string num;
    cout << "Nhap so: ";
    cin >> num;
    
    int result = digitalRootSimulation(num);
    cout << "Digital Root cua " << num << " la: " << result << endl;
    
    return 0;
}
```

#### 3.1.4. Cài đặt Python
```python
def sum_digits(num_str):
    """Tính tổng các chữ số trong chuỗi"""
    return sum(int(digit) for digit in num_str)

def digital_root_simulation(num_str):
    """Tính Digital Root bằng phương pháp mô phỏng"""
    # Xử lý trường hợp đặc biệt
    if num_str == "0":
        return 0
    
    while len(num_str) > 1:
        sum_val = sum_digits(num_str)
        num_str = str(sum_val)
    
    return int(num_str)

# Chương trình chính
num = input("Nhap so: ")
result = digital_root_simulation(num)
print(f"Digital Root cua {num} la: {result}")
```

### 3.2. Phương pháp 2: Công thức toán học (Optimal)

#### 3.2.1. Lý thuyết toán học
Dựa trên tính chất của hệ thập phân, ta có thể chứng minh rằng:

**Với số abcd có thể viết thành:**
```
abcd = a×10³ + b×10² + c×10¹ + d×10⁰
     = a + b + c + d + a×999 + b×99 + c×9
     = (a + b + c + d) + 9×(a×111 + b×11 + c)
```

**Khi lấy modulo 9:**
```
abcd % 9 = (a + b + c + d) % 9
```

**Kết luận:**
- Digital Root của một số bằng `n % 9`
- **Ngoại lệ:** Nếu `n % 9 = 0` và `n ≠ 0` → Digital Root = 9
- **Trường hợp đặc biệt:** Nếu `n = 0` → Digital Root = 0

#### 3.2.2. Công thức
```
Digital Root = {
    0           nếu n = 0
    9           nếu n % 9 = 0 và n ≠ 0  
    n % 9       trong các trường hợp khác
}
```

#### 3.2.3. Cài đặt C++
```cpp
#include <iostream>
#include <string>
using namespace std;

// Hàm tính Digital Root bằng công thức toán học
int digitalRootOptimal(string num) {
    // Trường hợp đặc biệt: số 0
    if (num == "0") return 0;
    
    // Tính tổng các chữ số để tránh overflow với số lớn
    int sum = 0;
    for (char digit : num) {
        sum += digit - '0';
    }
    
    // Áp dụng công thức
    if (sum % 9 == 0) {
        return 9;
    }
    return sum % 9;
}

// Phiên bản cho số nguyên nhỏ
int digitalRootOptimal(int n) {
    if (n == 0) return 0;
    
    if (n % 9 == 0) {
        return 9;
    }
    return n % 9;
}

int main() {
    string num;
    cout << "Nhap so: ";
    cin >> num;
    
    int result = digitalRootOptimal(num);
    cout << "Digital Root cua " << num << " la: " << result << endl;
    
    // Test với số nguyên nhỏ
    int small_num = 1234;
    cout << "Digital Root cua " << small_num << " la: " << digitalRootOptimal(small_num) << endl;
    
    return 0;
}
```

#### 3.2.4. Cài đặt Python
```python
def digital_root_optimal(num_str):
    """Tính Digital Root bằng công thức toán học"""
    # Trường hợp đặc biệt: số 0
    if num_str == "0":
        return 0
    
    # Tính tổng các chữ số để tránh overflow với số lớn
    digit_sum = sum(int(digit) for digit in num_str)
    
    # Áp dụng công thức
    if digit_sum % 9 == 0:
        return 9
    return digit_sum % 9

def digital_root_optimal_int(n):
    """Phiên bản cho số nguyên nhỏ"""
    if n == 0:
        return 0
    
    if n % 9 == 0:
        return 9
    return n % 9

# Chương trình chính
num = input("Nhap so: ")
result = digital_root_optimal(num)
print(f"Digital Root cua {num} la: {result}")

# Test với số nguyên nhỏ
small_num = 1234
print(f"Digital Root cua {small_num} la: {digital_root_optimal_int(small_num)}")
```

---

## 4. PHÂN TÍCH ĐỘ PHỨC TẠP

### 4.1. Phương pháp 1 (Simulation)
- **Độ phức tạp thời gian:** O(log n × log log n)
  - Cần log n lần lặp để giảm số xuống 1 chữ số
  - Mỗi lần tính tổng mất O(số chữ số hiện tại)
- **Độ phức tạp không gian:** O(log n) - lưu trữ chuỗi

### 4.2. Phương pháp 2 (Optimal)
- **Độ phức tạp thời gian:** O(log n) - chỉ cần duyệt qua các chữ số một lần
- **Độ phức tạp không gian:** O(1) - chỉ cần biến lưu tổng

---

## 5. SO SÁNH CÁC PHƯƠNG PHÁP

| Tiêu chí | Phương pháp 1 (Simulation) | Phương pháp 2 (Optimal) |
|----------|----------------------------|--------------------------|
| Độ phức tạp thời gian | O(log n × log log n) | O(log n) |
| Độ phức tạp không gian | O(log n) | O(1) |
| Dễ hiểu | Rất dễ | Cần hiểu lý thuyết |
| Hiệu suất | Chậm | Rất nhanh |
| Xử lý số lớn | Chậm | Tối ưu |

### Khuyến nghị
- **Phương pháp 1:** Dùng để hiểu bài toán, phù hợp khi số nhỏ
- **Phương pháp 2:** Sử dụng trong thực tế, đặc biệt với số lớn

---

## 6. TÍNH CHẤT ĐẶC BIỆT CỦA DIGITAL ROOT

### 6.1. Chu kỳ Digital Root
Digital Root của các số tự nhiên có chu kỳ 9:

| Số | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | ... | 18 | 19 |
|----|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|
| DR | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1  | 2  | 3  | ... | 9  | 1  |

### 6.2. Ứng dụng thực tế
1. **Kiểm tra tính chia hết cho 9:** Số chia hết cho 9 ⟺ Digital Root = 9
2. **Checksum đơn giản:** Kiểm tra lỗi trong truyền dữ liệu
3. **Numerology:** Sử dụng trong các ứng dụng về số học thần bí

---

## 7. BÀI TẬP THỰC HÀNH

### 7.1. Bài tập cơ bản
1. Tính Digital Root của: 456, 789, 999, 1000, 12345
2. Viết chương trình tìm tất cả số từ 1-100 có Digital Root = 7
3. Kiểm tra số nào trong dãy sau chia hết cho 9: 123, 456, 789, 999

### 7.2. Bài tập nâng cao
1. **Digital Root của tích:** Cho hai số a, b. So sánh Digital Root của (a×b) và (Digital Root(a) × Digital Root(b))
2. **Digital Root dãy số:** Tính Digital Root của tổng các số từ 1 đến n
3. **Digital Root palindrome:** Tìm số palindrome có Digital Root cho trước

### 7.3. Code mẫu bài tập mở rộng

#### Tìm số có Digital Root = k (C++)
```cpp
#include <iostream>
#include <vector>
using namespace std;

int digitalRoot(int n) {
    if (n == 0) return 0;
    return (n % 9 == 0) ? 9 : n % 9;
}

vector<int> findNumbersWithDigitalRoot(int limit, int target_dr) {
    vector<int> result;
    for (int i = 0; i <= limit; i++) {
        if (digitalRoot(i) == target_dr) {
            result.push_back(i);
        }
    }
    return result;
}

int main() {
    int limit, target;
    cout << "Nhap gioi han: ";
    cin >> limit;
    cout << "Nhap Digital Root can tim: ";
    cin >> target;
    
    vector<int> numbers = findNumbersWithDigitalRoot(limit, target);
    
    cout << "Cac so tu 0 den " << limit << " co Digital Root = " << target << ":\n";
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
```

#### Tìm số có Digital Root = k (Python)
```python
def digital_root(n):
    """Tính Digital Root của số n"""
    if n == 0:
        return 0
    return 9 if n % 9 == 0 else n % 9

def find_numbers_with_digital_root(limit, target_dr):
    """Tìm các số có Digital Root = target_dr"""
    return [i for i in range(limit + 1) if digital_root(i) == target_dr]

# Chương trình chính
limit = int(input("Nhap gioi han: "))
target = int(input("Nhap Digital Root can tim: "))

numbers = find_numbers_with_digital_root(limit, target)

print(f"Cac so tu 0 den {limit} co Digital Root = {target}:")
print(" ".join(map(str, numbers)))
```

---

## 8. CHƯƠNG TRÌNH DEMO TƯƠNG TÁC

### 8.1. Demo C++
```cpp
#include <iostream>
#include <string>
#include <iomanip>
using namespace std;

class DigitalRootCalculator {
private:
    // Phương pháp simulation
    int simulationMethod(string num) {
        if (num == "0") return 0;
        
        cout << "\n=== PHƯƠNG PHÁP SIMULATION ===" << endl;
        cout << "Số ban đầu: " << num << endl;
        
        int step = 1;
        while (num.length() > 1) {
            int sum = 0;
            cout << "Bước " << step << ": ";
            for (int i = 0; i < num.length(); i++) {
                sum += num[i] - '0';
                cout << num[i];
                if (i < num.length() - 1) cout << " + ";
            }
            cout << " = " << sum << endl;
            num = to_string(sum);
            step++;
        }
        
        int result = stoi(num);
        cout << "Digital Root = " << result << endl;
        return result;
    }
    
    // Phương pháp optimal
    int optimalMethod(string num) {
        cout << "\n=== PHƯƠNG PHÁP OPTIMAL ===" << endl;
        
        if (num == "0") {
            cout << "Số 0 → Digital Root = 0" << endl;
            return 0;
        }
        
        // Tính tổng các chữ số
        int sum = 0;
        cout << "Tính tổng các chữ số: ";
        for (int i = 0; i < num.length(); i++) {
            sum += num[i] - '0';
            cout << num[i];
            if (i < num.length() - 1) cout << " + ";
        }
        cout << " = " << sum << endl;
        
        int result;
        if (sum % 9 == 0) {
            result = 9;
            cout << sum << " % 9 = 0 → Digital Root = 9" << endl;
        } else {
            result = sum % 9;
            cout << sum << " % 9 = " << result << " → Digital Root = " << result << endl;
        }
        
        return result;
    }

public:
    void calculate(string num) {
        cout << string(50, '=') << endl;
        cout << "TÍNH DIGITAL ROOT CỦA SỐ: " << num << endl;
        cout << string(50, '=') << endl;
        
        int result1 = simulationMethod(num);
        int result2 = optimalMethod(num);
        
        cout << "\n=== KẾT QUẢ ===" << endl;
        cout << "Phương pháp Simulation: " << result1 << endl;
        cout << "Phương pháp Optimal: " << result2 << endl;
        cout << "Kết quả khớp: " << (result1 == result2 ? "✓" : "✗") << endl;
    }
};

int main() {
    DigitalRootCalculator calc;
    string num;
    
    while (true) {
        cout << "\nNhập số cần tính Digital Root (hoặc 'exit' để thoát): ";
        cin >> num;
        
        if (num == "exit") break;
        
        calc.calculate(num);
        cout << endl;
    }
    
    return 0;
}
```

---

## 9. TỔNG KẾT

### 9.1. Kiến thức đã học
- Khái niệm Digital Root và cách tính
- Hai phương pháp giải: Simulation và Optimal
- Lý thuyết toán học đằng sau công thức optimal
- Tính chất và ứng dụng của Digital Root

### 9.2. Kỹ năng phát triển
- Tư duy thuật toán từ đơn giản đến tối ưu
- Áp dụng lý thuyết toán học vào lập trình
- Phân tích độ phức tạp thuật toán
- Xử lý số lớn dưới dạng chuỗi

### 9.3. Bài học quan trọng
- Không phải lúc nào cũng cần mô phỏng trực tiếp
- Lý thuyết toán học có thể giúp tối ưu hóa đáng kể
- Luôn xem xét các trường hợp đặc biệt (số 0, số 9)
- Hiệu suất quan trọng khi xử lý dữ liệu lớn

---