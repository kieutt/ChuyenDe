# CHUYÊN ĐỀ: ĐẾM CẶP SỐ CÓ TỔNG LŨY THỪA BẬC 3 BẰNG N

## 1. MỤC TIÊU HỌC TẬP

Sau khi hoàn thành chuyên đề này, học sinh sẽ có thể:
- Hiểu bài toán tìm cặp số thỏa mãn phương trình a³ + b³ = n
- So sánh và phân tích hai phương pháp giải: Brute Force và Tối ưu
- Áp dụng kiến thức về căn bậc ba và perfect cube
- Tối ưu hóa thuật toán từ O(n²) xuống O(n^(1/3))
- Xử lý các vấn đề về độ chính xác trong tính toán số thực

## 2. CƠ SỞ LÝ THUYẾT

### 2.1. Định nghĩa bài toán
Cho một số nguyên dương n, đếm tất cả các cặp số nguyên (a, b) thỏa mãn:
```
a³ + b³ = n
```

**Lưu ý quan trọng:** (a, b) và (b, a) được coi là hai cặp khác nhau.

### 2.2. Khái niệm Perfect Cube
**Perfect Cube** là số có thể biểu diễn dưới dạng lũy thừa bậc 3 của một số nguyên:
- 1 = 1³ (perfect cube)
- 8 = 2³ (perfect cube)  
- 27 = 3³ (perfect cube)
- 64 = 4³ (perfect cube)

### 2.3. Tính chất toán học
- Nếu a³ + b³ = n, thì b³ = n - a³
- b là số nguyên ⟺ (n - a³) là perfect cube
- Giới hạn tìm kiếm: 1 ≤ a ≤ ∛n

## 3. CÁC VÍ DỤ MINH HỌA

### Ví dụ 1:
**Input:** n = 9
**Phân tích:**
- a = 1: b³ = 9 - 1³ = 8 = 2³ → b = 2 ✓ → cặp (1,2)
- a = 2: b³ = 9 - 2³ = 1 = 1³ → b = 1 ✓ → cặp (2,1)

**Output:** 2 cặp

### Ví dụ 2:
**Input:** n = 28  
**Phân tích:**
- a = 1: b³ = 28 - 1 = 27 = 3³ → b = 3 ✓ → cặp (1,3)
- a = 2: b³ = 28 - 8 = 20 ≠ perfect cube ✗
- a = 3: b³ = 28 - 27 = 1 = 1³ → b = 1 ✓ → cặp (3,1)

**Output:** 2 cặp

### Ví dụ 3:
**Input:** n = 2
**Phân tích:**
- a = 1: b³ = 2 - 1 = 1 = 1³ → b = 1 ✓ → cặp (1,1)

**Output:** 1 cặp

## 4. HIỆN THỰC THUẬT TOÁN

### 4.1. Phương pháp 1: Brute Force - O(n²)

**Ý tưởng:** Duyệt tất cả các cặp (a,b) và kiểm tra điều kiện a³ + b³ = n

**Code C++:**
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

// Phương pháp Brute Force - O(n²)
int countPairsBruteForce(int n) {
    int count = 0;
    vector<pair<int, int>> pairs; // Lưu trữ các cặp tìm được
    
    cout << "=== PHƯƠNG PHÁP BRUTE FORCE ===\n";
    cout << "Tìm tất cả cặp (a,b) sao cho a³ + b³ = " << n << "\n\n";
    
    // Duyệt tất cả các giá trị a từ 1 đến n
    for (int a = 1; a <= n; a++) {
        int a_cubed = a * a * a;
        if (a_cubed > n) break; // Tối ưu: dừng sớm nếu a³ > n
        
        // Duyệt tất cả các giá trị b từ 0 đến n  
        for (int b = 0; b <= n; b++) {
            int b_cubed = b * b * b;
            if (a_cubed + b_cubed > n) break; // Tối ưu: dừng sớm
            
            if (a_cubed + b_cubed == n) {
                count++;
                pairs.push_back({a, b});
                cout << "Tìm thấy cặp: (" << a << ", " << b << ") ";
                cout << "→ " << a << "³ + " << b << "³ = " 
                     << a_cubed << " + " << b_cubed << " = " << n << "\n";
            }
        }
    }
    
    cout << "\nTổng số cặp tìm được: " << count << "\n";
    return count;
}

// Hàm kiểm tra hiệu suất
void analyzeBruteForce(int n) {
    clock_t start = clock();
    int result = countPairsBruteForce(n);
    clock_t end = clock();
    
    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;
    cout << "Thời gian thực hiện: " << time_taken << " giây\n";
    cout << "Độ phức tạp: O(n²) = O(" << n << "²) = O(" << n*n << ")\n\n";
}
```

### 4.2. Phương pháp 2: Tối ưu - O(n^(1/3))

**Ý tưởng:** 
1. Chỉ duyệt a từ 1 đến ∛n
2. Tính b³ = n - a³
3. Kiểm tra b³ có phải perfect cube không

**Code Python:**
```python
import math
import time

def is_perfect_cube(num):
    """
    Kiểm tra một số có phải là perfect cube không
    
    Args:
        num: Số cần kiểm tra
    
    Returns:
        tuple: (is_perfect, cube_root) nếu là perfect cube
               (False, -1) nếu không phải
    """
    if num < 0:
        return False, -1
    
    if num == 0:
        return True, 0
    
    # Tính căn bậc ba
    cube_root = round(num ** (1/3))
    
    # Kiểm tra chính xác do floating point errors
    if cube_root ** 3 == num:
        return True, cube_root
    
    # Kiểm tra thêm các giá trị lân cận do rounding errors
    for delta in [-1, 1]:
        test_root = cube_root + delta
        if test_root >= 0 and test_root ** 3 == num:
            return True, test_root
    
    return False, -1

def count_pairs_optimized(n):
    """
    Đếm cặp số có tổng lũy thừa bậc 3 bằng n - Phương pháp tối ưu
    
    Args:
        n: Số nguyên dương
    
    Returns:
        int: Số lượng cặp tìm được
    """
    count = 0
    pairs = []
    
    print("=== PHƯƠNG PHÁP TỐI ƯU ===")
    print(f"Tìm tất cả cặp (a,b) sao cho a³ + b³ = {n}")
    
    # Tính căn bậc ba của n để giới hạn phạm vi tìm kiếm
    max_a = int(n ** (1/3)) + 1
    print(f"Giới hạn tìm kiếm: 1 ≤ a ≤ {max_a}")
    print(f"Độ phức tạp giảm từ O(n²) xuống O(∛n)\n")
    
    # Chỉ duyệt a từ 1 đến ∛n
    for a in range(1, max_a + 1):
        a_cubed = a ** 3
        
        if a_cubed > n:
            break
        
        # Tính b³ = n - a³
        b_cubed = n - a_cubed
        
        print(f"a = {a}: a³ = {a_cubed}, b³ = {n} - {a_cubed} = {b_cubed}")
        
        # Kiểm tra b³ có phải perfect cube không
        is_cube, b = is_perfect_cube(b_cubed)
        
        if is_cube and b >= 0:
            count += 1
            pairs.append((a, b))
            print(f"  ✓ {b_cubed} = {b}³ → Tìm thấy cặp ({a}, {b})")
        else:
            print(f"  ✗ {b_cubed} không phải perfect cube")
    
    print(f"\nCác cặp tìm được: {pairs}")
    print(f"Tổng số cặp: {count}")
    
    return count

def compare_methods(n):
    """So sánh hiệu suất giữa hai phương pháp"""
    print(f"\n{'='*60}")
    print(f"SO SÁNH HIỆU SUẤT CHO N = {n}")
    print(f"{'='*60}")
    
    # Phương pháp Brute Force
    print("\n1. PHƯƠNG PHÁP BRUTE FORCE:")
    start_time = time.time()
    result1 = count_pairs_brute_force(n)
    time1 = time.time() - start_time
    
    print(f"   Kết quả: {result1}")
    print(f"   Thời gian: {time1:.6f} giây")
    print(f"   Độ phức tạp: O(n²) = O({n}²) = O({n**2})")
    
    # Phương pháp Tối ưu
    print("\n2. PHƯƠNG PHÁP TỐI ƯU:")
    start_time = time.time()
    result2 = count_pairs_optimized(n)
    time2 = time.time() - start_time
    
    max_a = int(n ** (1/3)) + 1
    print(f"   Kết quả: {result2}")
    print(f"   Thời gian: {time2:.6f} giây")
    print(f"   Độ phức tạp: O(∛n) = O({n}^(1/3)) ≈ O({max_a})")
    
    # So sánh
    if time1 > 0:
        speedup = time1 / time2 if time2 > 0 else float('inf')
        print(f"\n3. KẾT QUẢ SO SÁNH:")
        print(f"   Tỷ lệ tăng tốc: {speedup:.2f}x")
        print(f"   Độ chính xác: {'✓' if result1 == result2 else '✗'}")

def count_pairs_brute_force(n):
    """Phiên bản đơn giản của brute force cho so sánh"""
    count = 0
    for a in range(1, n + 1):
        a_cubed = a ** 3
        if a_cubed > n:
            break
        for b in range(n + 1):
            if a_cubed + b ** 3 == n:
                count += 1
            elif a_cubed + b ** 3 > n:
                break
    return count

def demonstrate_perfect_cube_check():
    """Demo kiểm tra perfect cube"""
    print("\n" + "="*50)
    print("DEMO: KIỂM TRA PERFECT CUBE")
    print("="*50)
    
    test_numbers = [0, 1, 8, 27, 64, 125, 10, 20, 30]
    
    for num in test_numbers:
        is_cube, root = is_perfect_cube(num)
        if is_cube:
            print(f"{num:3d} = {root}³ → Perfect Cube ✓")
        else:
            print(f"{num:3d} → Không phải Perfect Cube ✗")

# Chương trình chính
def main():
    print("CHUYÊN ĐỀ: ĐỀM CẶP SỐ CÓ TỔNG LŨY THỪA BẬC 3 BẰNG N")
    print("="*60)
    
    # Demo kiểm tra perfect cube
    demonstrate_perfect_cube_check()
    
    # Test với các ví dụ
    test_cases = [9, 28, 2, 16, 35]
    
    for n in test_cases:
        print(f"\n{'='*60}")
        print(f"TEST CASE: N = {n}")
        print(f"{'='*60}")
        
        result = count_pairs_optimized(n)
        
        if n <= 50:  # Chỉ so sánh với số nhỏ
            compare_methods(n)
    
    # Nhập từ người dùng
    print(f"\n{'='*60}")
    try:
        n = int(input("\nNhập giá trị N để tìm cặp: "))
        
        if n <= 0:
            print("Lỗi: N phải là số nguyên dương!")
            return
        
        if n > 1000:
            print("Cảnh báo: N lớn có thể mất thời gian với brute force!")
            choice = input("Chỉ dùng phương pháp tối ưu? (y/n): ")
            if choice.lower() == 'y':
                count_pairs_optimized(n)
            else:
                compare_methods(n)
        else:
            compare_methods(n)
            
    except ValueError:
        print("Lỗi: Vui lòng nhập số nguyên hợp lệ!")

if __name__ == "__main__":
    main()
```

## 5. PHÂN TÍCH ĐỘ PHỨC TẠP

### 5.1. So sánh hai phương pháp

| Tiêu chí | Brute Force | Tối ưu |
|----------|-------------|--------|
| **Thời gian** | O(n²) | O(n^(1/3)) |
| **Không gian** | O(1) | O(1) |
| **Dễ hiểu** | Cao | Trung bình |
| **Hiệu quả** | Thấp | Cao |

### 5.2. Phân tích chi tiết

**Brute Force:**
- Duyệt tất cả cặp (a,b): O(n²) operations
- Với n = 1000: ~1,000,000 phép toán
- Phù hợp với n nhỏ (< 100)

**Tối ưu:**
- Chỉ duyệt a từ 1 đến ∛n: O(n^(1/3)) operations  
- Với n = 1000: ~10 phép toán
- Phù hợp với n lớn

### 5.3. Ví dụ so sánh thực tế

```
N = 1000:
- Brute Force: ~1,000,000 operations
- Tối ưu:      ~10 operations  
- Tăng tốc:    ~100,000x

N = 1,000,000:
- Brute Force: ~10¹² operations
- Tối ưu:      ~100 operations
- Tăng tốc:    ~10,000,000,000x
```

## 6. XỬ LÝ CÁC VẤN ĐỀ KỸ THUẬT

### 6.1. Floating Point Precision
```cpp
// Xử lý sai số floating point khi tính căn bậc ba
bool isPerfectCube(long long num) {
    if (num < 0) return false;
    
    long long cubeRoot = round(cbrt(num));
    
    // Kiểm tra chính xác
    if (cubeRoot * cubeRoot * cubeRoot == num) return true;
    
    // Kiểm tra các giá trị lân cận do rounding error
    for (int delta = -1; delta <= 1; delta++) {
        long long testRoot = cubeRoot + delta;
        if (testRoot >= 0 && testRoot * testRoot * testRoot == num) {
            return true;
        }
    }
    
    return false;
}
```

### 6.2. Overflow Protection
```cpp
// Kiểm tra overflow trước khi tính lũy thừa
bool safeCube(int a, long long &result) {
    if (a > cbrt(LLONG_MAX)) {
        return false; // Overflow sẽ xảy ra
    }
    result = (long long)a * a * a;
    return true;
}
```

### 6.3. Binary Search Approach
```cpp
// Phương pháp Binary Search để tìm căn bậc ba
long long cubeRootBinarySearch(long long num) {
    if (num == 0) return 0;
    
    long long left = 1, right = cbrt(num) + 1;
    long long result = 0;
    
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        long long cube = mid * mid * mid;
        
        if (cube == num) return mid;
        else if (cube < num) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

## 7. BÀI TẬP THỰC HÀNH

### Bài tập 1: Cơ bản
Modify thuật toán để chỉ đếm các cặp (a,b) với a ≤ b (loại bỏ trùng lặp).

### Bài tập 2: Mở rộng
Tìm tất cả các cặp (a,b,c) sao cho a³ + b³ + c³ = n.

### Bài tập 3: Tối ưu hóa
Implement thuật toán để tìm tất cả các cặp trong khoảng [1, n] có tổng lũy thừa bậc 3 là perfect cube.

### Bài tập 4: Ứng dụng
Tìm số n nhỏ nhất có nhiều hơn k cách biểu diễn dưới dạng tổng hai lũy thừa bậc 3.

## 8. MỞ RỘNG VÀ ỨNG DỤNG

### 8.1. Generalization - Sum of k-th Powers
```cpp
// Tổng quát: a^k + b^k = n
int countKthPowerPairs(int n, int k) {
    int count = 0;
    double maxA = pow(n, 1.0/k);
    
    for (int a = 1; a <= maxA; a++) {
        long long aPowerK = pow(a, k);
        long long diff = n - aPowerK;
        
        double bDouble = pow(diff, 1.0/k);
        int b = round(bDouble);
        
        if (pow(b, k) == diff) {
            count++;
        }
    }
    
    return count;
}
```

### 8.2. Ramanujan Numbers
```cpp
// Tìm số Ramanujan: số có thể biểu diễn dưới dạng 
// tổng hai lũy thừa bậc 3 theo ít nhất 2 cách khác nhau
vector<int> findRamanujanNumbers(int limit) {
    map<int, vector<pair<int,int>>> sums;
    vector<int> ramanujan;
    
    // Tính tất cả các tổng a³ + b³
    for (int a = 1; a <= cbrt(limit); a++) {
        for (int b = a; b <= cbrt(limit - a*a*a); b++) {
            int sum = a*a*a + b*b*b;
            if (sum <= limit) {
                sums[sum].push_back({a, b});
            }
        }
    }
    
    // Tìm những số có ít nhất 2 cách biểu diễn
    for (auto& entry : sums) {
        if (entry.second.size() >= 2) {
            ramanujan.push_back(entry.first);
        }
    }
    
    return ramanujan;
}
```

### 8.3. Number Theory Applications
```cpp
// Định lý Fermat's Last Theorem check
// Không tồn tại a³ + b³ = c³ với a,b,c > 0 (đã được chứng minh)
bool checkFermatCubes(int limit) {
    for (int c = 2; c <= limit; c++) {
        long long c_cubed = (long long)c * c * c;
        
        if (countPairsOptimized(c_cubed) > 0) {
            // Tìm thấy phản ví dụ cho Fermat's Last Theorem
            // (Điều này không bao giờ xảy ra với cube)
            return false;
        }
    }
    return true; // Khẳng định định lý
}
```

## 9. BENCHMARK VÀ TEST CASES

### 9.1. Performance Testing
```
N = 10:       Brute Force vs Optimized = 0.001ms vs 0.0001ms
N = 100:      Brute Force vs Optimized = 0.1ms vs 0.001ms  
N = 1,000:    Brute Force vs Optimized = 10ms vs 0.01ms
N = 10,000:   Brute Force vs Optimized = 1000ms vs 0.1ms
N = 100,000:  Brute Force vs Optimized = 100,000ms vs 1ms
```

### 9.2. Edge Cases
```
N = 0:  Không có cặp nào (a,b ≥ 1)
N = 1:  1 cặp (1,0) - nếu cho phép b = 0  
N = 2:  1 cặp (1,1)
N = 8:  1 cặp (2,0) - nếu cho phép b = 0
N = 9:  2 cặp (1,2) và (2,1)
```

## 10. KẾT LUẬN

Bài toán đếm cặp số có tổng lũy thừa bậc 3 bằng n là một ví dụ xuất sắc về:

**Algorithm Optimization:**
- Từ O(n²) brute force xuống O(n^(1/3)) optimized
- Giảm complexity theo exponential scale

**Mathematical Insights:**
- Sử dụng tính chất perfect cube
- Áp dụng giới hạn tìm kiếm thông minh

**Implementation Challenges:**
- Xử lý floating point precision
- Overflow prevention
- Edge case handling

**Real-world Applications:**
- Number theory research
- Cryptographic applications  
- Mathematical puzzle solving
- Algorithm design patterns

Đây là một bài toán tuyệt vời để học sinh hiểu về optimization thinking, mathematical analysis, và practical programming challenges trong competitive programming và algorithm design.