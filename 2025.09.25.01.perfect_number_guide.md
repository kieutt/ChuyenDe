# CHUYÊN ĐỀ: SỐ HOÀN HẢO (PERFECT NUMBER)
## Dành cho học sinh lớp 10 Chuyên Tin

---

## 1. ĐỊNH NGHĨA VÀ KHÁI NIỆM CƠ BẢN

### 1.1. Định nghĩa số hoàn hảo
**Số hoàn hảo** (Perfect Number) là một số nguyên dương bằng tổng của tất cả các ước số thực sự của nó (không bao gồm chính nó).

### 1.2. Ước số thực sự
Ước số thực sự của một số n là tất cả các số nguyên dương chia hết cho n, ngoại trừ chính số n đó.

### 1.3. Minh họa bằng sơ đồ

```
Số 6:
┌─────────────────────────────────┐
│  Các ước số thực sự của 6:      │
│  ┌───┐ ┌───┐ ┌───┐             │
│  │ 1 │ │ 2 │ │ 3 │             │
│  └───┘ └───┘ └───┘             │
│                                 │
│  Tổng: 1 + 2 + 3 = 6 ✓         │
│  → 6 là số hoàn hảo             │
└─────────────────────────────────┘

Số 15:
┌─────────────────────────────────┐
│  Các ước số thực sự của 15:     │
│  ┌───┐ ┌───┐ ┌───┐             │
│  │ 1 │ │ 3 │ │ 5 │             │
│  └───┘ └───┘ └───┘             │
│                                 │
│  Tổng: 1 + 3 + 5 = 9 ≠ 15 ✗    │
│  → 15 không phải số hoàn hảo    │
└─────────────────────────────────┘
```

## 2. CÁC VÍ DỤ MINH HỌA

### Ví dụ 1: Kiểm tra số 6
- **Input**: n = 6
- **Các ước số thực sự**: 1, 2, 3
- **Tổng**: 1 + 2 + 3 = 6
- **Kết quả**: 6 = 6 → **TRUE** (6 là số hoàn hảo)

### Ví dụ 2: Kiểm tra số 15  
- **Input**: n = 15
- **Các ước số thực sự**: 1, 3, 5
- **Tổng**: 1 + 3 + 5 = 9
- **Kết quả**: 9 ≠ 15 → **FALSE** (15 không phải số hoàn hảo)

### Ví dụ 3: Kiểm tra số 28
- **Input**: n = 28
- **Các ước số thực sự**: 1, 2, 4, 7, 14
- **Tổng**: 1 + 2 + 4 + 7 + 14 = 28
- **Kết quả**: 28 = 28 → **TRUE** (28 là số hoàn hảo)

## 3. CÁC PHƯƠNG PHÁP GIẢI QUYẾT

### 3.1. Phương pháp 1: Thuật toán cơ bản (Naive Approach)

#### 3.1.1. Ý tưởng thuật toán
- Duyệt qua tất cả các số từ 1 đến n-1
- Kiểm tra xem số nào là ước của n
- Tính tổng tất cả các ước số thực sự
- So sánh tổng với n

#### 3.1.2. Sơ đồ thuật toán
```
┌─────────────────┐
│   Bắt đầu       │
└─────┬───────────┘
      │
┌─────▼───────────┐
│ Nhập số n       │
└─────┬───────────┘
      │
┌─────▼───────────┐
│ sum = 0         │
│ i = 1           │
└─────┬───────────┘
      │
┌─────▼───────────┐
│ i < n?          │◄─────┐
└─────┬───────────┘      │
      │ Yes              │
┌─────▼───────────┐      │
│ n % i == 0?     │      │
└─────┬───────────┘      │
      │ Yes              │
┌─────▼───────────┐      │
│ sum = sum + i   │      │
└─────┬───────────┘      │
      │                  │
┌─────▼───────────┐      │
│ i = i + 1       │──────┘
└─────────────────┘
      │ No
┌─────▼───────────┐
│ sum == n?       │
└─────┬───────────┘
      │
┌─────▼───────────┐
│ Xuất kết quả    │
└─────┬───────────┘
      │
┌─────▼───────────┐
│   Kết thúc      │
└─────────────────┘
```

#### 3.1.3. Code mẫu

**C++:**
```cpp
#include <iostream>
using namespace std;

// Hàm kiểm tra số hoàn hảo
bool isPerfect(int n) {
    int sum = 0;
    
    // Duyệt từ 1 đến n-1
    for (int i = 1; i < n; i++) {
        if (n % i == 0) {  // i là ước của n
            sum += i;
        }
    }
    
    return sum == n;
}

int main() {
    int n;
    cout << "Nhap so n: ";
    cin >> n;
    
    if (isPerfect(n)) {
        cout << n << " la so hoan hao" << endl;
    } else {
        cout << n << " khong phai la so hoan hao" << endl;
    }
    
    return 0;
}
```

**Python:**
```python
# Hàm kiểm tra số hoàn hảo
def isPerfect(n):
    sum_divisors = 0
    
    # Duyệt từ 1 đến n-1
    for i in range(1, n):
        if n % i == 0:  # i là ước của n
            sum_divisors += i
    
    return sum_divisors == n

# Chương trình chính
if __name__ == '__main__':
    n = int(input("Nhap so n: "))
    
    if isPerfect(n):
        print(f"{n} la so hoan hao")
    else:
        print(f"{n} khong phai la so hoan hao")
```

#### 3.1.4. Độ phức tạp
- **Thời gian**: O(n)
- **Không gian**: O(1)

### 3.2. Phương pháp 2: Thuật toán tối ưu (Optimized Approach)

#### 3.2.1. Ý tưởng cải tiến
Thay vì duyệt từ 1 đến n-1, chúng ta chỉ cần duyệt từ 1 đến √n vì:
- Nếu i là ước của n, thì n/i cũng là ước của n
- Các ước luôn xuất hiện theo cặp (i, n/i)

#### 3.2.2. Minh họa bằng sơ đồ

```
Tìm ước của 28:
┌─────────────────────────────────────────────────┐
│ i = 1: 28 % 1 = 0 → ước: 1                     │
│ i = 2: 28 % 2 = 0 → ước: 2, 28/2 = 14          │
│ i = 3: 28 % 3 ≠ 0                              │
│ i = 4: 28 % 4 = 0 → ước: 4, 28/4 = 7           │
│ i = 5: 28 % 5 ≠ 0                              │
│ i > √28 → dừng                                  │
│                                                 │
│ Các ước thực sự: 1, 2, 4, 7, 14                │
│ Tổng: 1 + 2 + 4 + 7 + 14 = 28 ✓               │
└─────────────────────────────────────────────────┘
```

#### 3.2.3. Code mẫu tối ưu

**C++:**
```cpp
#include <iostream>
#include <cmath>
using namespace std;

// Hàm kiểm tra số hoàn hảo tối ưu
bool isPerfect(int n) {
    // Trường hợp đặc biệt
    if (n <= 1) return false;
    
    int sum = 1;  // Bao gồm ước 1
    
    // Duyệt từ 2 đến √n
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            if (i * i != n) {
                // Thêm cả i và n/i
                sum += i + n / i;
            } else {
                // Trường hợp i = √n, chỉ thêm i
                sum += i;
            }
        }
    }
    
    return sum == n;
}

int main() {
    int n;
    cout << "Nhap so n: ";
    cin >> n;
    
    cout << "Kiem tra cac so tu 1 den " << n << ":" << endl;
    for (int i = 1; i <= n; i++) {
        if (isPerfect(i)) {
            cout << i << " la so hoan hao" << endl;
        }
    }
    
    return 0;
}
```

**Python:**
```python
import math

# Hàm kiểm tra số hoàn hảo tối ưu
def isPerfect(n):
    # Trường hợp đặc biệt
    if n <= 1:
        return False
    
    sum_divisors = 1  # Bao gồm ước 1
    
    # Duyệt từ 2 đến √n
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if i * i != n:
                # Thêm cả i và n/i
                sum_divisors += i + n // i
            else:
                # Trường hợp i = √n, chỉ thêm i
                sum_divisors += i
    
    return sum_divisors == n

# Chương trình chính
if __name__ == '__main__':
    n = int(input("Nhap so n: "))
    
    print(f"Kiem tra cac so tu 1 den {n}:")
    for i in range(1, n + 1):
        if isPerfect(i):
            print(f"{i} la so hoan hao")
```

#### 3.2.4. Độ phức tạp
- **Thời gian**: O(√n)
- **Không gian**: O(1)

## 4. NHỮNG ĐIỀU THÚ VỊ VỀ SỐ HOÀN HẢO

### 4.1. Các số hoàn hảo đã biết
```
Số hoàn hảo đầu tiên: 6 = 2¹ × (2² - 1) = 2 × 3
Số hoàn hảo thứ hai:  28 = 2² × (2³ - 1) = 4 × 7  
Số hoàn hảo thứ ba:   496 = 2⁴ × (2⁵ - 1) = 16 × 31
Số hoàn hảo thứ tư:   8128 = 2⁶ × (2⁷ - 1) = 64 × 127
```

### 4.2. Định lý Euclid về số hoàn hảo chẵn
Mọi số hoàn hảo chẵn đều có dạng: **2^(p-1) × (2^p - 1)**
Trong đó (2^p - 1) là một số nguyên tố (gọi là số nguyên tố Mersenne).

### 4.3. Bí ẩn về số hoàn hảo lẻ
Đến nay, chưa có số hoàn hảo lẻ nào được tìm thấy, và vẫn chưa có ai chứng minh được chúng có tồn tại hay không.

## 5. BÀI TẬP THỰC HÀNH

### Bài tập 1 (Cơ bản)
Viết chương trình kiểm tra một số n có phải là số hoàn hảo hay không.

### Bài tập 2 (Nâng cao) 
Tìm tất cả các số hoàn hảo từ 1 đến N (N ≤ 10000).

### Bài tập 3 (Ứng dụng)
Viết chương trình tìm tất cả các ước số của một số n và tính tổng chúng.

### Bài tập 4 (Thử thách)
Tối ưu hóa thuật toán để có thể kiểm tra các số hoàn hảo lớn (N ≤ 10^8).

## 6. GỢI Ý GIẢI BÀI TẬP

### Bài tập 1:
- Sử dụng phương pháp cơ bản hoặc tối ưu
- Chú ý xử lý trường hợp n ≤ 1

### Bài tập 2:
- Sử dụng vòng lặp kết hợp với hàm isPerfect()
- Có thể tối ưu bằng cách chỉ kiểm tra các số chẵn (vì tất cả số hoàn hảo đã biết đều chẵn)

### Bài tập 3:
- Tách riêng hàm tìm ước số và hàm tính tổng
- Có thể trả về danh sách các ước số

### Bài tập 4:
- Sử dụng thuật toán O(√n)
- Có thể áp dụng kỹ thuật song song xử lý (parallel processing)
- Sử dụng kiểu dữ liệu long long cho các số lớn
