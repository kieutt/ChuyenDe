# CHUYÊN ĐỀ: TÌM SỐ FIBONACCI THỨ N
## (Nth Fibonacci Number)
### Dành cho học sinh lớp 10 Chuyên Tin

---

## 1. ĐỊNH NGHĨA VÀ KHÁI NIỆM CƠ BẢN

### 1.1. Dãy số Fibonacci
**Dãy số Fibonacci** là một dãy số trong đó mỗi số (sau hai số đầu) là tổng của hai số liền trước nó.

### 1.2. Công thức toán học
```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)  với n ≥ 2
```

### 1.3. Dãy số Fibonacci đầu tiên
```
F(0) = 0
F(1) = 1
F(2) = 1
F(3) = 2
F(4) = 3
F(5) = 5
F(6) = 8
F(7) = 13
F(8) = 21
F(9) = 34
F(10) = 55
```

### 1.4. Minh họa bằng sơ đồ cây

```
                F(5) = 5
              /          \
         F(4) = 3       F(3) = 2
        /       \        /       \
    F(3) = 2  F(2) = 1  F(2) = 1  F(1) = 1
   /      \     /    \
F(2) = 1 F(1) = 1  F(1) = 1  F(0) = 0
/     \
F(1) = 1  F(0) = 0

Quan sát: Nhiều phép tính bị lặp lại!
```

## 2. CÁC VÍ DỤ MINH HỌA

### Ví dụ 1: Tìm F(2)
- **Input**: n = 2
- **Output**: 1
- **Giải thích**: F(2) = F(1) + F(0) = 1 + 0 = 1

### Ví dụ 2: Tìm F(5)
- **Input**: n = 5
- **Output**: 5
- **Giải thích**: F(5) = F(4) + F(3) = 3 + 2 = 5

### Ví dụ 3: Tìm F(10)
- **Input**: n = 10
- **Output**: 55
- **Giải thích**: Theo dãy số đã tính ở trên

## 3. PHƯƠNG PHÁP 1: ĐỆ QUY ĐƠN GIẢN (NAIVE RECURSION)

### 3.1. Ý tưởng thuật toán
Áp dụng trực tiếp công thức toán học bằng đệ quy.

### 3.2. Sơ đồ thuật toán

```
┌─────────────────┐
│   Bắt đầu       │
└─────┬───────────┘
      │
┌─────▼───────────┐
│   Nhập n        │
└─────┬───────────┘
      │
┌─────▼───────────┐
│   n <= 1?       │
└─────┬───────────┘
      │ Yes
┌─────▼───────────┐      ┌─────────────────┐
│  Trả về n       │      │       No        │
└─────────────────┘      └─────┬───────────┘
                               │
                     ┌─────────▼─────────┐
                     │ Trả về F(n-1) +   │
                     │       F(n-2)      │
                     └───────────────────┘
```

### 3.3. Code mẫu đệ quy đơn giản

**C++:**
```cpp
#include <iostream>
#include <chrono>
using namespace std;
using namespace chrono;

// Hàm tính Fibonacci bằng đệ quy đơn giản
int fibonacciRecursive(int n) {
    // Trường hợp cơ sở
    if (n <= 1) {
        return n;
    }
    
    // Trường hợp đệ quy
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}

int main() {
    int n;
    cout << "Nhap n: ";
    cin >> n;
    
    auto start = high_resolution_clock::now();
    int result = fibonacciRecursive(n);
    auto end = high_resolution_clock::now();
    
    auto duration = duration_cast<milliseconds>(end - start);
    
    cout << "F(" << n << ") = " << result << endl;
    cout << "Thoi gian thuc hien: " << duration.count() << " ms" << endl;
    
    return 0;
}
```

**Python:**
```python
import time

def fibonacci_recursive(n):
    """Tính số Fibonacci thứ n bằng đệ quy đơn giản"""
    # Trường hợp cơ sở
    if n <= 1:
        return n
    
    # Trường hợp đệ quy
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

def main():
    n = int(input("Nhập n: "))
    
    start_time = time.time()
    result = fibonacci_recursive(n)
    end_time = time.time()
    
    print(f"F({n}) = {result}")
    print(f"Thời gian thực hiện: {(end_time - start_time):.3f} giây")

if __name__ == "__main__":
    main()
```

### 3.4. Phân tích độ phức tạp
- **Thời gian**: O(2^n) - tăng trưởng hàm mũ
- **Không gian**: O(n) - độ sâu stack đệ quy

### 3.5. Nhược điểm
- **Cực kỳ chậm** với n lớn
- **Tính toán lặp lại** rất nhiều lần
- **Không khả thi** với n > 40

## 4. PHƯƠNG PHÁP 2: ĐỆ QUY CÓ GHI NHỚ (MEMOIZATION)

### 4.1. Ý tưởng cải tiến
Lưu trữ kết quả đã tính để tránh tính lại nhiều lần.

### 4.2. Minh họa bộ nhớ cache

```
Tính F(5) với memoization:

Bước 1: memo = [-1, -1, -1, -1, -1, -1]
Bước 2: Tính F(0) = 0 → memo = [0, -1, -1, -1, -1, -1]
Bước 3: Tính F(1) = 1 → memo = [0, 1, -1, -1, -1, -1]
Bước 4: Tính F(2) = 1 → memo = [0, 1, 1, -1, -1, -1]
Bước 5: Tính F(3) = 2 → memo = [0, 1, 1, 2, -1, -1]
Bước 6: Tính F(4) = 3 → memo = [0, 1, 1, 2, 3, -1]
Bước 7: Tính F(5) = 5 → memo = [0, 1, 1, 2, 3, 5]

Mỗi F(i) chỉ tính 1 lần!
```

### 4.3. Code mẫu với memoization

**C++:**
```cpp
#include <iostream>
#include <vector>
#include <chrono>
using namespace std;
using namespace chrono;

// Hàm phụ trợ với memoization
int fibonacciMemoUtil(int n, vector<int>& memo) {
    // Trường hợp cơ sở
    if (n <= 1) {
        return n;
    }
    
    // Kiểm tra đã tính trước đó chưa
    if (memo[n] != -1) {
        return memo[n];
    }
    
    // Tính và lưu vào memo
    memo[n] = fibonacciMemoUtil(n - 1, memo) + fibonacciMemoUtil(n - 2, memo);
    return memo[n];
}

// Hàm wrapper
int fibonacciMemo(int n) {
    vector<int> memo(n + 1, -1); // Khởi tạo với -1
    return fibonacciMemoUtil(n, memo);
}

int main() {
    int n;
    cout << "Nhap n: ";
    cin >> n;
    
    auto start = high_resolution_clock::now();
    int result = fibonacciMemo(n);
    auto end = high_resolution_clock::now();
    
    auto duration = duration_cast<microseconds>(end - start);
    
    cout << "F(" << n << ") = " << result << endl;
    cout << "Thoi gian thuc hien: " << duration.count() << " microseconds" << endl;
    
    return 0;
}
```

**Python:**
```python
import time

def fibonacci_memo_util(n, memo):
    """Hàm phụ trợ với memoization"""
    # Trường hợp cơ sở
    if n <= 1:
        return n
    
    # Kiểm tra đã tính trước đó chưa
    if memo[n] != -1:
        return memo[n]
    
    # Tính và lưu vào memo
    memo[n] = fibonacci_memo_util(n - 1, memo) + fibonacci_memo_util(n - 2, memo)
    return memo[n]

def fibonacci_memo(n):
    """Hàm wrapper với memoization"""
    memo = [-1] * (n + 1)  # Khởi tạo với -1
    return fibonacci_memo_util(n, memo)

def main():
    n = int(input("Nhập n: "))
    
    start_time = time.time()
    result = fibonacci_memo(n)
    end_time = time.time()
    
    print(f"F({n}) = {result}")
    print(f"Thời gian thực hiện: {(end_time - start_time) * 1000:.3f} ms")

if __name__ == "__main__":
    main()
```

### 4.4. Phân tích độ phức tạp
- **Thời gian**: O(n) - mỗi F(i) chỉ tính 1 lần
- **Không gian**: O(n) - bảng memo + stack đệ quy

## 5. PHƯƠNG PHÁP 3: QUY HOẠCH ĐỘNG (BOTTOM-UP)

### 5.1. Ý tưởng
Tính từ dưới lên, từ F(0), F(1) đến F(n) mà không dùng đệ quy.

### 5.2. Minh họa quá trình

```
Tính F(7) bằng bottom-up:

dp[0] = 0
dp[1] = 1

i = 2: dp[2] = dp[1] + dp[0] = 1 + 0 = 1
i = 3: dp[3] = dp[2] + dp[1] = 1 + 1 = 2
i = 4: dp[4] = dp[3] + dp[2] = 2 + 1 = 3
i = 5: dp[5] = dp[4] + dp[3] = 3 + 2 = 5
i = 6: dp[6] = dp[5] + dp[4] = 5 + 3 = 8
i = 7: dp[7] = dp[6] + dp[5] = 8 + 5 = 13

Kết quả: F(7) = 13
```

### 5.3. Code mẫu bottom-up

**C++:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

// Hàm tính Fibonacci bằng quy hoạch động
int fibonacciDP(int n) {
    if (n <= 1) {
        return n;
    }
    
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// Demo với in ra quá trình
void demonstrateDP(int n) {
    cout << "\n=== DEMO QUY HOACH DONG ===" << endl;
    
    if (n <= 1) {
        cout << "F(" << n << ") = " << n << endl;
        return;
    }
    
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    cout << "dp[0] = 0" << endl;
    cout << "dp[1] = 1" << endl;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
        cout << "dp[" << i << "] = dp[" << (i-1) << "] + dp[" << (i-2) 
             << "] = " << dp[i-1] << " + " << dp[i-2] << " = " << dp[i] << endl;
    }
    
    cout << "Ket qua: F(" << n << ") = " << dp[n] << endl;
}

int main() {
    int n;
    cout << "Nhap n: ";
    cin >> n;
    
    int result = fibonacciDP(n);
    cout << "F(" << n << ") = " << result << endl;
    
    // Demo quá trình tính toán
    if (n <= 10) {
        demonstrateDP(n);
    }
    
    return 0;
}
```

**Python:**
```python
def fibonacci_dp(n):
    """Tính Fibonacci bằng quy hoạch động"""
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]

def demonstrate_dp(n):
    """Demo quá trình quy hoạch động"""
    print("\n=== DEMO QUY HOẠCH ĐỘNG ===")
    
    if n <= 1:
        print(f"F({n}) = {n}")
        return
    
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1
    
    print("dp[0] = 0")
    print("dp[1] = 1")
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
        print(f"dp[{i}] = dp[{i-1}] + dp[{i-2}] = {dp[i-1]} + {dp[i-2]} = {dp[i]}")
    
    print(f"Kết quả: F({n}) = {dp[n]}")

def main():
    n = int(input("Nhập n: "))
    
    result = fibonacci_dp(n)
    print(f"F({n}) = {result}")
    
    # Demo quá trình tính toán
    if n <= 10:
        demonstrate_dp(n)

if __name__ == "__main__":
    main()
```

### 5.4. Phân tích độ phức tạp
- **Thời gian**: O(n) - vòng lặp từ 2 đến n
- **Không gian**: O(n) - mảng dp

## 6. PHƯƠNG PHÁP 4: TỐI ƯU HÓA KHÔNG GIAN

### 6.1. Ý tưởng
Chỉ cần lưu 2 số Fibonacci gần nhất thay vì toàn bộ mảng.

### 6.2. Minh họa quá trình

```
Tính F(6) với tối ưu không gian:

prev2 = 0, prev1 = 1

i = 2: curr = 0 + 1 = 1
       prev2 = 1, prev1 = 1

i = 3: curr = 1 + 1 = 2  
       prev2 = 1, prev1 = 2

i = 4: curr = 1 + 2 = 3
       prev2 = 2, prev1 = 3

i = 5: curr = 2 + 3 = 5
       prev2 = 3, prev1 = 5

i = 6: curr = 3 + 5 = 8
       prev2 = 5, prev1 = 8

Kết quả: F(6) = 8
```

### 6.3. Code mẫu tối ưu không gian

**C++:**
```cpp
#include <iostream>
using namespace std;

// Hàm tính Fibonacci tối ưu không gian
int fibonacciOptimized(int n) {
    if (n <= 1) {
        return n;
    }
    
    int prev2 = 0;  // F(i-2)
    int prev1 = 1;  // F(i-1)
    int curr = 0;   // F(i)
    
    for (int i = 2; i <= n; i++) {
        curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return curr;
}

// Demo với in ra quá trình
void demonstrateOptimized(int n) {
    cout << "\n=== DEMO TOI UU KHONG GIAN ===" << endl;
    
    if (n <= 1) {
        cout << "F(" << n << ") = " << n << endl;
        return;
    }
    
    int prev2 = 0;
    int prev1 = 1;
    int curr = 0;
    
    cout << "Ban dau: prev2 = 0, prev1 = 1" << endl;
    
    for (int i = 2; i <= n; i++) {
        curr = prev1 + prev2;
        cout << "i = " << i << ": curr = " << prev1 << " + " << prev2 << " = " << curr << endl;
        prev2 = prev1;
        prev1 = curr;
        cout << "        Cap nhat: prev2 = " << prev2 << ", prev1 = " << prev1 << endl;
    }
    
    cout << "Ket qua: F(" << n << ") = " << curr << endl;
}

int main() {
    int n;
    cout << "Nhap n: ";
    cin >> n;
    
    int result = fibonacciOptimized(n);
    cout << "F(" << n << ") = " << result << endl;
    
    // Demo quá trình tính toán
    if (n <= 8) {
        demonstrateOptimized(n);
    }
    
    return 0;
}
```

**Python:**
```python
def fibonacci_optimized(n):
    """Tính Fibonacci tối ưu không gian"""
    if n <= 1:
        return n
    
    prev2 = 0  # F(i-2)
    prev1 = 1  # F(i-1)
    curr = 0   # F(i)
    
    for i in range(2, n + 1):
        curr = prev1 + prev2
        prev2 = prev1
        prev1 = curr
    
    return curr

def demonstrate_optimized(n):
    """Demo quá trình tối ưu không gian"""
    print("\n=== DEMO TỐI ƯU KHÔNG GIAN ===")
    
    if n <= 1:
        print(f"F({n}) = {n}")
        return
    
    prev2 = 0
    prev1 = 1
    curr = 0
    
    print("Ban đầu: prev2 = 0, prev1 = 1")
    
    for i in range(2, n + 1):
        curr = prev1 + prev2
        print(f"i = {i}: curr = {prev1} + {prev2} = {curr}")
        prev2 = prev1
        prev1 = curr
        print(f"        Cập nhật: prev2 = {prev2}, prev1 = {prev1}")
    
    print(f"Kết quả: F({n}) = {curr}")

def main():
    n = int(input("Nhập n: "))
    
    result = fibonacci_optimized(n)
    print(f"F({n}) = {result}")
    
    # Demo quá trình tính toán
    if n <= 8:
        demonstrate_optimized(n)

if __name__ == "__main__":
    main()
```

### 6.4. Phân tích độ phức tạp
- **Thời gian**: O(n)
- **Không gian**: O(1) - chỉ dùng 3 biến

## 7. PHƯƠNG PHÁP 5: LŨY THỪA MA TRẬN (MATRIX EXPONENTIATION)

### 7.1. Ý tưởng nâng cao
Sử dụng ma trận để biểu diễn mối quan hệ Fibonacci và áp dụng lũy thừa nhanh.

### 7.2. Ma trận biến đổi

```
Ma trận Fibonacci:
[1 1]^n = [F(n+1) F(n)  ]
[1 0]     [F(n)   F(n-1)]

Ví dụ:
[1 1]^5 = [8 5] = [F(6) F(5)]
[1 0]     [5 3]   [F(5) F(4)]
```

### 7.3. Code mẫu ma trận (nâng cao)

**C++:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

// Hàm nhân hai ma trận 2x2
void multiplyMatrix(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {
    int x = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0];
    int y = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1];
    int z = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0];
    int w = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1];
    
    mat1[0][0] = x;
    mat1[0][1] = y;
    mat1[1][0] = z;
    mat1[1][1] = w;
}

// Hàm lũy thừa ma trận
void matrixPower(vector<vector<int>>& mat, int n) {
    if (n == 0 || n == 1) return;
    
    vector<vector<int>> baseMatrix = {{1, 1}, {1, 0}};
    
    matrixPower(mat, n / 2);
    multiplyMatrix(mat, mat);
    
    if (n % 2 != 0) {
        multiplyMatrix(mat, baseMatrix);
    }
}

// Hàm tính Fibonacci bằng ma trận
int fibonacciMatrix(int n) {
    if (n <= 1) return n;
    
    vector<vector<int>> mat = {{1, 1}, {1, 0}};
    matrixPower(mat, n - 1);
    
    return mat[0][0];
}

int main() {
    int n;
    cout << "Nhap n: ";
    cin >> n;
    
    int result = fibonacciMatrix(n);
    cout << "F(" << n << ") = " << result << " (Matrix method)" << endl;
    
    return 0;
}
```

### 7.4. Phân tích độ phức tạp
- **Thời gian**: O(log n) - lũy thừa nhanh
- **Không gian**: O(log n) - stack đệ quy

## 8. SO SÁNH CÁC PHƯƠNG PHÁP

| Phương pháp | Thời gian | Không gian | Ưu điểm | Nhược điểm |
|------------|-----------|------------|---------|------------|
| **Đệ quy đơn giản** | O(2^n) | O(n) | Đơn giản, dễ hiểu | Cực chậm với n lớn |
| **Memoization** | O(n) | O(n) | Nhanh, tự nhiên | Dùng nhiều bộ nhớ |
| **Bottom-up DP** | O(n) | O(n) | Nhanh, không đệ quy | Dùng nhiều bộ nhớ |
| **Tối ưu không gian** | O(n) | O(1) | Nhanh, ít bộ nhớ | Code hơi phức tạp |
| **Ma trận** | O(log n) | O(log n) | Cực nhanh | Khó hiểu, khó cài đặt |

## 9. CHƯƠNG TRÌNH DEMO TỔNG HỢP

**C++:**
```cpp
#include <iostream>
#include <chrono>
#include <vector>
using namespace std;
using namespace chrono;

class FibonacciCalculator {
public:
    // Method 1: Recursion
    static int recursive(int n) {
        if (n <= 1) return n;
        return recursive(n - 1) + recursive(n - 2);
    }
    
    // Method 2: Memoization
    static int memoization(int n) {
        vector<int> memo(n + 1, -1);
        return memoUtil(n, memo);
    }
    
    // Method 3: Bottom-up DP
    static int bottomUp(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
    
    // Method 4: Space optimized
    static int spaceOptimized(int n) {
        if (n <= 1) return n;
        int prev2 = 0, prev1 = 1, curr = 0;
        for (int i = 2; i <= n; i++) {
            curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return curr;
    }

private:
    static int memoUtil(int n, vector<int>& memo) {
        if (n <= 1) return n;
        if (memo[n] != -1) return memo[n];
        memo[n] = memoUtil(n-1, memo) + memoUtil(n-2, memo);
        return memo[n];
    }
};

void compareAll(int n) {
    cout << "\n=== SO SANH TAT CA PHUONG PHAP CHO F(" << n << ") ===" << endl;
    
    // Method 1: Recursion (chỉ với n nhỏ)
    if (n <= 35) {
        auto start = high_resolution_clock::now();
        int result1 = FibonacciCalculator::recursive(n);
        auto end = high_resolution_clock::now();
        auto time1 = duration_cast<microseconds>(end - start);
        cout << "Recursion:        " << result1 << " (" << time1.count() << " μs)" << endl;
    }
    
    // Method 2: Memoization
    auto start = high_resolution_clock::now();
    int result2 = FibonacciCalculator::memoization(n);
    auto end = high_resolution_clock::now();
    auto time2 = duration_cast<microseconds>(end - start);
    cout << "Memoization:      " << result2 << " (" << time2.count() << " μs)" << endl;
    
    // Method 3: Bottom-up
    start = high_resolution_clock::now();
    int result3 = FibonacciCalculator::bottomUp(n);
    end = high_resolution_clock::now();
    auto time3 = duration_cast<microseconds>(end - start);
    cout << "Bottom-up DP:     " << result3 << " (" << time3.count() << " μs)" << endl;
    
    // Method 4: Space optimized
    start = high_resolution_clock::now();
    int result4 = FibonacciCalculator::spaceOptimized(n);
    end = high_resolution_clock::now();
    auto time4 = duration_cast<microseconds>(end - start);
    cout << "Space Optimized:  " << result4 << " (" << time4.count() << " μs)" << endl;
}

int main() {
    int n;
    cout << "Nhap n: ";
    cin >> n;
    
    // So sánh các phương pháp
    compareAll(n);
    
    // Hiển thị dãy Fibonacci đầu tiên
    cout << "\n=== DAY SO FIBONACCI DAU TIEN ===" << endl;
    cout << "F(0) = 0" << endl;
    for (int i = 1; i <= min(n, 15); i++) {
        cout << "F(" << i << ") = " << FibonacciCalculator::spaceOptimized(i) << endl;
    }
    
    return 0;
}
```

**Python:**
```python
import time

class FibonacciCalculator:
    @staticmethod
    def recursive(n):
        """Phương pháp đệ quy đơn giản"""
        if n <= 1:
            return n
        return FibonacciCalculator.recursive(n - 1) + FibonacciCalculator.recursive(n - 2)
    
    @staticmethod
    def memoization(n):
        """Phương pháp memoization"""
        memo = [-1] * (n + 1)
        return FibonacciCalculator._memo_util(n, memo)
    
    @staticmethod
    def _memo_util(n, memo):
        if n <= 1:
            return n
        if memo[n] != -1:
            return memo[n]
        memo[n] = FibonacciCalculator._memo_util(n-1, memo) + FibonacciCalculator._memo_util(n-2, memo)
        return memo[n]
    
    @staticmethod
    def bottom_up(n):
        """Phương pháp quy hoạch động bottom-up"""
        if n <= 1:
            return n
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
    
    @staticmethod
    def space_optimized(n):
        """Phương pháp tối ưu không gian"""
        if n <= 1:
            return n
        prev2, prev1, curr = 0, 1, 0
        for i in range(2, n + 1):
            curr = prev1 + prev2
            prev2 = prev1
            prev1 = curr
        return curr

def compare_all(n):
    """So sánh tất cả các phương pháp"""
    print(f"\n=== SO SÁNH TẤT CẢ PHƯƠNG PHÁP CHO F({n}) ===")
    
    # Method 1: Recursion (chỉ với n nhỏ)
    if n <= 35:
        start_time = time.time()
        result1 = FibonacciCalculator.recursive(n)
        end_time = time.time()
        time1 = (end_time - start_time) * 1000
        print(f"Recursion:        {result1} ({time1:.3f} ms)")
    
    # Method 2: Memoization
    start_time = time.time()
    result2 = FibonacciCalculator.memoization(n)
    end_time = time.time()
    time2 = (end_time - start_time) * 1000
    print(f"Memoization:      {result2} ({time2:.3f} ms)")
    
    # Method 3: Bottom-up
    start_time = time.time()
    result3 = FibonacciCalculator.bottom_up(n)
    end_time = time.time()
    time3 = (end_time - start_time) * 1000
    print(f"Bottom-up DP:     {result3} ({time3:.3f} ms)")
    
    # Method 4: Space optimized
    start_time = time.time()
    result4 = FibonacciCalculator.space_optimized(n)
    end_time = time.time()
    time4 = (end_time - start_time) * 1000
    print(f"Space Optimized:  {result4} ({time4:.3f} ms)")

def main():
    n = int(input("Nhập n: "))
    
    # So sánh các phương pháp
    compare_all(n)
    
    # Hiển thị dãy Fibonacci đầu tiên
    print("\n=== DÃY SỐ FIBONACCI ĐẦU TIÊN ===")
    print("F(0) = 0")
    for i in range(1, min(n + 1, 16)):
        print(f"F({i}) = {FibonacciCalculator.space_optimized(i)}")

if __name__ == "__main__":
    main()
```

## 10. BÀI TẬP THỰC HÀNH

### Bài tập 1 (Cơ bản)
Viết chương trình tính số Fibonacci thứ n bằng cả 4 phương pháp và so sánh hiệu suất.

### Bài tập 2 (Nâng cao) 
In ra tất cả các số Fibonacci từ F(0) đến F(n).

### Bài tập 3 (Ứng dụng)
Tìm số Fibonacci đầu tiên có k chữ số.

### Bài tập 4 (Thử thách)
Kiểm tra một số có phải là số Fibonacci hay không.

### Bài tập 5 (Tư duy)
Tính tổng của n số Fibonacci đầu tiên.

## 11. GỢI Ý GIẢI BÀI TẬP

### Bài tập 1:
```cpp
// Sử dụng class FibonacciCalculator đã viết
// Đo thời gian bằng chrono
// So sánh với các input khác nhau
```

### Bài tập 2:
```python
def print_fibonacci_sequence(n):
    print("Dãy Fibonacci:")
    for i in range(n + 1):
        print(f"F({i}) = {fibonacci_optimized(i)}")
```

### Bài tập 3:
```cpp
int findFirstFibonacciWithKDigits(int k) {
    int n = 0;
    while (true) {
        int fib = fibonacciOptimized(n);
        if (countDigits(fib) == k) {
            return fib;
        }
        n++;
    }
}
```

### Bài tập 4:
```python
def is_fibonacci(num):
    # Một số là Fibonacci nếu một hoặc cả hai số
    # (5*n*n + 4) hoặc (5*n*n - 4) là số chính phương
    return is_perfect_square(5*num*num + 4) or is_perfect_square(5*num*num - 4)
```

### Bài tập 5:
```cpp
// Công thức: Sum = F(n+2) - 1
int sumOfNFibonacci(int n) {
    return fibonacciOptimized(n + 2) - 1;
}
```

## 12. ỨNG DỤNG THỰC TẾ

### 12.1. Trong tự nhiên
- **Cánh hoa hướng dương**: Số xoắn ốc thuận và nghịch
- **Lá cây**: Sự sắp xếp theo tỷ lệ vàng
- **Hình xoắn ốc**: Ốc sên, lốc xoáy

### 12.2. Trong khoa học máy tính
- **Thuật toán tìm kiếm**: Fibonacci Search
- **Cấu trúc dữ liệu**: Fibonacci Heap
- **Phân tích thuật toán**: Độ phức tạp worst-case

### 12.3. Trong toán học và vật lý
- **Tỷ lệ vàng**: φ = (1 + √5) / 2 ≈ 1.618
- **Dãy Lucas**: Tương tự Fibonacci nhưng bắt đầu từ 2, 1
- **Lý thuyết số**: Nghiên cứu tính chất số học

## 13. NHỮNG ĐIỀU THÚ VỊ VỀ FIBONACCI

### 13.1. Tính chất toán học
```
F(n+m) = F(n) × F(m+1) + F(n-1) × F(m)
F(2n) = F(n) × (2F(n+1) - F(n))
GCD(F(m), F(n)) = F(GCD(m, n))
```

### 13.2. Chu kỳ lặp lại
- Fibonacci modulo m có chu kỳ lặp lại (Pisano period)
- F(n) mod 10 lặp lại sau 60 số
- F(n) mod 100 lặp lại sau 300 số

### 13.3. Mối quan hệ với tỷ lệ vàng
```
Lim (F(n+1) / F(n)) = φ khi n → ∞
      n→∞

φ = (1 + √5) / 2 ≈ 1.6180339887...
```

---
