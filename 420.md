# AtCoder Beginner Contest 420 - ƒê·ªÅ thi l·∫≠p tr√¨nh thi ƒë·∫•u

## T·ªïng quan

AtCoder Beginner Contest 420 l√† m·ªôt cu·ªôc thi l·∫≠p tr√¨nh thi ƒë·∫•u d√†nh cho ng∆∞·ªùi m·ªõi b·∫Øt ƒë·∫ßu, bao g·ªìm 7 b√†i to√°n t·ª´ m·ª©c ƒë·ªô c∆° b·∫£n ƒë·∫øn n√¢ng cao. Cu·ªôc thi n√†y gi√∫p h·ªçc sinh r√®n luy·ªán k·ªπ nƒÉng gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ, t∆∞ duy thu·∫≠t to√°n v√† k·ªπ nƒÉng l·∫≠p tr√¨nh.

### Th√¥ng tin chung:
- **Th·ªùi gian**: 100 ph√∫t
- **S·ªë b√†i**: 7 b√†i (A-G)
- **ƒêi·ªÉm t·ªëi ƒëa**: 2375 ƒëi·ªÉm
- **Ng√¥n ng·ªØ**: C++, Python v√† c√°c ng√¥n ng·ªØ kh√°c ƒë∆∞·ª£c h·ªó tr·ª£

### Ph√¢n ph·ªëi ƒëi·ªÉm s·ªë:
- B√†i A: 100 ƒëi·ªÉm (ƒê·ªô kh√≥: ‚òÖ‚òÜ‚òÜ‚òÜ‚òÜ)
- B√†i B: 200 ƒëi·ªÉm (ƒê·ªô kh√≥: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ)  
- B√†i C: 300 ƒëi·ªÉm (ƒê·ªô kh√≥: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ)
- B√†i D: 400 ƒëi·ªÉm (ƒê·ªô kh√≥: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ)
- B√†i E: 450 ƒëi·ªÉm (ƒê·ªô kh√≥: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ)
- B√†i F: 550 ƒëi·ªÉm (ƒê·ªô kh√≥: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ)
- B√†i G: 575 ƒëi·ªÉm (ƒê·ªô kh√≥: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ)

### Chi·∫øn l∆∞·ª£c l√†m b√†i:
1. **B√†i A-C**: D√†nh 15-20 ph√∫t ƒë·∫ßu ƒë·ªÉ gi·∫£i nhanh c√°c b√†i d·ªÖ
2. **B√†i D-E**: T·∫≠p trung ph√¢n t√≠ch k·ªπ thu·∫≠t v√† thu·∫≠t to√°n
3. **B√†i F-G**: D√†nh th·ªùi gian c√≤n l·∫°i cho c√°c b√†i kh√≥

---

## M·ª•c l·ª•c

### **Ph·∫ßn 1**: T·ªïng quan v√† M·ª•c l·ª•c

### **Ph·∫ßn 2**: B√†i A - What month is it?
- ƒê·ªÅ b√†i ti·∫øng Vi·ªát
- H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n
- Gi·∫£i thu·∫≠t v√† ƒë·ªô ph·ª©c t·∫°p
- Code tham kh·∫£o (C++ & Python)
- Test case v√† ch·∫•m ƒëi·ªÉm

### **Ph·∫ßn 3**: B√†i B - Most Minority  
- ƒê·ªÅ b√†i ti·∫øng Vi·ªát
- H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n
- Gi·∫£i thu·∫≠t v√† ƒë·ªô ph·ª©c t·∫°p
- Code tham kh·∫£o (C++ & Python)
- Test case v√† ch·∫•m ƒëi·ªÉm

### **Ph·∫ßn 4**: B√†i C - Sum of Min Query
- ƒê·ªÅ b√†i ti·∫øng Vi·ªát
- H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n
- Gi·∫£i thu·∫≠t v√† ƒë·ªô ph·ª©c t·∫°p
- Code tham kh·∫£o (C++ & Python)
- Test case v√† ch·∫•m ƒëi·ªÉm

### **Ph·∫ßn 5**: B√†i D - Toggle Maze
- ƒê·ªÅ b√†i ti·∫øng Vi·ªát
- H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n
- Gi·∫£i thu·∫≠t v√† ƒë·ªô ph·ª©c t·∫°p
- Code tham kh·∫£o (C++ & Python)
- Test case v√† ch·∫•m ƒëi·ªÉm

### **Ph·∫ßn 6**: B√†i E - Reachability Query
- ƒê·ªÅ b√†i ti·∫øng Vi·ªát
- H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n
- Gi·∫£i thu·∫≠t v√† ƒë·ªô ph·ª©c t·∫°p
- Code tham kh·∫£o (C++ & Python)
- Test case v√† ch·∫•m ƒëi·ªÉm

### **Ph·∫ßn 7**: B√†i F - kirinuki
- ƒê·ªÅ b√†i ti·∫øng Vi·ªát
- H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n
- Gi·∫£i thu·∫≠t v√† ƒë·ªô ph·ª©c t·∫°p
- Code tham kh·∫£o (C++ & Python)
- Test case v√† ch·∫•m ƒëi·ªÉm

### **Ph·∫ßn 8**: B√†i G - sqrt(n¬≤+n+X)
- ƒê·ªÅ b√†i ti·∫øng Vi·ªát
- H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n
- Gi·∫£i thu·∫≠t v√† ƒë·ªô ph·ª©c t·∫°p
- Code tham kh·∫£o (C++ & Python)
- Test case v√† ch·∫•m ƒëi·ªÉm

### **Ph·∫ßn 9**: T·ªïng k·∫øt v√† L·ªùi khuy√™n
- Nh·∫≠n x√©t v·ªÅ t·ª´ng b√†i
- K·ªπ thu·∫≠t th∆∞·ªùng g·∫∑p
- L·ªùi khuy√™n cho h·ªçc sinh
- T√†i li·ªáu tham kh·∫£o th√™m

---

## H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng t√†i li·ªáu

### C√°ch ƒë·ªçc hi·ªáu qu·∫£:
1. **ƒê·ªçc ƒë·ªÅ b√†i**: Hi·ªÉu r√µ y√™u c·∫ßu v√† r√†ng bu·ªôc
2. **T·ª± suy nghƒ©**: D√†nh 5-10 ph√∫t t·ª± t√¨m c√°ch gi·∫£i
3. **ƒê·ªçc h∆∞·ªõng d·∫´n**: So s√°nh v·ªõi c√°ch ti·∫øp c·∫≠n g·ª£i √Ω
4. **Nghi√™n c·ª©u code**: Hi·ªÉu t·ª´ng d√≤ng code v√† logic
5. **T·ª± implement**: Vi·∫øt l·∫°i code theo c√°ch hi·ªÉu c·ªßa m√¨nh
6. **Test th·ª≠**: Ch·∫°y v·ªõi c√°c test case m·∫´u

### K√Ω hi·ªáu trong t√†i li·ªáu:
- `$...$`: Bi·ªÉu th·ª©c to√°n h·ªçc, bi·∫øn s·ªë
- **Bold**: Thu·∫≠t ng·ªØ quan tr·ªçng
- `code`: ƒêo·∫°n code ho·∫∑c t√™n bi·∫øn
- üí°: G·ª£i √Ω quan tr·ªçng
- ‚ö†Ô∏è: L∆∞u √Ω c·∫ßn ch√∫ √Ω
- üîç: Ph√¢n t√≠ch chi ti·∫øt

### C·∫•u tr√∫c m·ªói b√†i:
1. **ƒê·ªÅ b√†i**: B·∫£n d·ªãch ti·∫øng Vi·ªát ƒë·∫ßy ƒë·ªß
2. **Ph√¢n t√≠ch**: Hi·ªÉu b√†i to√°n v√† x√°c ƒë·ªãnh d·ªØ li·ªáu v√†o/ra
3. **√ù t∆∞·ªüng**: C√°c c√°ch ti·∫øp c·∫≠n t·ª´ ƒë∆°n gi·∫£n ƒë·∫øn t·ªëi ∆∞u
4. **Thu·∫≠t to√°n**: M√¥ t·∫£ chi ti·∫øt thu·∫≠t to√°n
5. **ƒê·ªô ph·ª©c t·∫°p**: Ph√¢n t√≠ch th·ªùi gian v√† b·ªô nh·ªõ
6. **Implementation**: Code m·∫´u v·ªõi comment chi ti·∫øt
7. **Test cases**: B·ªô test ƒë·∫ßy ƒë·ªß v·ªõi subtask

---

*T√†i li·ªáu ƒë∆∞·ª£c bi√™n so·∫°n b·ªüi gi√°o vi√™n c√≥ 20 nƒÉm kinh nghi·ªám gi·∫£ng d·∫°y l·∫≠p tr√¨nh thi ƒë·∫•u*
# B√†i A: What month is it? (Th√°ng n√†o?)

## ƒê·ªÅ b√†i

**ƒêi·ªÉm s·ªë**: 100 ƒëi·ªÉm  
**Th·ªùi gian**: 2 gi√¢y  
**B·ªô nh·ªõ**: 1024 MiB

### M√¥ t·∫£ b√†i to√°n
Cho hai s·ªë nguy√™n $X$ v√† $Y$ v·ªõi $1 \leq X, Y \leq 12$.

H√£y t√¨m xem $Y$ th√°ng sau th√°ng $X$ l√† th√°ng m·∫•y.

### D·ªØ li·ªáu v√†o
```
X Y
```

### D·ªØ li·ªáu ra
In ra m·ªôt s·ªë nguy√™n l√† ƒë√°p √°n.

### V√≠ d·ª•

**V√≠ d·ª• 1:**
```
V√†o: 5 9
Ra: 2
```
*Gi·∫£i th√≠ch: 9 th√°ng sau th√°ng 5 l√† th√°ng 2.*

**V√≠ d·ª• 2:**
```
V√†o: 1 1  
Ra: 2
```

**V√≠ d·ª• 3:**
```
V√†o: 12 12
Ra: 12
```

---

## H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n b√†i to√°n

### B∆∞·ªõc 1: Hi·ªÉu b√†i to√°n
üí° **Ph√¢n t√≠ch**: ƒê√¢y l√† b√†i to√°n v·ªÅ ph√©p to√°n modular v·ªõi chu k·ª≥ 12 th√°ng.

- Th√°ng $X$ + $Y$ th√°ng = Th√°ng n√†o?
- L∆∞u √Ω: N·∫øu v∆∞·ª£t qu√° th√°ng 12 th√¨ quay l·∫°i t·ª´ th√°ng 1

### B∆∞·ªõc 2: X√°c ƒë·ªãnh c√¥ng th·ª©c
G·ªçi k·∫øt qu·∫£ l√† $result$:
- $result = (X + Y - 1) \bmod 12 + 1$

**Gi·∫£i th√≠ch c√¥ng th·ª©c:**
1. $X + Y$: T·ªïng tr·ª±c ti·∫øp
2. $-1$: Chuy·ªÉn t·ª´ h·ªá 1-indexed sang 0-indexed  
3. $\bmod 12$: L·∫•y ph·∫ßn d∆∞ ƒë·ªÉ x·ª≠ l√Ω chu k·ª≥
4. $+1$: Chuy·ªÉn l·∫°i v·ªÅ 1-indexed

### B∆∞·ªõc 3: Ki·ªÉm tra c√°c tr∆∞·ªùng h·ª£p
- **Tr∆∞·ªùng h·ª£p 1**: $X + Y \leq 12$ ‚Üí K·∫øt qu·∫£ = $X + Y$
- **Tr∆∞·ªùng h·ª£p 2**: $X + Y > 12$ ‚Üí C·∫ßn d√πng modular

---

## Gi·∫£i thu·∫≠t v√† ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

### Thu·∫≠t to√°n
```
1. ƒê·ªçc X, Y
2. T√≠nh result = (X + Y - 1) % 12 + 1
3. In result
```

### ƒê·ªô ph·ª©c t·∫°p
- **Th·ªùi gian**: $O(1)$ - Ch·ªâ c√≥ ph√©p t√≠nh ƒë∆°n gi·∫£n
- **B·ªô nh·ªõ**: $O(1)$ - Ch·ªâ c·∫ßn l∆∞u v√†i bi·∫øn

---

## Code tham kh·∫£o

### C++
```cpp
#include <iostream>
using namespace std;

int main() {
    int X, Y;
    cin >> X >> Y;
    
    // Tinh thang sau Y thang ke tu thang X
    int result = (X + Y - 1) % 12 + 1;
    
    cout << result << endl;
    
    return 0;
}
```

### Python
```python
# Nhap du lieu
X, Y = map(int, input().split())

# Tinh thang sau Y thang ke tu thang X  
result = (X + Y - 1) % 12 + 1

# In ket qua
print(result)
```

---

## B·ªô test ch·∫•m ƒëi·ªÉm

### Test cases m·∫´u
```
Test 1: 5 9 ‚Üí 2
Test 2: 1 1 ‚Üí 2  
Test 3: 12 12 ‚Üí 12
Test 4: 6 6 ‚Üí 12
Test 5: 11 2 ‚Üí 1
```

### Subtask v√† ƒëi·ªÉm s·ªë

**Subtask 1** (20 ƒëi·ªÉm): $X + Y \leq 12$
- 8 test cases
- Kh√¥ng c·∫ßn x·ª≠ l√Ω modular

**Subtask 2** (80 ƒëi·ªÉm): Kh√¥ng r√†ng bu·ªôc th√™m  
- 32 test cases
- Bao g·ªìm tr∆∞·ªùng h·ª£p c·∫ßn modular

### Generator test t·ª± ƒë·ªông

#### C++
```cpp
#include <iostream>
#include <random>
#include <fstream>
using namespace std;

int main() {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dis(1, 12);
    
    // Tao 40 test cases
    for (int t = 1; t <= 40; t++) {
        ofstream input("input" + to_string(t) + ".txt");
        ofstream output("output" + to_string(t) + ".txt");
        
        int X = dis(gen);
        int Y = dis(gen);
        
        input << X << " " << Y << endl;
        
        int result = (X + Y - 1) % 12 + 1;
        output << result << endl;
        
        input.close();
        output.close();
    }
    
    return 0;
}
```

#### Python
```python
import random

# Tao 40 test cases
for t in range(1, 41):
    X = random.randint(1, 12)
    Y = random.randint(1, 12)
    
    with open(f"input{t}.txt", "w") as f:
        f.write(f"{X} {Y}\n")
    
    result = (X + Y - 1) % 12 + 1
    
    with open(f"output{t}.txt", "w") as f:
        f.write(f"{result}\n")
```

### Ch·∫•m ƒëi·ªÉm chi ti·∫øt
- **AC (Accepted)**: 100 ƒëi·ªÉm - Code ch√≠nh x√°c
- **WA (Wrong Answer)**: 0 ƒëi·ªÉm - Sai k·∫øt qu·∫£  
- **TLE (Time Limit)**: 0 ƒëi·ªÉm - Qu√° th·ªùi gian (kh√≥ x·∫£y ra v·ªõi b√†i n√†y)
- **RE (Runtime Error)**: 0 ƒëi·ªÉm - L·ªói runtime

---

## L∆∞u √Ω v√† m·∫πo

‚ö†Ô∏è **C√°c l·ªói th∆∞·ªùng g·∫∑p:**
1. Qu√™n x·ª≠ l√Ω modular khi $X + Y > 12$
2. Nh·∫ßm l·∫´n gi·ªØa 0-indexed v√† 1-indexed
3. Sai c√¥ng th·ª©c modular

üí° **M·∫πo l√†m b√†i:**
1. Ki·ªÉm tra k·ªπ c√¥ng th·ª©c v·ªõi c√°c v√≠ d·ª• m·∫´u
2. Xem x√©t tr∆∞·ªùng h·ª£p bi√™n: $X=12, Y=12$
3. B√†i n√†y r·∫•t ƒë∆°n gi·∫£n, n√™n t·∫≠p trung l√†m nhanh v√† ch√≠nh x√°c

üîç **Ki·∫øn th·ª©c li√™n quan:**
- Ph√©p to√°n modular
- Chuy·ªÉn ƒë·ªïi gi·ªØa 0-indexed v√† 1-indexed
- X·ª≠ l√Ω chu k·ª≥ trong b√†i to√°n

# B√†i B: Most Minority (Phe thi·ªÉu s·ªë)

## ƒê·ªÅ b√†i

**ƒêi·ªÉm s·ªë**: 200 ƒëi·ªÉm  
**Th·ªùi gian**: 2 gi√¢y  
**B·ªô nh·ªõ**: 1024 MiB

### M√¥ t·∫£ b√†i to√°n
C√≥ $N$ ng∆∞·ªùi (v·ªõi $N$ l·∫ª) th·ª±c hi·ªán $M$ l∆∞·ª£t b√¨nh ch·ªçn, m·ªói l∆∞·ª£t ch·ªçn $0$ ho·∫∑c $1$.

K·∫øt qu·∫£ b√¨nh ch·ªçn ƒë∆∞·ª£c cho b·ªüi $N$ x√¢u $S_1, S_2, \ldots, S_N$ ƒë·ªô d√†i $M$, trong ƒë√≥ k√Ω t·ª± th·ª© $j$ c·ªßa $S_i$ bi·ªÉu th·ªã l·ª±a ch·ªçn c·ªßa ng∆∞·ªùi $i$ trong l∆∞·ª£t b√¨nh ch·ªçn th·ª© $j$.

Trong m·ªói l∆∞·ª£t b√¨nh ch·ªçn, nh·ªØng ng∆∞·ªùi thu·ªôc phe thi·ªÉu s·ªë s·∫Ω nh·∫≠n ƒë∆∞·ª£c 1 ƒëi·ªÉm theo quy t·∫Øc:
- N·∫øu c√≥ $x$ ng∆∞·ªùi ch·ªçn $0$ v√† $y$ ng∆∞·ªùi ch·ªçn $1$:
  - N·∫øu $x = 0$ ho·∫∑c $y = 0$: T·∫•t c·∫£ nh·∫≠n 1 ƒëi·ªÉm
  - N·∫øu $x < y$: Ch·ªâ nh·ªØng ng∆∞·ªùi ch·ªçn $0$ nh·∫≠n 1 ƒëi·ªÉm
  - N·∫øu $x > y$: Ch·ªâ nh·ªØng ng∆∞·ªùi ch·ªçn $1$ nh·∫≠n 1 ƒëi·ªÉm
- L∆∞u √Ω: V√¨ $N$ l·∫ª n√™n $x \neq y$ (tr·ª´ tr∆∞·ªùng h·ª£p $x = 0$ ho·∫∑c $y = 0$)

H√£y t√¨m t·∫•t c·∫£ nh·ªØng ng∆∞·ªùi c√≥ t·ªïng ƒëi·ªÉm cao nh·∫•t.

### D·ªØ li·ªáu v√†o
```
N M
S_1
S_2
...
S_N
```

### D·ªØ li·ªáu ra
In ra s·ªë th·ª© t·ª± c·ªßa t·∫•t c·∫£ ng∆∞·ªùi c√≥ ƒëi·ªÉm cao nh·∫•t, theo th·ª© t·ª± tƒÉng d·∫ßn, c√°ch nhau b·ªüi d·∫•u c√°ch.

### V√≠ d·ª•

**V√≠ d·ª• 1:**
```
V√†o: 
3 5
11100
10101
01110

Ra: 2 3
```

**V√≠ d·ª• 2:**
```
V√†o:
5 4
0000
0000
0000
0000
0000

Ra: 1 2 3 4 5
```

---

## H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n b√†i to√°n

### B∆∞·ªõc 1: Hi·ªÉu b√†i to√°n
üí° **Ph√¢n t√≠ch**: C·∫ßn m√¥ ph·ªèng qu√° tr√¨nh b√¨nh ch·ªçn v√† t√≠nh ƒëi·ªÉm cho t·ª´ng ng∆∞·ªùi.

**C√°c th√†nh ph·∫ßn ch√≠nh:**
1. ƒê·ªçc k·∫øt qu·∫£ b√¨nh ch·ªçn c·ªßa $N$ ng∆∞·ªùi trong $M$ l∆∞·ª£t
2. V·ªõi m·ªói l∆∞·ª£t, x√°c ƒë·ªãnh phe thi·ªÉu s·ªë v√† trao ƒëi·ªÉm
3. T√¨m nh·ªØng ng∆∞·ªùi c√≥ t·ªïng ƒëi·ªÉm cao nh·∫•t

### B∆∞·ªõc 2: Ph√¢n t√≠ch t·ª´ng l∆∞·ª£t b√¨nh ch·ªçn
V·ªõi l∆∞·ª£t b√¨nh ch·ªçn th·ª© $j$:
1. ƒê·∫øm s·ªë ng∆∞·ªùi ch·ªçn $0$ ($x$) v√† s·ªë ng∆∞·ªùi ch·ªçn $1$ ($y$)
2. √Åp d·ª•ng quy t·∫Øc trao ƒëi·ªÉm
3. C·ªông ƒëi·ªÉm v√†o t·ªïng ƒëi·ªÉm c·ªßa t·ª´ng ng∆∞·ªùi

### B∆∞·ªõc 3: T√¨m ƒëi·ªÉm cao nh·∫•t
1. T√¨m ƒëi·ªÉm cao nh·∫•t trong t·∫•t c·∫£ ng∆∞·ªùi
2. Li·ªát k√™ t·∫•t c·∫£ ng∆∞·ªùi c√≥ ƒëi·ªÉm b·∫±ng ƒëi·ªÉm cao nh·∫•t

---

## Gi·∫£i thu·∫≠t v√† ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

### Thu·∫≠t to√°n
```
1. ƒê·ªçc N, M v√† N x√¢u S[1..N]
2. Kh·ªüi t·∫°o m·∫£ng ƒëi·ªÉm scores[1..N] = 0
3. V·ªõi m·ªói l∆∞·ª£t j t·ª´ 1 ƒë·∫øn M:
   a. ƒê·∫øm x = s·ªë ng∆∞·ªùi ch·ªçn 0, y = s·ªë ng∆∞·ªùi ch·ªçn 1
   b. X√°c ƒë·ªãnh ai ƒë∆∞·ª£c ƒëi·ªÉm theo quy t·∫Øc
   c. C·ªông 1 ƒëi·ªÉm cho nh·ªØng ng∆∞·ªùi ƒë∆∞·ª£c ch·ªçn
4. T√¨m max_score = max(scores[1..N])
5. In t·∫•t c·∫£ i sao cho scores[i] = max_score
```

### ƒê·ªô ph·ª©c t·∫°p
- **Th·ªùi gian**: $O(N \times M)$ - Duy·ªát qua t·∫•t c·∫£ l∆∞·ª£t b√¨nh ch·ªçn
- **B·ªô nh·ªõ**: $O(N \times M)$ - L∆∞u tr·ªØ x√¢u b√¨nh ch·ªçn

---

## Code tham kh·∫£o

### C++
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
    
    vector<string> votes(N);
    for (int i = 0; i < N; i++) {
        cin >> votes[i];
    }
    
    vector<int> scores(N, 0);
    
    // Duyet qua tung luot binh chon
    for (int j = 0; j < M; j++) {
        int count0 = 0, count1 = 0;
        
        // Dem so nguoi chon 0 va 1
        for (int i = 0; i < N; i++) {
            if (votes[i][j] == '0') count0++;
            else count1++;
        }
        
        // Ap dung quy tac trao diem
        for (int i = 0; i < N; i++) {
            if (count0 == 0 || count1 == 0) {
                // Tat ca nhan 1 diem
                scores[i]++;
            } else if (count0 < count1 && votes[i][j] == '0') {
                // Nguoi chon 0 la thieu so
                scores[i]++;
            } else if (count1 < count0 && votes[i][j] == '1') {
                // Nguoi chon 1 la thieu so
                scores[i]++;
            }
        }
    }
    
    // Tim diem cao nhat
    int max_score = *max_element(scores.begin(), scores.end());
    
    // In cac nguoi co diem cao nhat
    vector<int> winners;
    for (int i = 0; i < N; i++) {
        if (scores[i] == max_score) {
            winners.push_back(i + 1); // +1 vi so thu tu bat dau tu 1
        }
    }
    
    for (int i = 0; i < winners.size(); i++) {
        if (i > 0) cout << " ";
        cout << winners[i];
    }
    cout << endl;
    
    return 0;
}
```

### Python
```python
# Nhap du lieu
N, M = map(int, input().split())
votes = []
for i in range(N):
    votes.append(input().strip())

scores = [0] * N

# Duyet qua tung luot binh chon
for j in range(M):
    count0 = 0
    count1 = 0
    
    # Dem so nguoi chon 0 va 1
    for i in range(N):
        if votes[i][j] == '0':
            count0 += 1
        else:
            count1 += 1
    
    # Ap dung quy tac trao diem
    for i in range(N):
        if count0 == 0 or count1 == 0:
            # Tat ca nhan 1 diem
            scores[i] += 1
        elif count0 < count1 and votes[i][j] == '0':
            # Nguoi chon 0 la thieu so
            scores[i] += 1
        elif count1 < count0 and votes[i][j] == '1':
            # Nguoi chon 1 la thieu so
            scores[i] += 1

# Tim diem cao nhat
max_score = max(scores)

# Tim cac nguoi co diem cao nhat
winners = []
for i in range(N):
    if scores[i] == max_score:
        winners.append(i + 1)  # +1 vi so thu tu bat dau tu 1

# In ket qua
print(*winners)
```

---

## B·ªô test ch·∫•m ƒëi·ªÉm

### Test cases ƒë·∫∑c bi·ªát
```
Test 1: T·∫•t c·∫£ ch·ªçn gi·ªëng nhau
Test 2: Lu√¥n c√≥ phe thi·ªÉu s·ªë r√µ r√†ng  
Test 3: N = 1 (tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát)
Test 4: C√≥ l∆∞·ª£t kh√¥ng ai ch·ªçn 0 ho·∫∑c 1
Test 5: ƒêi·ªÉm b·∫±ng nhau cho nhi·ªÅu ng∆∞·ªùi
```

### Subtask v√† ƒëi·ªÉm s·ªë

**Subtask 1** (30 ƒëi·ªÉm): $N = 1$
- 12 test cases
- Tr∆∞·ªùng h·ª£p ƒë∆°n gi·∫£n, ch·ªâ c√≥ 1 ng∆∞·ªùi

**Subtask 2** (40 ƒëi·ªÉm): $N \leq 10, M \leq 10$
- 16 test cases  
- Test c√°c tr∆∞·ªùng h·ª£p nh·ªè

**Subtask 3** (30 ƒëi·ªÉm): Kh√¥ng r√†ng bu·ªôc th√™m
- 12 test cases
- Test ƒë·∫ßy ƒë·ªß v·ªõi $N \leq 99, M \leq 100$

### Generator test t·ª± ƒë·ªông

#### C++
```cpp
#include <iostream>
#include <random>
#include <fstream>
#include <vector>
#include <string>
using namespace std;

vector<int> solve(int N, int M, vector<string>& votes) {
    vector<int> scores(N, 0);
    
    for (int j = 0; j < M; j++) {
        int count0 = 0, count1 = 0;
        for (int i = 0; i < N; i++) {
            if (votes[i][j] == '0') count0++;
            else count1++;
        }
        
        for (int i = 0; i < N; i++) {
            if (count0 == 0 || count1 == 0) {
                scores[i]++;
            } else if (count0 < count1 && votes[i][j] == '0') {
                scores[i]++;
            } else if (count1 < count0 && votes[i][j] == '1') {
                scores[i]++;
            }
        }
    }
    
    int max_score = *max_element(scores.begin(), scores.end());
    vector<int> winners;
    for (int i = 0; i < N; i++) {
        if (scores[i] == max_score) {
            winners.push_back(i + 1);
        }
    }
    
    return winners;
}

int main() {
    random_device rd;
    mt19937 gen(rd());
    
    for (int t = 1; t <= 40; t++) {
        ofstream input("input" + to_string(t) + ".txt");
        ofstream output("output" + to_string(t) + ".txt");
        
        int N, M;
        if (t <= 12) {
            N = 1;
            M = uniform_int_distribution<>(1, 100)(gen);
        } else if (t <= 28) {
            N = uniform_int_distribution<>(1, 9)(gen);
            if (N % 2 == 0) N++;
            M = uniform_int_distribution<>(1, 10)(gen);
        } else {
            N = uniform_int_distribution<>(1, 99)(gen);
            if (N % 2 == 0) N++;
            M = uniform_int_distribution<>(1, 100)(gen);
        }
        
        input << N << " " << M << endl;
        
        vector<string> votes(N);
        for (int i = 0; i < N; i++) {
            votes[i] = "";
            for (int j = 0; j < M; j++) {
                votes[i] += (uniform_int_distribution<>(0, 1)(gen) ? '1' : '0');
            }
            input << votes[i] << endl;

# B√†i C: Sum of Min Query (Truy v·∫•n t·ªïng gi√° tr·ªã nh·ªè nh·∫•t)

## ƒê·ªÅ b√†i

**ƒêi·ªÉm s·ªë**: 300 ƒëi·ªÉm  
**Th·ªùi gian**: 2 gi√¢y  
**B·ªô nh·ªõ**: 1024 MiB

### M√¥ t·∫£ b√†i to√°n
Cho hai d√£y s·ªë nguy√™n ƒë·ªô d√†i $N$: $A = (A_1, A_2, \ldots, A_N)$ v√† $B = (B_1, B_2, \ldots, B_N)$.

C·∫ßn x·ª≠ l√Ω $Q$ truy v·∫•n theo th·ª© t·ª±. Truy v·∫•n th·ª© $i$ c√≥ d·∫°ng:
- Cho k√Ω t·ª± $c_i$ v√† hai s·ªë nguy√™n $X_i$, $V_i$
- N·∫øu $c_i = $ `A`: thay ƒë·ªïi $A_{X_i} = V_i$
- N·∫øu $c_i = $ `B`: thay ƒë·ªïi $B_{X_i} = V_i$  
- Sau ƒë√≥ in ra $\displaystyle \sum_{k=1}^N \min(A_k, B_k)$

### R√†ng bu·ªôc
- $1 \leq N, Q \leq 2 \times 10^5$
- $1 \leq A_i, B_i \leq 10^9$
- $c_i \in \{$`A`$,$`B`$\}$
- $1 \leq X_i \leq N$
- $1 \leq V_i \leq 10^9$

### D·ªØ li·ªáu v√†o
```
N Q
A_1 A_2 ... A_N
B_1 B_2 ... B_N
c_1 X_1 V_1
c_2 X_2 V_2
...
c_Q X_Q V_Q
```

### D·ªØ li·ªáu ra
In ra $Q$ d√≤ng, m·ªói d√≤ng l√† k·∫øt qu·∫£ c·ªßa m·ªôt truy v·∫•n.

### V√≠ d·ª•

**V√≠ d·ª• 1:**
```
V√†o:
4 3
3 1 4 1
2 7 1 8
A 2 3
B 3 3
A 1 7

Ra:
7
9
9
```

*Gi·∫£i th√≠ch:*
- Truy v·∫•n 1: $A = (3,3,4,1), B = (2,7,1,8) \Rightarrow \min(3,2) + \min(3,7) + \min(4,1) + \min(1,8) = 2 + 3 + 1 + 1 = 7$
- Truy v·∫•n 2: $A = (3,3,4,1), B = (2,7,3,8) \Rightarrow \min(3,2) + \min(3,7) + \min(4,3) + \min(1,8) = 2 + 3 + 3 + 1 = 9$
- Truy v·∫•n 3: $A = (7,3,4,1), B = (2,7,3,8) \Rightarrow \min(7,2) + \min(3,7) + \min(4,3) + \min(1,8) = 2 + 3 + 3 + 1 = 9$

---

## H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n b√†i to√°n

### B∆∞·ªõc 1: Hi·ªÉu b√†i to√°n
üí° **Ph√¢n t√≠ch**: ƒê√¢y l√† b√†i to√°n update ƒëi·ªÉm v√† truy v·∫•n t·ªïng.

**Thao t√°c ch√≠nh:**
1. C·∫≠p nh·∫≠t m·ªôt ph·∫ßn t·ª≠ trong d√£y $A$ ho·∫∑c $B$
2. T√≠nh t·ªïng $\min(A_k, B_k)$ v·ªõi m·ªçi $k$ t·ª´ $1$ ƒë·∫øn $N$

### B∆∞·ªõc 2: C√°ch ti·∫øp c·∫≠n ƒë∆°n gi·∫£n
**Approach 1: Simulation tr·ª±c ti·∫øp**
- V·ªõi m·ªói truy v·∫•n: c·∫≠p nh·∫≠t ph·∫ßn t·ª≠ v√† t√≠nh l·∫°i to√†n b·ªô t·ªïng
- ƒê·ªô ph·ª©c t·∫°p: $O(Q \times N)$ - C√≥ th·ªÉ ch·∫≠m v·ªõi $N, Q$ l·ªõn

**Approach 2: T·ªëi ∆∞u h√≥a**
- Duy tr√¨ t·ªïng hi·ªán t·∫°i
- Khi c·∫≠p nh·∫≠t ph·∫ßn t·ª≠ t·∫°i v·ªã tr√≠ $X$: ch·ªâ c·∫ßn c·∫≠p nh·∫≠t l·∫°i ƒë√≥ng g√≥p c·ªßa v·ªã tr√≠ ƒë√≥
- ƒê·ªô ph·ª©c t·∫°p: $O(Q)$ - T·ªëi ∆∞u h∆°n

### B∆∞·ªõc 3: Thu·∫≠t to√°n t·ªëi ∆∞u
```
1. T√≠nh total_sum ban ƒë·∫ßu = sum(min(A[i], B[i]) for i in 1..N)
2. V·ªõi m·ªói truy v·∫•n (c, X, V):
   a. old_min = min(A[X], B[X])
   b. C·∫≠p nh·∫≠t A[X] ho·∫∑c B[X] = V
   c. new_min = min(A[X], B[X])
   d. total_sum = total_sum - old_min + new_min
   e. In total_sum
```

---

## Gi·∫£i thu·∫≠t v√† ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

### Thu·∫≠t to√°n
```
1. ƒê·ªçc N, Q v√† hai d√£y A, B
2. T√≠nh t·ªïng ban ƒë·∫ßu: sum = Œ£ min(A[i], B[i])
3. V·ªõi m·ªói truy v·∫•n:
   a. L∆∞u old_min = min(A[X], B[X])
   b. C·∫≠p nh·∫≠t A[X] ho·∫∑c B[X] theo truy v·∫•n
   c. T√≠nh new_min = min(A[X], B[X])
   d. C·∫≠p nh·∫≠t: sum = sum - old_min + new_min
   e. In sum
```

### ƒê·ªô ph·ª©c t·∫°p
- **Th·ªùi gian**: $O(N + Q)$ - T√≠nh ban ƒë·∫ßu $O(N)$, m·ªói truy v·∫•n $O(1)$
- **B·ªô nh·ªõ**: $O(N)$ - L∆∞u tr·ªØ hai d√£y $A$ v√† $B$

---

## Code tham kh·∫£o

### C++
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N, Q;
    cin >> N >> Q;
    
    vector<long long> A(N + 1), B(N + 1);
    
    // Doc day A
    for (int i = 1; i <= N; i++) {
        cin >> A[i];
    }
    
    // Doc day B  
    for (int i = 1; i <= N; i++) {
        cin >> B[i];
    }
    
    // Tinh tong ban dau
    long long total_sum = 0;
    for (int i = 1; i <= N; i++) {
        total_sum += min(A[i], B[i]);
    }
    
    // Xu ly cac truy van
    for (int q = 0; q < Q; q++) {
        char c;
        int X;
        long long V;
        cin >> c >> X >> V;
        
        // Luu gia tri min cu
        long long old_min = min(A[X], B[X]);
        
        // Cap nhat gia tri moi
        if (c == 'A') {
            A[X] = V;
        } else {
            B[X] = V;
        }
        
        // Tinh gia tri min moi
        long long new_min = min(A[X], B[X]);
        
        // Cap nhat tong
        total_sum = total_sum - old_min + new_min;
        
        // In ket qua
        cout << total_sum << "\n";
    }
    
    return 0;
}
```

### Python
```python
# Nhap du lieu
N, Q = map(int, input().split())
A = [0] + list(map(int, input().split()))  # 1-indexed
B = [0] + list(map(int, input().split()))  # 1-indexed

# Tinh tong ban dau
total_sum = sum(min(A[i], B[i]) for i in range(1, N + 1))

# Xu ly cac truy van
for _ in range(Q):
    c, X, V = input().split()
    X = int(X)
    V = int(V)
    
    # Luu gia tri min cu
    old_min = min(A[X], B[X])
    
    # Cap nhat gia tri moi
    if c == 'A':
        A[X] = V
    else:
        B[X] = V
    
    # Tinh gia tri min moi
    new_min = min(A[X], B[X])
    
    # Cap nhat tong
    total_sum = total_sum - old_min + new_min
    
    # In ket qua
    print(total_sum)
```

---

## B·ªô test ch·∫•m ƒëi·ªÉm

### Test cases ƒë·∫∑c bi·ªát
```
Test 1: N = 1, Q = 1 (tr∆∞·ªùng h·ª£p t·ªëi thi·ªÉu)
Test 2: T·∫•t c·∫£ A[i] < B[i] ban ƒë·∫ßu
Test 3: T·∫•t c·∫£ A[i] > B[i] ban ƒë·∫ßu  
Test 4: A[i] = B[i] cho m·ªôt s·ªë v·ªã tr√≠
Test 5: Gi√° tr·ªã l·ªõn (10^9)
Test 6: Nhi·ªÅu truy v·∫•n c·∫≠p nh·∫≠t c√πng v·ªã tr√≠
```

### Subtask v√† ƒëi·ªÉm s·ªë

**Subtask 1** (20 ƒëi·ªÉm): $N, Q \leq 100$
- 8 test cases
- C√≥ th·ªÉ d√πng thu·∫≠t to√°n $O(Q \times N)$

**Subtask 2** (30 ƒëi·ªÉm): $N, Q \leq 5000$  
- 12 test cases
- C·∫ßn thu·∫≠t to√°n hi·ªáu qu·∫£ h∆°n

**Subtask 3** (50 ƒëi·ªÉm): Kh√¥ng r√†ng bu·ªôc th√™m
- 20 test cases
- C·∫ßn thu·∫≠t to√°n $O(N + Q)$

### Generator test t·ª± ƒë·ªông

#### C++
```cpp
#include <iostream>
#include <random>
#include <fstream>
#include <vector>
using namespace std;

long long solve_query(vector<long long>& A, vector<long long>& B, 
                     char c, int X, long long V, long long& total_sum) {
    long long old_min = min(A[X], B[X]);
    
    if (c == 'A') A[X] = V;
    else B[X] = V;
    
    long long new_min = min(A[X], B[X]);
    total_sum = total_sum - old_min + new_min;
    
    return total_sum;
}

int main() {
    random_device rd;
    mt19937 gen(rd());
    
    for (int t = 1; t <= 40; t++) {
        ofstream input("input" + to_string(t) + ".txt");
        ofstream output("output" + to_string(t) + ".txt");
        
        int N, Q;
        if (t <= 8) {
            N = uniform_int_distribution<>(1, 100)(gen);
            Q = uniform_int_distribution<>(1, 100)(gen);
        } else if (t <= 20) {
            N = uniform_int_distribution<>(1, 5000)(gen);
            Q = uniform_int_distribution<>(1, 5000)(gen);
        } else {
            N = uniform_int_distribution<>(1, 200000)(gen);
            Q = uniform_int_distribution<>(1, 200000)(gen);
        }
        
        input << N << " " << Q << endl;
        
        vector<long long> A(N + 1), B(N + 1);
        uniform_int_distribution<long long> val_dist(1, 1000000000);
        
        // Tao day A
        for (int i = 1; i <= N; i++) {
            A[i] = val_dist(gen);
            if (i > 1) input << " ";
            input << A[i];
        }
        input << endl;
        
        // Tao day B
        for (int i = 1; i <= N; i++) {
            B[i] = val_dist(gen);
            if (i > 1) input << " ";
            input << B[i];
        }
        input << endl;
        
        // Tinh tong ban dau
        long long total_sum = 0;
        for (int i = 1; i <= N; i++) {
            total_sum += min(A[i], B[i]);
        }
        
        // Tao cac truy van
        uniform_int_distribution<> pos_dist(1, N);
        uniform_int_distribution<> char_dist(0, 1);
        
        for (int q = 0; q < Q; q++) {
            char c = (char_dist(gen) == 0) ? 'A' : 'B';
            int X = pos_dist(gen);
            long long V = val_dist(gen);
            
            input << c << " " << X << " " << V << endl;
            
            long long result = solve_query(A, B, c, X, V, total_sum);
            output << result << endl;
        }
        
        input.close();
        output.close();
    }
    
    return 0;
}
```

#### Python
```python
import random

def solve_query(A, B, c, X, V):
    old_min = min(A[X], B[X])
    
    if c == 'A':
        A[X] = V
    else:
        B[X] = V
    
    new_min = min(A[X], B[X])
    return new_min - old_min

# Tao 40 test cases
for t in range(1, 41):
    if t <= 8:
        N = random.randint(1, 100)
        Q = random.randint(1, 100)
    elif t <= 20:
        N = random.randint(1, 5000)
        Q = random.randint(1, 5000)
    else:
        N = random.randint(1, 200000)
        Q = random.randint(1, 200000)
    
    A = [0] + [random.randint(1, 1000000000) for _ in range(N)]
    B = [0] + [random.randint(1, 1000000000) for _ in range(N)]
    
    # Tinh tong ban dau
    total_sum = sum(min(A[i], B[i]) for i in range(1, N + 1))
    
    with open(f"input{t}.txt", "w") as f:
        f.write(f"{N} {Q}\n")
        f.write(" ".join(map(str, A[1:])) + "\n")
        f.write(" ".join(map(str, B[1:])) + "\n")
        
        results = []
        for _ in range(Q):
            c = random.choice(['A', 'B'])
            X = random.randint(1, N)
            V = random.randint(1, 1000000000)
            
            f.write(f"{c} {X} {V}\n")
            
            # Tinh ket qua
            diff = solve_query(A, B, c, X, V)
            total_sum += diff
            results.append(total_sum)
    
    with open(f"output{t}.txt", "w") as f:
        for result in results:
            f.write(f"{result}\n")
```

### Ch·∫•m ƒëi·ªÉm chi ti·∫øt
- **AC (Accepted)**: 300 ƒëi·ªÉm - Code ch√≠nh x√°c v√† hi·ªáu qu·∫£
- **WA (Wrong Answer)**: 0 ƒëi·ªÉm - Sai logic c·∫≠p nh·∫≠t ho·∫∑c t√≠nh t·ªïng
- **TLE (Time Limit)**: 0 ƒëi·ªÉm - Thu·∫≠t to√°n $O(Q \times N)$ v·ªõi d·ªØ li·ªáu l·ªõn
- **RE (Runtime Error)**: 0 ƒëi·ªÉm - Tr√†n s·ªë ho·∫∑c truy c·∫≠p sai ch·ªâ s·ªë

---

## L∆∞u √Ω v√† m·∫πo

‚ö†Ô∏è **C√°c l·ªói th∆∞·ªùng g·∫∑p:**
1. Tr√†n s·ªë: c·∫ßn d√πng `long long` thay v√¨ `int`
2. Ch·ªâ s·ªë m·∫£ng: nh·ªõ s·ª≠ d·ª•ng 1-indexed
3. Thu·∫≠t to√°n ch·∫≠m: t√≠nh l·∫°i to√†n b·ªô t·ªïng m·ªói l·∫ßn thay v√¨ ch·ªâ c·∫≠p nh·∫≠t diff
4. Kh√¥ng l∆∞u tr·∫°ng th√°i: ph·∫£i nh·ªõ gi√° tr·ªã c≈© ƒë·ªÉ t√≠nh diff

üí° **M·∫πo l√†m b√†i:**
1. Ki·ªÉm tra k·ªπ ki·ªÉu d·ªØ li·ªáu: $N \times 10^9$ c√≥ th·ªÉ tr√†n `int`  
2. T·ªëi ∆∞u h√≥a: ch·ªâ c·∫≠p nh·∫≠t ph·∫ßn thay ƒë·ªïi thay v√¨ t√≠nh l·∫°i to√†n b·ªô
3. Debug: in ra t·ª´ng b∆∞·ªõc ƒë·ªÉ ki·ªÉm tra logic c·∫≠p nh·∫≠t
4. Test edge case: $N=1$, t·∫•t c·∫£ $A[i] = B[i]$

üîç **Ki·∫øn th·ª©c li√™n quan:**
- Point Update & Range Query c∆° b·∫£n
- T·ªëi ∆∞u h√≥a thu·∫≠t to√°n b·∫±ng c√°ch duy tr√¨ state
- X·ª≠ l√Ω s·ªë l·ªõn v·ªõi `long long`
- K·ªπ thu·∫≠t difference/delta trong c·∫≠p nh·∫≠t

# B√†i D: Toggle Maze (M√™ cung c√¥ng t·∫Øc)

## ƒê·ªÅ b√†i

**ƒêi·ªÉm s·ªë**: 400 ƒëi·ªÉm  
**Th·ªùi gian**: 2 gi√¢y  
**B·ªô nh·ªõ**: 1024 MiB

### M√¥ t·∫£ b√†i to√°n
Cho m·ªôt l∆∞·ªõi $H \times W$ v·ªõi c√°c k√Ω t·ª± sau:
- `.`: √î tr·ªëng
- `#`: V·∫≠t c·∫£n  
- `S`: ƒêi·ªÉm xu·∫•t ph√°t
- `G`: ƒêi·ªÉm ƒë√≠ch
- `o`: C·ª≠a m·ªü
- `x`: C·ª≠a ƒë√≥ng
- `?`: C√¥ng t·∫Øc

Takahashi c√≥ th·ªÉ di chuy·ªÉn t·ª´ √¥ hi·ªán t·∫°i ƒë·∫øn √¥ k·ªÅ c·∫≠n (4 h∆∞·ªõng) n·∫øu √¥ ƒë√≥ kh√¥ng ph·∫£i l√† v·∫≠t c·∫£n ho·∫∑c c·ª≠a ƒë√≥ng.

M·ªói khi Takahashi di chuy·ªÉn ƒë·∫øn √¥ c√¥ng t·∫Øc `?`, t·∫•t c·∫£ c·ª≠a s·∫Ω ƒë·ªïi tr·∫°ng th√°i:
- C·ª≠a m·ªü `o` ‚Üí C·ª≠a ƒë√≥ng `x`
- C·ª≠a ƒë√≥ng `x` ‚Üí C·ª≠a m·ªü `o`

H√£y t√¨m s·ªë b∆∞·ªõc √≠t nh·∫•t ƒë·ªÉ ƒëi t·ª´ `S` ƒë·∫øn `G`, ho·∫∑c `-1` n·∫øu kh√¥ng th·ªÉ.

### R√†ng bu·ªôc
- $1 \leq H, W \leq 500$
- $A_{i,j} \in \{$ `.`, `#`, `S`, `G`, `o`, `x`, `?` $\}$
- `S` v√† `G` xu·∫•t hi·ªán ƒë√∫ng 1 l·∫ßn

### D·ªØ li·ªáu v√†o
```
H W
A_{1,1}A_{1,2}...A_{1,W}
A_{2,1}A_{2,2}...A_{2,W}
...
A_{H,1}A_{H,2}...A_{H,W}
```

### D·ªØ li·ªáu ra
In ra s·ªë b∆∞·ªõc √≠t nh·∫•t, ho·∫∑c `-1` n·∫øu kh√¥ng th·ªÉ.

### V√≠ d·ª•

**V√≠ d·ª• 1:**
```
V√†o:
2 4
S.xG
#?o.

Ra: 5
```

*Gi·∫£i th√≠ch: Di chuy·ªÉn $(1,1) \to (1,2) \to (2,2) \to (1,2) \to (1,3) \to (1,4)$ v·ªõi 5 b∆∞·ªõc.*

**V√≠ d·ª• 2:**
```
V√†o:
1 5
So?oG

Ra: -1
```

---

## H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n b√†i to√°n

### B∆∞·ªõc 1: Hi·ªÉu b√†i to√°n
üí° **Ph√¢n t√≠ch**: ƒê√¢y l√† b√†i to√°n t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t v·ªõi tr·∫°ng th√°i thay ƒë·ªïi.

**ƒêi·ªÉm ƒë·∫∑c bi·ªát:**
- Tr·∫°ng th√°i c·ª≠a thay ƒë·ªïi m·ªói khi ƒëi qua c√¥ng t·∫Øc
- C·∫ßn theo d√µi c·∫£ v·ªã tr√≠ v√† tr·∫°ng th√°i c·ª≠a
- BFS v·ªõi state space m·ªü r·ªông

### B∆∞·ªõc 2: M√¥ h√¨nh h√≥a tr·∫°ng th√°i
**State**: $(r, c, door\_state)$
- $(r, c)$: v·ªã tr√≠ hi·ªán t·∫°i
- $door\_state$: tr·∫°ng th√°i c·ª≠a (0 ho·∫∑c 1, t∆∞∆°ng ·ª©ng ban ƒë·∫ßu ho·∫∑c ƒë√£ ƒë·ªïi)

**Transition**: T·ª´ $(r, c, state)$ ƒë·∫øn $(nr, nc, new\_state)$
- $new\_state = state$ n·∫øu √¥ ƒë√≠ch kh√¥ng ph·∫£i c√¥ng t·∫Øc
- $new\_state = 1 - state$ n·∫øu √¥ ƒë√≠ch l√† c√¥ng t·∫Øc

### B∆∞·ªõc 3: Thu·∫≠t to√°n BFS
```
1. Kh·ªüi t·∫°o: queue v·ªõi (start_r, start_c, 0, 0) - v·ªã tr√≠, tr·∫°ng th√°i, b∆∞·ªõc
2. D√πng BFS ƒë·ªÉ duy·ªát:
   - V·ªõi m·ªói tr·∫°ng th√°i, th·ª≠ 4 h∆∞·ªõng di chuy·ªÉn
   - Ki·ªÉm tra ƒëi·ªÅu ki·ªán h·ª£p l·ªá (kh√¥ng ph·∫£i v·∫≠t c·∫£n, c·ª≠a ƒë√≥ng)
   - C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ª≠a n·∫øu ƒëi qua c√¥ng t·∫Øc
3. Tr·∫£ v·ªÅ s·ªë b∆∞·ªõc khi ƒë·∫øn ƒë∆∞·ª£c ƒë√≠ch, ho·∫∑c -1
```

---

## Gi·∫£i thu·∫≠t v√† ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

### Thu·∫≠t to√°n
```
1. T√¨m v·ªã tr√≠ start (S) v√† goal (G)
2. Kh·ªüi t·∫°o visited[r][c][door_state] = false
3. BFS:
   - Queue ch·ª©a (row, col, door_state, steps)
   - V·ªõi m·ªói tr·∫°ng th√°i, th·ª≠ 4 h∆∞·ªõng
   - Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa √¥ ti·∫øp theo
   - C·∫≠p nh·∫≠t door_state n·∫øu c·∫ßn
   - ƒê√°nh d·∫•u visited v√† th√™m v√†o queue
4. Tr·∫£ v·ªÅ k·∫øt qu·∫£
```

### ƒê·ªô ph·ª©c t·∫°p
- **Th·ªùi gian**: $O(H \times W \times 2)$ - M·ªói √¥ c√≥ 2 tr·∫°ng th√°i c·ª≠a
- **B·ªô nh·ªõ**: $O(H \times W \times 2)$ - L∆∞u tr·∫°ng th√°i visited

---

## Code tham kh·∫£o

### C++
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <string>
using namespace std;

int dr[] = {-1, 1, 0, 0};
int dc[] = {0, 0, -1, 1};

int main() {
    int H, W;
    cin >> H >> W;
    
    vector<string> grid(H);
    int start_r = -1, start_c = -1;
    int goal_r = -1, goal_c = -1;
    
    for (int i = 0; i < H; i++) {
        cin >> grid[i];
        for (int j = 0; j < W; j++) {
            if (grid[i][j] == 'S') {
                start_r = i;
                start_c = j;
            } else if (grid[i][j] == 'G') {
                goal_r = i;
                goal_c = j;
            }
        }
    }
    
    // BFS voi state (row, col, door_state)
    // door_state: 0 = ban dau, 1 = da doi
    vector<vector<vector<bool>>> visited(H, vector<vector<bool>>(W, vector<bool>(2, false)));
    
    queue<tuple<int, int, int, int>> q; // row, col, door_state, steps
    q.push({start_r, start_c, 0, 0});
    visited[start_r][start_c][0] = true;
    
    while (!q.empty()) {
        auto [r, c, door_state, steps] = q.front();
        q.pop();
        
        // Kiem tra neu da den dich
        if (r == goal_r && c == goal_c) {
            cout << steps << endl;
            return 0;
        }
        
        // Thu 4 huong di chuyen
        for (int d = 0; d < 4; d++) {
            int nr = r + dr[d];
            int nc = c + dc[d];
            
            // Kiem tra trong bien
            if (nr < 0 || nr >= H || nc < 0 || nc >= W) continue;
            
            char cell = grid[nr][nc];
            int new_door_state = door_state;
            
            // Kiem tra co the di chuyen den o nay khong
            bool can_move = true;
            
            if (cell == '#') {
                can_move = false;
            } else if (cell == 'x') { // cua dong
                if (door_state == 0) can_move = false; // chua doi trang thai
            } else if (cell == 'o') { // cua mo
                if (door_state == 1) can_move = false; // da doi trang thai
            }
            
            if (!can_move) continue;
            
            // Cap nhat trang thai cua neu di qua cong tac
            if (cell == '?') {
                new_door_state = 1 - door_state;
            }
            
            // Kiem tra chua tham
            if (!visited[nr][nc][new_door_state]) {
                visited[nr][nc][new_door_state] = true;
                q.push({nr, nc, new_door_state, steps + 1});
            }
        }
    }
    
    cout << -1 << endl;
    return 0;
}
```

### Python
```python
from collections import deque

# Doc du lieu
H, W = map(int, input().split())
grid = []
start_r = start_c = goal_r = goal_c = -1

for i in range(H):
    row = input().strip()
    grid.append(row)
    for j in range(W):
        if row[j] == 'S':
            start_r, start_c = i, j
        elif row[j] == 'G':
            goal_r, goal_c = i, j

# Cac huong di chuyen
dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

# BFS voi state (row, col, door_state)
visited = [[[False] * 2 for _ in range(W)] for _ in range(H)]
queue = deque([(start_r, start_c, 0, 0)])  # row, col, door_state, steps
visited[start_r][start_c][0] = True

while queue:
    r, c, door_state, steps = queue.popleft()
    
    # Kiem tra neu da den dich
    if r == goal_r and c == goal_c:
        print(steps)
        exit()
    
    # Thu 4 huong di chuyen
    for d in range(4):
        nr, nc = r + dr[d], c + dc[d]
        
        # Kiem tra trong bien
        if nr < 0 or nr >= H or nc < 0 or nc >= W:
            continue
        
        cell = grid[nr][nc]
        new_door_state = door_state
        
        # Kiem tra co the di chuyen den o nay khong
        can_move = True
        
        if cell == '#':
            can_move = False
        elif cell == 'x':  # cua dong
            if door_state == 0:  # chua doi trang thai
                can_move = False
        elif cell == 'o':  # cua mo
            if door_state == 1:  # da doi trang thai
                can_move = False
        
        if not can_move:
            continue
        
        # Cap nhat trang thai cua neu di qua cong tac
        if cell == '?':
            new_door_state = 1 - door_state
        
        # Kiem tra chua tham
        if not visited[nr][nc][new_door_state]:
            visited[nr][nc][new_door_state] = True
            queue.append((nr, nc, new_door_state, steps + 1))

print(-1)
```

---

## B·ªô test ch·∫•m ƒëi·ªÉm

### Test cases ƒë·∫∑c bi·ªát
```
Test 1: Kh√¥ng c√≥ c·ª≠a v√† c√¥ng t·∫Øc - BFS th√¥ng th∆∞·ªùng
Test 2: C√≥ c·ª≠a nh∆∞ng kh√¥ng c√≥ c√¥ng t·∫Øc
Test 3: C√≥ c√¥ng t·∫Øc nh∆∞ng kh√¥ng c√≥ c·ª≠a
Test 4: C·∫ßn ƒëi qua c√¥ng t·∫Øc nhi·ªÅu l·∫ßn
Test 5: Kh√¥ng th·ªÉ ƒë·∫øn ƒë√≠ch
Test 6: ƒê∆∞·ªùng ƒëi t·ªëi ∆∞u c·∫ßn toggle doors
```

### Subtask v√† ƒëi·ªÉm s·ªë

**Subtask 1** (25 ƒëi·ªÉm): Kh√¥ng c√≥ c√¥ng t·∫Øc v√† c·ª≠a
- 10 test cases
- Ch·ªâ c·∫ßn BFS th√¥ng th∆∞·ªùng

**Subtask 2** (35 ƒëi·ªÉm): $H, W \leq 50$
- 14 test cases  
- Test tr√™n l∆∞·ªõi nh·ªè

**Subtask 3** (40 ƒëi·ªÉm): Kh√¥ng r√†ng bu·ªôc th√™m
- 16 test cases
- Test ƒë·∫ßy ƒë·ªß v·ªõi $H, W \leq 500$

### Generator test t·ª± ƒë·ªông

#### C++
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <random>
#include <fstream>
using namespace std;

// Ham giai bai toan
int solve(vector<string>& grid, int H, int W) {
    int start_r = -1, start_c = -1, goal_r = -1, goal_c = -1;
    
    // Tim vi tri start va goal
    for (int i = 0; i < H; i++) {
        for (int j = 0; j < W; j++) {
            if (grid[i][j] == 'S') {
                start_r = i; start_c = j;
            } else if (grid[i][j] == 'G') {
                goal_r = i; goal_c = j;
            }
        }
    }
    
    int dr[] = {-1, 1, 0, 0};
    int dc[] = {0, 0, -1, 1};
    
    vector<vector<vector<bool>>> visited(H, vector<vector<bool>>(W, vector<bool>(2, false)));
    queue<tuple<int, int, int, int>> q;
    q.push({start_r, start_c, 0, 0});
    visited[start_r][start_c][0] = true;
    
    while (!q.empty()) {
        auto [r, c, door_state, steps] = q.front();
        q.pop();
        
        if (r == goal_r && c == goal_c) {
            return steps;
        }
        
        for (int d = 0; d < 4; d++) {
            int nr = r + dr[d];
            int nc = c + dc[d];
            
            if (nr < 0 || nr >= H || nc < 0 || nc >= W) continue;
            
            char cell = grid[nr][nc];
            int new_door_state = door_state;
            bool can_move = true;
            
            if (cell == '#') {
                can_move = false;
            } else if (cell == 'x') {
                if (door_state == 0) can_move = false;
            } else if (cell == 'o') {
                if (door_state == 1) can_move = false;
            }
            
            if (!can_move) continue;
            
            if (cell == '?') {
                new_door_state = 1 - door_state;
            }
            
            if (!visited[nr][nc][new_door_state]) {
                visited[nr][nc][new_door_state] = true;
                q.push({nr, nc, new_door_state, steps + 1});
            }
        }
    }
    
    return -1;
}

int main() {
    random_device rd;
    mt19937 gen(rd());
    
    for (int t = 1; t <= 40; t++) {
        ofstream input("input" + to_string(t) + ".txt");
        ofstream output("output" + to_string(t) + ".txt");
        
        int H, W;
        if (t <= 10) {
            // Subtask 1: khong co cong tac va cua
            H = uniform_int_distribution<>(2, 20)(gen);
            W = uniform_int_distribution<>(2, 20)(gen);
        } else if (t <= 24) {
            // Subtask 2: luoi nho
            H = uniform_int_distribution<>(2, 50)(gen);
            W = uniform_int_distribution<>(2, 50)(gen);
        } else {
            // Subtask 3: luoi lon
            H = uniform_int_distribution<>(2, 500)(gen);
            W = uniform_int_distribution<>(2, 500)(gen);
        }
        
        input << H << " " << W << endl;
        
        vector<string> grid(H, string(W, '.'));
        
        // Dat S va G
        int sr = uniform_int_distribution<>(0, H-1)(gen);
        int sc = uniform_int_distribution<>(0, W-1)(gen);
        int gr, gc;
        do {
            gr = uniform_int_distribution<>(0, H-1)(gen);
            gc = uniform_int_distribution<>(0, W-1)(gen);
        } while (gr == sr && gc == sc);
        
        grid[sr][sc] = 'S';
        grid[gr][gc] = 'G';
        
        // Them cac phan tu khac
        if (t > 10) { // Chi them cua va cong tac neu khong phai subtask 1
            int num_obstacles = uniform_int_distribution<>(0, H*W/10)(gen);
            int num_doors = uniform_int_distribution<>(0, H*W/20)(gen);
            int num_switches = uniform_int_distribution<>(0, min(3, H*W/30))(gen);
            
            vector<char> elements = {'#', 'o', 'x', '?'};
            vector<int> counts = {num_obstacles, num_doors/2, num_doors/2, num_switches};
            
            for (int i = 0; i < elements.size(); i++) {
                for (int j = 0; j < counts[i]; j++) {
                    int r, c;
                    do {
                        r = uniform_int_distribution<>(0, H-1)(gen);
                        c = uniform_int_distribution<>(0, W-1)(gen);
                    } while (grid[r][c] != '.');
                    grid[r][c] = elements[i];
                }
            }
        }
        
        // Ghi grid
        for (int i = 0; i < H; i++) {
            input << grid[i] << endl;
        }
        
        int result = solve(grid, H, W);
        output << result << endl;
        
        input.close();
        output.close();
    }
    
    return 0;
}
```

#### Python
```python
import random
from collections import deque

def solve(grid, H, W):
    start_r = start_c = goal_r = goal_c = -1
    
    # Tim vi tri start va goal
    for i in range(H):
        for j in range(W):
            if grid[i][j] == 'S':
                start_r, start_c = i, j
            elif grid[i][j] == 'G':
                goal_r, goal_c = i, j
    
    dr = [-1, 1, 0, 0]
    dc = [0, 0, -1, 1]
    
    visited = [[[False] * 2 for _ in range(W)] for _ in range(H)]
    queue = deque([(start_r, start_c, 0, 0)])
    visited[start_r][start_c][0] = True
    
    while queue:
        r, c, door_state, steps = queue.popleft()
        
        if r == goal_r and c == goal_c:
            return steps
        
        for d in range(4):
            nr, nc = r + dr[d], c + dc[d]
            
            if nr < 0 or nr >= H or nc < 0 or nc >= W:
                continue
            
            cell = grid[nr][nc]
            new_door_state = door_state
            can_move = True
            
            if cell == '#':
                can_move = False
            elif cell == 'x':
                if door_state == 0:
                    can_move = False
            elif cell == 'o':
                if door_state == 1:
                    can_move = False
            
            if not can_move:
                continue
            
            if cell == '?':
                new_door_state = 1 - door_state
            
            if not visited[nr][nc][new_door_state]:
                visited[nr][nc][new_door_state] = True
                queue.append((nr, nc, new_door_state, steps + 1))
    
    return -1

# Tao 40 test cases
for t in range(1, 41):
    if t <= 10:
        H = random.randint(2, 20)
        W = random.randint(2, 20)
    elif t <= 24:
        H = random.randint(2, 50)
        W = random.randint(2, 50)
    else:
        H = random.randint(2, 500)
        W = random.randint(2, 500)
    
    grid = [['.' for _ in range(W)] for _ in range(H)]
    
    # Dat S va G
    sr = random.randint(0, H-1)
    sc = random.randint(0, W-1)
    gr, gc = sr, sc
    while gr == sr and gc == sc:
        gr = random.randint(0, H-1)
        gc = random.randint(0, W-1)
    
    grid[sr][sc] = 'S'
    grid[gr][gc] = 'G'
    
    # Them cac phan tu khac
    if t > 10:
        num_obstacles = random.randint(0, H*W//10)
        num_doors = random.randint(0, H*W//20)
        num_switches = random.randint(0, min(3, H*W//30))
        
        elements = ['#', 'o', 'x', '?']
        counts = [num_obstacles, num_doors//2, num_doors//2, num_switches]
        
        for i, element in enumerate(elements):
            for _ in range(counts[i]):
                while True:
                    r = random.randint(0, H-1)
                    c = random.randint(0, W-1)
                    if grid[r][c] == '.':
                        grid[r][c] = element
                        break
    
    # Ghi file
    with open(f"input{t}.txt", "w") as f:
        f.write(f"{H} {W}\n")
        for row in grid:
            f.write("".join(row) + "\n")
    
    result = solve(grid, H, W)
    
    with open(f"output{t}.txt", "w") as f:
        f.write(f"{result}\n")
```

### Ch·∫•m ƒëi·ªÉm chi ti·∫øt
- **AC (Accepted)**: 400 ƒëi·ªÉm - BFS v·ªõi state space ch√≠nh x√°c
- **WA (Wrong Answer)**: 0 ƒëi·ªÉm - Sai logic toggle ho·∫∑c ƒëi·ªÅu ki·ªán di chuy·ªÉn
- **TLE (Time Limit)**: 0 ƒëi·ªÉm - Thu·∫≠t to√°n kh√¥ng t·ªëi ∆∞u ho·∫∑c visited sai
- **RE (Runtime Error)**: 0 ƒëi·ªÉm - L·ªói truy c·∫≠p m·∫£ng

---

## L∆∞u √Ω v√† m·∫πo

‚ö†Ô∏è **C√°c l·ªói th∆∞·ªùng g·∫∑p:**
1. Qu√™n theo d√µi tr·∫°ng th√°i c·ª≠a - ch·ªâ d√πng BFS th√¥ng th∆∞·ªùng
2. Sai logic toggle: c·ª≠a m·ªü/ƒë√≥ng khi n√†o
3. Kh√¥ng ƒë√°nh d·∫•u visited cho t·ª´ng state ri√™ng bi·ªát
4. Nh·∫ßm l·∫´n ƒëi·ªÅu ki·ªán c√≥ th·ªÉ ƒëi qua c·ª≠a

üí° **M·∫πo l√†m b√†i:**
1. V·∫Ω s∆° ƒë·ªì tr·∫°ng th√°i ƒë·ªÉ hi·ªÉu r√µ state space
2. Debug b·∫±ng c√°ch in ra tr·∫°ng th√°i m·ªói b∆∞·ªõc
3. Ki·ªÉm tra k·ªπ ƒëi·ªÅu ki·ªán c√≥ th·ªÉ di chuy·ªÉn qua t·ª´ng lo·∫°i √¥
4. Test v·ªõi c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát: kh√¥ng c√≥ c·ª≠a, kh√¥ng c√≥ c√¥ng t·∫Øc

üîç **Ki·∫øn th·ª©c li√™n quan:**
- BFS (Breadth-First Search)
- State Space Search
- Graph traversal v·ªõi multiple states
- Toggle/Flip operations trong thu·∫≠t to√°n

# B√†i E: Reachability Query (Truy v·∫•n kh·∫£ nƒÉng ti·∫øp c·∫≠n)

## ƒê·ªÅ b√†i

**ƒêi·ªÉm s·ªë**: 450 ƒëi·ªÉm  
**Th·ªùi gian**: 3 gi√¢y  
**B·ªô nh·ªõ**: 1024 MiB

### M√¥ t·∫£ b√†i to√°n
Cho ƒë·ªì th·ªã v√¥ h∆∞·ªõng $N$ ƒë·ªânh, ban ƒë·∫ßu kh√¥ng c√≥ c·∫°nh. C√°c ƒë·ªânh ƒë∆∞·ª£c ƒë√°nh s·ªë t·ª´ $1$ ƒë·∫øn $N$ v√† ban ƒë·∫ßu t·∫•t c·∫£ ƒë·ªÅu c√≥ m√†u tr·∫Øng.

C·∫ßn x·ª≠ l√Ω $Q$ truy v·∫•n thu·ªôc 3 lo·∫°i:
1. **Lo·∫°i 1**: Th√™m c·∫°nh v√¥ h∆∞·ªõng n·ªëi ƒë·ªânh $u$ v√† $v$
2. **Lo·∫°i 2**: ƒê·ªïi m√†u ƒë·ªânh $v$ (tr·∫Øng ‚Üí ƒëen, ƒëen ‚Üí tr·∫Øng)  
3. **Lo·∫°i 3**: Ki·ªÉm tra t·ª´ ƒë·ªânh $v$ c√≥ th·ªÉ ƒëi ƒë·∫øn ƒë·ªânh ƒëen n√†o kh√¥ng (bao g·ªìm ch√≠nh n√≥)

### R√†ng bu·ªôc
- $1 \leq N \leq 2 \times 10^5$
- $1 \leq Q \leq 6 \times 10^5$
- **Lo·∫°i 1**: $1 \leq u < v \leq N$, c·∫°nh $(u,v)$ ch∆∞a t·ªìn t·∫°i
- **Lo·∫°i 2,3**: $1 \leq v \leq N$

### D·ªØ li·ªáu v√†o
```
N Q
Query_1
Query_2
...
Query_Q
```

V·ªõi:
- Lo·∫°i 1: `1 u v`
- Lo·∫°i 2: `2 v`
- Lo·∫°i 3: `3 v`

### D·ªØ li·ªáu ra
V·ªõi m·ªói truy v·∫•n lo·∫°i 3, in ra `Yes` n·∫øu c√≥ th·ªÉ ƒë·∫øn ƒë·ªânh ƒëen, `No` n·∫øu kh√¥ng.

### V√≠ d·ª•

**V√≠ d·ª• 1:**
```
V√†o:
5 12
3 2
2 2
3 2
1 2 5
1 3 4
3 4
3 5
1 4 5
1 1 3
3 1
2 2
3 1

Ra:
No
Yes
No
Yes
Yes
No
```

---

## H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n b√†i to√°n

### B∆∞·ªõc 1: Hi·ªÉu b√†i to√°n
üí° **Ph√¢n t√≠ch**: ƒê√¢y l√† b√†i to√°n dynamic connectivity v·ªõi m√†u ƒë·ªânh thay ƒë·ªïi.

**Y√™u c·∫ßu ch√≠nh:**
- Th√™m c·∫°nh ƒë·ªông v√†o ƒë·ªì th·ªã
- Thay ƒë·ªïi m√†u ƒë·ªânh  
- Ki·ªÉm tra kh·∫£ nƒÉng ti·∫øp c·∫≠n ƒë·ªânh ƒëen t·ª´ m·ªôt ƒë·ªânh

### B∆∞·ªõc 2: Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p
**Approach 1: Naive - DFS/BFS m·ªói truy v·∫•n**
- ƒê·ªô ph·ª©c t·∫°p: $O(Q \times (N + M))$ - Qu√° ch·∫≠m

**Approach 2: Union-Find + Optimization**
- Duy tr√¨ th√†nh ph·∫ßn li√™n th√¥ng
- Theo d√µi s·ªë ƒë·ªânh ƒëen trong m·ªói th√†nh ph·∫ßn
- ƒê·ªô ph·ª©c t·∫°p: $O(Q \times \alpha(N))$ - Ch·∫•p nh·∫≠n ƒë∆∞·ª£c

### B∆∞·ªõc 3: Thu·∫≠t to√°n Union-Find t·ªëi ∆∞u
```
1. Duy tr√¨ Union-Find cho c√°c th√†nh ph·∫ßn li√™n th√¥ng
2. V·ªõi m·ªói th√†nh ph·∫ßn, ƒë·∫øm s·ªë ƒë·ªânh ƒëen
3. Truy v·∫•n lo·∫°i 1: Union hai th√†nh ph·∫ßn
4. Truy v·∫•n lo·∫°i 2: C·∫≠p nh·∫≠t s·ªë ƒë·ªânh ƒëen
5. Truy v·∫•n lo·∫°i 3: Ki·ªÉm tra s·ªë ƒë·ªânh ƒëen trong th√†nh ph·∫ßn
```

---

## Gi·∫£i thu·∫≠t v√† ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

### Thu·∫≠t to√°n
```
1. Kh·ªüi t·∫°o Union-Find v·ªõi N ƒë·ªânh
2. M·∫£ng black_count[i] = s·ªë ƒë·ªânh ƒëen trong th√†nh ph·∫ßn i
3. X·ª≠ l√Ω t·ª´ng truy v·∫•n:
   - Lo·∫°i 1: Union(u, v), c·∫≠p nh·∫≠t black_count
   - Lo·∫°i 2: Flip m√†u v, c·∫≠p nh·∫≠t black_count
   - Lo·∫°i 3: Ki·ªÉm tra black_count[find(v)] > 0
```

### ƒê·ªô ph·ª©c t·∫°p
- **Th·ªùi gian**: $O(Q \times \alpha(N))$ - V·ªõi $\alpha$ l√† h√†m Ackermann ngh·ªãch ƒë·∫£o
- **B·ªô nh·ªõ**: $O(N)$ - L∆∞u Union-Find v√† black_count

---

## Code tham kh·∫£o

### C++
```cpp
#include <iostream>
#include <vector>
using namespace std;

class UnionFind {
public:
    vector<int> parent, rank;
    vector<int> black_count;
    vector<bool> is_black;
    
    UnionFind(int n) : parent(n), rank(n, 0), black_count(n, 0), is_black(n, false) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void unite(int x, int y) {
        int px = find(x);
        int py = find(y);
        
        if (px == py) return;
        
        if (rank[px] < rank[py]) {
            parent[px] = py;
            black_count[py] += black_count[px];
        } else if (rank[px] > rank[py]) {
            parent[py] = px;
            black_count[px] += black_count[py];
        } else {
            parent[py] = px;
            black_count[px] += black_count[py];
            rank[px]++;
        }
    }
    
    void toggle_color(int x) {
        int px = find(x);
        if (is_black[x]) {
            // Den -> Trang
            black_count[px]--;
            is_black[x] = false;
        } else {
            // Trang -> Den  
            black_count[px]++;
            is_black[x] = true;
        }
    }
    
    bool has_black(int x) {
        int px = find(x);
        return black_count[px] > 0;
    }
};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N, Q;
    cin >> N >> Q;
    
    UnionFind uf(N);
    
    for (int i = 0; i < Q; i++) {
        int type;
        cin >> type;
        
        if (type == 1) {
            int u, v;
            cin >> u >> v;
            u--; v--; // Chuyen ve 0-indexed
            uf.unite(u, v);
        } else if (type == 2) {
            int v;
            cin >> v;
            v--; // Chuyen ve 0-indexed
            uf.toggle_color(v);
        } else {
            int v;
            cin >> v;
            v--; // Chuyen ve 0-indexed
            if (uf.has_black(v)) {
                cout << "Yes\n";
            } else {
                cout << "No\n";
            }
        }
    }
    
    return 0;
}
```

### Python
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.black_count = [0] * n
        self.is_black = [False] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def unite(self, x, y):
        px = self.find(x)
        py = self.find(y)
        
        if px == py:
            return
        
        if self.rank[px] < self.rank[py]:
            self.parent[px] = py
            self.black_count[py] += self.black_count[px]
        elif self.rank[px] > self.rank[py]:
            self.parent[py] = px
            self.black_count[px] += self.black_count[py]
        else:
            self.parent[py] = px
            self.black_count[px] += self.black_count[py]
            self.rank[px] += 1
    
    def toggle_color(self, x):
        px = self.find(x)
        if self.is_black[x]:
            # Den -> Trang
            self.black_count[px] -= 1
            self.is_black[x] = False
        else:
            # Trang -> Den
            self.black_count[px] += 1
            self.is_black[x] = True
    
    def has_black(self, x):
        px = self.find(x)
        return self.black_count[px] > 0

# Nhap du lieu
N, Q = map(int, input().split())
uf = UnionFind(N)

for _ in range(Q):
    query = list(map(int, input().split()))
    
    if query[0] == 1:
        u, v = query[1] - 1, query[2] - 1  # Chuyen ve 0-indexed
        uf.unite(u, v)
    elif query[0] == 2:
        v = query[1] - 1  # Chuyen ve 0-indexed
        uf.toggle_color(v)
    else:
        v = query[1] - 1  # Chuyen ve 0-indexed
        if uf.has_black(v):
            print("Yes")
        else:
            print("No")
```

---

## B·ªô test ch·∫•m ƒëi·ªÉm

### Test cases ƒë·∫∑c bi·ªát
```
Test 1: Ch·ªâ c√≥ truy v·∫•n lo·∫°i 3 - kh√¥ng c√≥ ƒë·ªânh ƒëen
Test 2: Th√™m c·∫°nh r·ªìi ƒë·ªïi m√†u
Test 3: ƒê·ªì th·ªã kh√¥ng li√™n th√¥ng
Test 4: T·∫•t c·∫£ ƒë·ªânh c√πng th√†nh ph·∫ßn
Test 5: Toggle m√†u nhi·ªÅu l·∫ßn
Test 6: Truy v·∫•n li√™n ti·∫øp nhi·ªÅu lo·∫°i 3
```

### Subtask v√† ƒëi·ªÉm s·ªë

**Subtask 1** (20 ƒëi·ªÉm): $N, Q \leq 1000$  
- 8 test cases
- C√≥ th·ªÉ d√πng DFS/BFS naive

**Subtask 2** (30 ƒëi·ªÉm): Kh√¥ng c√≥ truy v·∫•n lo·∫°i 1
- 12 test cases  
- ƒê·ªì th·ªã kh√¥ng thay ƒë·ªïi

**Subtask 3** (50 ƒëi·ªÉm): Kh√¥ng r√†ng bu·ªôc th√™m
- 20 test cases
- C·∫ßn Union-Find t·ªëi ∆∞u

### Generator test t·ª± ƒë·ªông

#### C++
```cpp
#include <iostream>
#include <random>
#include <fstream>
#include <vector>
#include <set>
using namespace std;

class UnionFind {
public:
    vector<int> parent, rank, black_count;
    vector<bool> is_black;
    
    UnionFind(int n) : parent(n), rank(n, 0), black_count(n, 0), is_black(n, false) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void unite(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return;
        
        if (rank[px] < rank[py]) {
            parent[px] = py;
            black_count[py] += black_count[px];
        } else if (rank[px] > rank[py]) {
            parent[py] = px;
            black_count[px] += black_count[py];
        } else {
            parent[py] = px;
            black_count[px] += black_count[py];
            rank[px]++;
        }
    }
    
    void toggle_color(int x) {
        int px = find(x);
        if (is_black[x]) {
            black_count[px]--;
            is_black[x] = false;
        } else {
            black_count[px]++;
            is_black[x] = true;
        }
    }
    
    bool has_black(int x) {
        int px = find(x);
        return black_count[px] > 0;
    }
};

vector<string> solve(int N, vector<vector<int>>& queries) {
    UnionFind uf(N);
    vector<string> results;
    set<pair<int, int>> edges;
    
    for (auto& query : queries) {
        if (query[0] == 1) {
            int u = query[1] - 1, v = query[2] - 1;
            if (edges.find({min(u, v), max(u, v)}) == edges.end()) {
                edges.insert({min(u, v), max(u, v)});
                uf.unite(u, v);
            }
        } else if (query[0] == 2) {
            int v = query[1] - 1;
            uf.toggle_color(v);
        } else {
            int v = query[1] - 1;
            results.push_back(uf.has_black(v) ? "Yes" : "No");
        }
    }
    
    return results;
}

int main() {
    random_device rd;
    mt19937 gen(rd());
    
    for (int t = 1; t <= 40; t++) {
        ofstream input("input" + to_string(t) + ".txt");
        ofstream output("output" + to_string(t) + ".txt");
        
        int N, Q;
        if (t <= 8) {
            N = uniform_int_distribution<>(1, 1000)(gen);
            Q = uniform_int_distribution<>(1, 1000)(gen);
        } else if (t <= 20) {
            N = uniform_int_distribution<>(1, 10000)(gen);
            Q = uniform_int_distribution<>(1, 10000)(gen);
        } else {
            N = uniform_int_distribution<>(1, 200000)(gen);
            Q = uniform_int_distribution<>(1, 600000)(gen);
        }
        
        input << N << " " << Q << endl;
        
        vector<vector<int>> queries;
        set<pair<int, int>> used_edges;
        
        for (int i = 0; i < Q; i++) {
            int type;
            
            if (t > 8 && t <= 20) {
                // Subtask 2: khong co truy van loai 1
                type = uniform_int_distribution<>(2, 3)(gen);
            } else {
                type = uniform_int_distribution<>(1, 3)(gen);
            }
            
            if (type == 1) {
                // Dam bao cac canh hop le
                int attempts = 0;
                int u, v;
                do {
                    u = uniform_int_distribution<>(1, N)(gen);
                    v = uniform_int_distribution<>(1, N)(gen);
                    if (u > v) swap(u, v);
                    attempts++;
                } while ((u == v || used_edges.count({u, v})) && attempts < 100);
                
                if (attempts < 100) {
                    used_edges.insert({u, v});
                    input << "1 " << u << " " << v << endl;
                    queries.push_back({1, u, v});
                } else {
                    // Neu khong tim duoc canh hop le, chuyen sang loai khac
                    type = uniform_int_distribution<>(2, 3)(gen);
                    int v = uniform_int_distribution<>(1, N)(gen);
                    input << type << " " << v << endl;
                    queries.push_back({type, v});
                }
            } else {
                int v = uniform_int_distribution<>(1, N)(gen);
                input << type << " " << v << endl;
                queries.push_back({type, v});
            }
        }
        
        vector<string> results = solve(N, queries);
        for (const string& result : results) {
            output << result << endl;
        }
        
        input.close();
        output.close();
    }
    
    return 0;
}
```

#### Python
```python
import random

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.black_count = [0] * n
        self.is_black = [False] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def unite(self, x, y):
        px = self.find(x)
        py = self.find(y)
        if px == py:
            return
        
        if self.rank[px] < self.rank[py]:
            self.parent[px] = py
            self.black_count[py] += self.black_count[px]
        elif self.rank[px] > self.rank[py]:
            self.parent[py] = px
            self.black_count[px] += self.black_count[py]
        else:
            self.parent[py] = px
            self.black_count[px] += self.black_count[py]
            self.rank[px] += 1
    
    def toggle_color(self, x):
        px = self.find(x)
        if self.is_black[x]:
            self.black_count[px] -= 1
            self.is_black[x] = False
        else:
            self.black_count[px] += 1
            self.is_black[x] = True
    
    def has_black(self, x):
        px = self.find(x)
        return self.black_count[px] > 0

def solve(N, queries):
    uf = UnionFind(N)
    results = []
    used_edges = set()
    
    for query in queries:
        if query[0] == 1:
            u, v = query[1] - 1, query[2] - 1
            edge = (min(u, v), max(u, v))
            if edge not in used_edges:
                used_edges.add(edge)
                uf.unite(u, v)
        elif query[0] == 2:
            v = query[1] - 1
            uf.toggle_color(v)
        else:
            v = query[1] - 1
            results.append("Yes" if uf.has_black(v) else "No")
    
    return results

# Tao 40 test cases
for t in range(1, 41):
    if t <= 8:
        N = random.randint(1, 1000)
        Q = random.randint(1, 1000)
    elif t <= 20:
        N = random.randint(1, 10000)
        Q = random.randint(1, 10000)
    else:
        N = random.randint(1, 200000)
        Q = random.randint(1, 600000)
    
    queries = []
    used_edges = set()
    
    with open(f"input{t}.txt", "w") as f:
        f.write(f"{N} {Q}\n")
        
        for i in range(Q):
            if t > 8 and t <= 20:
                # Subtask 2: khong co truy van loai 1
                query_type = random.randint(2, 3)
            else:
                query_type = random.randint(1, 3)
            
            if query_type == 1:
                # Dam bao cac canh hop le
                attempts = 0
                while attempts < 100:
                    u = random.randint(1, N)
                    v = random.randint(1, N)
                    if u > v:
                        u, v = v, u
                    if u != v and (u, v) not in used_edges:
                        used_edges.add((u, v))
                        f.write(f"1 {u} {v}\n")
                        queries.append([1, u, v])
                        break
                    attempts += 1
                
                if attempts >= 100:
                    # Neu khong tim duoc canh hop le, chuyen sang loai khac
                    query_type = random.randint(2, 3)
                    v = random.randint(1, N)
                    f.write(f"{query_type} {v}\n")
                    queries.append([query_type, v])
            else:
                v = random.randint(1, N)
                f.write(f"{query_type} {v}\n")
                queries.append([query_type, v])
    
    results = solve(N, queries)
    
    with open(f"output{t}.txt", "w") as f:
        for result in results:
            f.write(f"{result}\n")
```

### Ch·∫•m ƒëi·ªÉm chi ti·∫øt
- **AC (Accepted)**: 450 ƒëi·ªÉm - Union-Find v·ªõi black counting ch√≠nh x√°c
- **WA (Wrong Answer)**: 0 ƒëi·ªÉm - Sai logic union ho·∫∑c ƒë·∫øm ƒë·ªânh ƒëen
- **TLE (Time Limit)**: 0 ƒëi·ªÉm - D√πng DFS/BFS naive v·ªõi d·ªØ li·ªáu l·ªõn
- **RE (Runtime Error)**: 0 ƒëi·ªÉm - L·ªói truy c·∫≠p ho·∫∑c stack overflow

---

## Approach kh√°c: DFS/BFS t·ª´ng truy v·∫•n

### Khi n√†o d√πng:
- $N, Q$ nh·ªè (‚â§ 1000)  
- C√†i ƒë·∫∑t ƒë∆°n gi·∫£n h∆°n Union-Find
- D·ªÖ debug v√† hi·ªÉu thu·∫≠t to√°n

### Code DFS approach:
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<vector<int>> adj;
vector<bool> is_black;
vector<bool> visited;

bool dfs(int v) {
    if (visited[v]) return false;
    visited[v] = true;
    
    if (is_black[v]) return true;
    
    for (int u : adj[v]) {
        if (dfs(u)) return true;
    }
    
    return false;
}

int main() {
    int N, Q;
    cin >> N >> Q;
    
    adj.resize(N);
    is_black.resize(N, false);
    
    for (int i = 0; i < Q; i++) {
        int type;
        cin >> type;
        
        if (type == 1) {
            int u, v;
            cin >> u >> v;
            u--; v--;
            adj[u].push_back(v);
            adj[v].push_back(u);
        } else if (type == 2) {
            int v;
            cin >> v;
            v--;
            is_black[v] = !is_black[v];
        } else {
            int v;
            cin >> v;
            v--;
            visited.assign(N, false);
            cout << (dfs(v) ? "Yes" : "No") << "\n";
        }
    }
    
    return 0;
}
```

---

## L∆∞u √Ω v√† m·∫πo

‚ö†Ô∏è **C√°c l·ªói th∆∞·ªùng g·∫∑p:**
1. Qu√™n c·∫≠p nh·∫≠t black_count khi union hai th√†nh ph·∫ßn
2. Sai logic path compression trong Union-Find
3. Kh√¥ng x·ª≠ l√Ω tr∆∞·ªùng h·ª£p c·∫°nh ƒë√£ t·ªìn t·∫°i
4. Nh·∫ßm l·∫´n gi·ªØa 0-indexed v√† 1-indexed

üí° **M·∫πo l√†m b√†i:**
1. V·∫Ω s∆° ƒë·ªì v·ªõi v√≠ d·ª• nh·ªè ƒë·ªÉ hi·ªÉu r√µ flow
2. Union-Find ph√π h·ª£p v·ªõi b√†i n√†y h∆°n DFS/BFS
3. Debug b·∫±ng c√°ch in ra parent v√† black_count
4. Test edge cases: ƒë·ªì th·ªã r·ªóng, t·∫•t c·∫£ ƒë·ªânh ƒëen

üîç **Ki·∫øn th·ª©c li√™n quan:**
- Union-Find (Disjoint Set Union)  
- Dynamic Connectivity
- Path Compression v√† Union by Rank
- Component-based queries

# B√†i F: kirinuki (C·∫Øt h√¨nh ch·ªØ nh·∫≠t)

## ƒê·ªÅ b√†i

**ƒêi·ªÉm s·ªë**: 550 ƒëi·ªÉm  
**Th·ªùi gian**: 2 gi√¢y  
**B·ªô nh·ªõ**: 1024 MiB

### M√¥ t·∫£ b√†i to√°n
Cho l∆∞·ªõi $N \times M$ v·ªõi c√°c k√Ω t·ª± `.` (tr·ªëng) v√† `#` (c√≥ v·∫≠t c·∫£n).

T√≠nh s·ªë l∆∞·ª£ng h√¨nh ch·ªØ nh·∫≠t c√≥ kh√¥ng qu√° $K$ √¥ m√† t·∫•t c·∫£ c√°c √¥ trong ƒë√≥ ƒë·ªÅu l√† `.`.

Ch√≠nh x√°c h∆°n, ƒë·∫øm s·ªë b·ªô $(l_x, r_x, l_y, r_y)$ th·ªèa m√£n:
- $1 \leq l_x \leq r_x \leq N$
- $1 \leq l_y \leq r_y \leq M$  
- $(r_x - l_x + 1) \times (r_y - l_y + 1) \leq K$
- T·∫•t c·∫£ √¥ $(i, j)$ v·ªõi $l_x \leq i \leq r_x$ v√† $l_y \leq j \leq r_y$ ƒë·ªÅu l√† `.`

### R√†ng bu·ªôc
- $1 \leq N, M \leq 5 \times 10^5$
- $1 \leq N \times M \leq 5 \times 10^6$  
- $1 \leq K \leq N \times M$

### D·ªØ li·ªáu v√†o
```
N M K
S_1
S_2
...
S_N
```

### D·ªØ li·ªáu ra
In ra s·ªë l∆∞·ª£ng h√¨nh ch·ªØ nh·∫≠t h·ª£p l·ªá.

### V√≠ d·ª•

**V√≠ d·ª• 1:**
```
V√†o:
3 3 4
#..
...
..#

Ra: 19
```

**V√≠ d·ª• 2:**
```
V√†o:  
7 5 35
.....
.....
.....
.....
.....
.....
.....

Ra: 420
```

---

## H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n b√†i to√°n

### B∆∞·ªõc 1: Hi·ªÉu b√†i to√°n
üí° **Ph√¢n t√≠ch**: ƒê√¢y l√† b√†i to√°n ƒë·∫øm s·ªë h√¨nh ch·ªØ nh·∫≠t con th·ªèa m√£n ƒëi·ªÅu ki·ªán.

**Y√™u c·∫ßu:**
1. H√¨nh ch·ªØ nh·∫≠t c√≥ di·ªán t√≠ch ‚â§ $K$
2. T·∫•t c·∫£ √¥ trong h√¨nh ch·ªØ nh·∫≠t ƒë·ªÅu l√† `.`

### B∆∞·ªõc 2: Ph∆∞∆°ng ph√°p ti·∫øp c·∫≠n

**Approach 1: Brute Force**
- Duy·ªát t·∫•t c·∫£ $(l_x, r_x, l_y, r_y)$  
- Ki·ªÉm tra ƒëi·ªÅu ki·ªán cho m·ªói h√¨nh ch·ªØ nh·∫≠t
- ƒê·ªô ph·ª©c t·∫°p: $O(N^2 M^2 NM)$ - Qu√° ch·∫≠m

**Approach 2: Prefix Sum + Optimization**
- D√πng prefix sum ƒë·ªÉ ki·ªÉm tra nhanh s·ªë √¥ `#`
- T·ªëi ∆∞u v·ªõi constraint v·ªÅ di·ªán t√≠ch
- ƒê·ªô ph·ª©c t·∫°p: $O(N^2 M^2)$ - V·∫´n ch·∫≠m v·ªõi $N, M$ l·ªõn

**Approach 3: Height-based + Two Pointers**
- V·ªõi m·ªói h√†ng bottom, t√≠nh height c·ªßa t·ª´ng c·ªôt  
- D√πng thu·∫≠t to√°n ƒë·∫øm h√¨nh ch·ªØ nh·∫≠t v·ªõi di·ªán t√≠ch ‚â§ $K$
- ƒê·ªô ph·ª©c t·∫°p: $O(NM \times \min(N, K))$

### B∆∞·ªõc 3: Thu·∫≠t to√°n t·ªëi ∆∞u

S·ª≠ d·ª•ng **histogram-based approach**:
```
1. V·ªõi m·ªói h√†ng l√†m ƒë√°y (bottom):
   - T√≠nh height[j] = s·ªë h√†ng li√™n ti·∫øp c√≥ '.' k·∫øt th√∫c t·∫°i (bottom, j)
2. V·ªõi m·ªói height array:
   - ƒê·∫øm s·ªë h√¨nh ch·ªØ nh·∫≠t c√≥ di·ªán t√≠ch ‚â§ K trong histogram
3. C·ªông t·∫•t c·∫£ k·∫øt qu·∫£
```

---

## Gi·∫£i thu·∫≠t v√† ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

### Thu·∫≠t to√°n chi ti·∫øt
```
1. Kh·ªüi t·∫°o height[M] = 0
2. V·ªõi m·ªói h√†ng i t·ª´ 0 ƒë·∫øn N-1:
   a. C·∫≠p nh·∫≠t height[j]:
      - N·∫øu grid[i][j] == '.': height[j]++
      - N·∫øu grid[i][j] == '#': height[j] = 0
   b. G·ªçi count_rectangles(height, K) ƒë·ªÉ ƒë·∫øm
3. Tr·∫£ v·ªÅ t·ªïng
```

### H√†m count_rectangles(height, K):
```
1. V·ªõi m·ªói c·ªôt left t·ª´ 0 ƒë·∫øn M-1:
   a. min_height = height[left]
   b. V·ªõi m·ªói c·ªôt right t·ª´ left ƒë·∫øn M-1:
      - min_height = min(min_height, height[right])  
      - width = right - left + 1
      - max_allowed_height = K / width
      - actual_height = min(min_height, max_allowed_height)
      - count += actual_height
2. Tr·∫£ v·ªÅ count
```

### ƒê·ªô ph·ª©c t·∫°p
- **Th·ªùi gian**: $O(N \times M^2)$ - V·ªõi m·ªói h√†ng, duy·ªát $O(M^2)$ h√¨nh ch·ªØ nh·∫≠t
- **B·ªô nh·ªõ**: $O(M)$ - L∆∞u m·∫£ng height

---

## Code tham kh·∫£o

### C++
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

long long count_rectangles(vector<int>& height, int K) {
    int M = height.size();
    long long count = 0;
    
    for (int left = 0; left < M; left++) {
        int min_height = height[left];
        for (int right = left; right < M; right++) {
            min_height = min(min_height, height[right]);
            int width = right - left + 1;
            
            if (min_height == 0) break; // Khong the tao hinh chu nhat
            
            int max_allowed_height = K / width;
            int actual_height = min(min_height, max_allowed_height);
            
            if (actual_height > 0) {
                count += actual_height;
            }
        }
    }
    
    return count;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N, M, K;
    cin >> N >> M >> K;
    
    vector<string> grid(N);
    for (int i = 0; i < N; i++) {
        cin >> grid[i];
    }
    
    vector<int> height(M, 0);
    long long total_count = 0;
    
    for (int i = 0; i < N; i++) {
        // Cap nhat height cho hang hien tai
        for (int j = 0; j < M; j++) {
            if (grid[i][j] == '.') {
                height[j]++;
            } else {
                height[j] = 0;
            }
        }
        
        // Dem hinh chu nhat ket thuc tai hang i
        total_count += count_rectangles(height, K);
    }
    
    cout << total_count << endl;
    
    return 0;
}
```

### Python
```python
def count_rectangles(height, K):
    M = len(height)
    count = 0
    
    for left in range(M):
        min_height = height[left]
        for right in range(left, M):
            min_height = min(min_height, height[right])
            width = right - left + 1
            
            if min_height == 0:
                break  # Khong the tao hinh chu nhat
            
            max_allowed_height = K // width
            actual_height = min(min_height, max_allowed_height)
            
            if actual_height > 0:
                count += actual_height
    
    return count

# Nhap du lieu
N, M, K = map(int, input().split())
grid = []
for i in range(N):
    grid.append(input().strip())

height = [0] * M
total_count = 0

for i in range(N):
    # Cap nhat height cho hang hien tai
    for j in range(M):
        if grid[i][j] == '.':
            height[j] += 1
        else:
            height[j] = 0
    
    # Dem hinh chu nhat ket thuc tai hang i
    total_count += count_rectangles(height, K)

print(total_count)
```

---

## T·ªëi ∆∞u h√≥a n√¢ng cao

### Approach v·ªõi Stack (cho b√†i kh√≥ h∆°n):
```cpp
long long count_rectangles_optimized(vector<int>& height, int K) {
    int M = height.size();
    long long count = 0;
    vector<int> stack;
    
    for (int i = 0; i <= M; i++) {
        int h = (i == M) ? 0 : height[i];
        
        while (!stack.empty() && height[stack.back()] > h) {
            int height_idx = stack.back();
            stack.pop_back();
            
            int width = stack.empty() ? i : i - stack.back() - 1;
            int rect_height = height[height_idx];
            
            // Tinh so hinh chu nhat voi chieu cao rect_height
            for (int w = 1; w <= width && w * rect_height <= K; w++) {
                int max_h = K / w;
                int actual_h = min(rect_height, max_h);
                count += (long long)(width - w + 1) * actual_h;
            }
        }
        
        if (i < M) stack.push_back(i);
    }
    
    return count;
}
```

---

## B·ªô test ch·∫•m ƒëi·ªÉm

### Test cases ƒë·∫∑c bi·ªát
```
Test 1: T·∫•t c·∫£ √¥ l√† '.' - c√¥ng th·ª©c t·ªï h·ª£p
Test 2: T·∫•t c·∫£ √¥ l√† '#' - k·∫øt qu·∫£ = 0  
Test 3: K = 1 - ch·ªâ ƒë·∫øm √¥ ƒë∆°n l·∫ª
Test 4: K = N*M - kh√¥ng gi·ªõi h·∫°n di·ªán t√≠ch
Test 5: B√†n c·ªù xen k·∫Ω '.' v√† '#'
Test 6: L∆∞·ªõi d·∫°ng h√†ng/c·ªôt
```

### Subtask v√† ƒëi·ªÉm s·ªë

**Subtask 1** (20 ƒëi·ªÉm): $N, M \leq 50$
- 8 test cases
- C√≥ th·ªÉ brute force $O(N^2 M^2)$

**Subtask 2** (30 ƒëi·ªÉm): $N \leq 500, M \leq 500$  
- 12 test cases
- C·∫ßn thu·∫≠t to√°n $O(N M^2)$

**Subtask 3** (50 ƒëi·ªÉm): Kh√¥ng r√†ng bu·ªôc th√™m
- 20 test cases  
- C·∫ßn t·ªëi ∆∞u v·ªõi $N \times M \leq 5 \times 10^6$

### Generator test t·ª± ƒë·ªông

#### C++
```cpp
#include <iostream>
#include <random>
#include <fstream>
#include <vector>
#include <string>
using namespace std;

long long solve(vector<string>& grid, int N, int M, int K) {
    vector<int> height(M, 0);
    long long total = 0;
    
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (grid[i][j] == '.') {
                height[j]++;
            } else {
                height[j] = 0;
            }
        }
        
        // Dem hinh chu nhat
        for (int left = 0; left < M; left++) {
            int min_height = height[left];
            for (int right = left; right < M; right++) {
                min_height = min(min_height, height[right]);
                if (min_height == 0) break;
                
                int width = right - left + 1;
                int max_height = K / width;
                int actual_height = min(min_height, max_height);
                
                if (actual_height > 0) {
                    total += actual_height;
                }
            }
        }
    }
    
    return total;
}

int main() {
    random_device rd;
    mt19937 gen(rd());
    
    for (int t = 1; t <= 40; t++) {
        ofstream input("input" + to_string(t) + ".txt");
        ofstream output("output" + to_string(t) + ".txt");
        
        int N, M, K;
        if (t <= 8) {
            N = uniform_int_distribution<>(1, 50)(gen);
            M = uniform_int_distribution<>(1, 50)(gen);
        } else if (t <= 20) {
            N = uniform_int_distribution<>(1, 500)(gen);
            M = uniform_int_distribution<>(1, 500)(gen);
        } else {
            // Dam bao N * M <= 5 * 10^6
            long long total = uniform_int_distribution<long long>(1, 5000000)(gen);
            N = uniform_int_distribution<>(1, min((long long)500000, total))(gen);
            M = total / N;
            if (M == 0) M = 1;
        }
        
        K = uniform_int_distribution<>(1, N * M)(gen);
        
        input << N << " " << M << " " << K << endl;
        
        vector<string> grid(N);
        uniform_real_distribution<> prob(0.0, 1.0);
        double empty_prob = 0.7; // 70% o trong
        
        for (int i = 0; i < N; i++) {
            grid[i] = "";
            for (int j = 0; j < M; j++) {
                if (prob(gen) < empty_prob) {
                    grid[i] += '.';
                } else {
                    grid[i] += '#';
                }
            }
            input << grid[i] << endl;
        }
        
        long long result = solve(grid, N, M, K);
        output << result << endl;
        
        input.close();
        output.close();
    }
    
    return 0;
}
```

#### Python  
```python
import random

def solve(grid, N, M, K):
    height = [0] * M
    total = 0
    
    for i in range(N):
        for j in range(M):
            if grid[i][j] == '.':
                height[j] += 1
            else:
                height[j] = 0
        
        # Dem hinh chu nhat
        for left in range(M):
            min_height = height[left]
            for right in range(left, M):
                min_height = min(min_height, height[right])
                if min_height == 0:
                    break
                
                width = right - left + 1
                max_height = K // width
                actual_height = min(min_height, max_height)
                
                if actual_height > 0:
                    total += actual_height
    
    return total

# Tao 40 test cases
for t in range(1, 41):
    if t <= 8:
        N = random.randint(1, 50)
        M = random.randint(1, 50)
    elif t <= 20:
        N = random.randint(1, 500) 
        M = random.randint(1, 500)
    else:
        # Dam bao N * M <= 5 * 10^6
        total = random.randint(1, 5000000)
        N = random.randint(1, min(500000, total))
        M = total // N
        if M == 0:
            M = 1
    
    K = random.randint(1, N * M)
    
    grid = []
    empty_prob = 0.7  # 70% o trong
    
    for i in range(N):
        row = ""
        for j in range(M):
            if random.random() < empty_prob:
                row += '.'
            else:
                row += '#'
        grid.append(row)
    
    with open(f"input{t}.txt", "w") as f:
        f.write(f"{N} {M} {K}\n")
        for row in grid:
            f.write(f"{row}\n")
    
    result = solve(grid, N, M, K)
    
    with open(f"output{t}.txt", "w") as f:
        f.write(f"{result}\n")
```

### Ch·∫•m ƒëi·ªÉm chi ti·∫øt
- **AC (Accepted)**: 550 ƒëi·ªÉm - Histogram-based approach ch√≠nh x√°c
- **WA (Wrong Answer)**: 0 ƒëi·ªÉm - Sai logic ƒë·∫øm ho·∫∑c ƒëi·ªÅu ki·ªán di·ªán t√≠ch
- **TLE (Time Limit)**: 0 ƒëi·ªÉm - Brute force $O(N^2 M^2 NM)$ v·ªõi d·ªØ li·ªáu l·ªõn  
- **MLE (Memory Limit)**: 0 ƒëi·ªÉm - L∆∞u qu√° nhi·ªÅu d·ªØ li·ªáu kh√¥ng c·∫ßn thi·∫øt

---

## Ph√¢n t√≠ch chi ti·∫øt thu·∫≠t to√°n

### T·∫°i sao d√πng Histogram approach?

**Insight ch√≠nh:** M·ªói h√¨nh ch·ªØ nh·∫≠t c√≥ th·ªÉ ƒë∆∞·ª£c x√°c ƒë·ªãnh b·ªüi:
- H√†ng ƒë√°y (bottom row)  
- C·ªôt tr√°i v√† ph·∫£i (left, right columns)
- Chi·ªÅu cao b·ªã gi·ªõi h·∫°n b·ªüi √¥ `#` g·∫ßn nh·∫•t

**V√≠ d·ª• minh h·ªça:**
```
Grid:
#..
...
..#

V·ªõi h√†ng 1 l√†m ƒë√°y:
height = [0, 1, 1]
C√≥ th·ªÉ t·∫°o h√¨nh ch·ªØ nh·∫≠t:
- (1,1) v·ªõi height=1: 1 c√°ch  
- (1,2) v·ªõi height=1: 1 c√°ch
- (1,1)-(1,2) v·ªõi height=1: 1 c√°ch

V·ªõi h√†ng 2 l√†m ƒë√°y:  
height = [0, 2, 2]
C√≥ th·ªÉ t·∫°o th√™m nhi·ªÅu h√¨nh ch·ªØ nh·∫≠t...
```

### T·ªëi ∆∞u h√≥a th√™m

**Pruning s·ªõm:**
```cpp
if (width > K) break; // Chi·ªÅu r·ªông ƒë√£ v∆∞·ª£t qu√° K
if (min_height == 0) break; // Kh√¥ng th·ªÉ t·∫°o h√¨nh ch·ªØ nh·∫≠t
```

**Precompute:**
```cpp
vector<int> max_width_for_height(N + 1);
for (int h = 1; h <= N; h++) {
    max_width_for_height[h] = K / h;
}
```

---

## B√†i to√°n m·ªü r·ªông v√† bi·∫øn th·ªÉ

### Bi·∫øn th·ªÉ 1: ƒê·∫øm h√¨nh vu√¥ng
Ch·ªâ c·∫ßn thay ƒëi·ªÅu ki·ªán di·ªán t√≠ch b·∫±ng `width == height`.

### Bi·∫øn th·ªÉ 2: Minimum/Maximum area constraint  
Th√™m ƒëi·ªÅu ki·ªán `area >= L` v√† `area <= K`.

### Bi·∫øn th·ªÉ 3: Weighted rectangles
M·ªói √¥ c√≥ tr·ªçng s·ªë, t√≠nh t·ªïng tr·ªçng s·ªë thay v√¨ di·ªán t√≠ch.

---

## L∆∞u √Ω v√† m·∫πo

‚ö†Ô∏è **C√°c l·ªói th∆∞·ªùng g·∫∑p:**
1. Qu√™n reset `height[j] = 0` khi g·∫∑p √¥ `#`
2. T√≠nh sai di·ªán t√≠ch ho·∫∑c ƒëi·ªÅu ki·ªán $\leq K$  
3. Overflow v·ªõi `long long` - t·ªïng c√≥ th·ªÉ r·∫•t l·ªõn
4. Thu·∫≠t to√°n brute force v·ªõi complexity cao

üí° **M·∫πo l√†m b√†i:**
1. V·∫Ω v√≠ d·ª• nh·ªè ƒë·ªÉ hi·ªÉu histogram approach
2. Debug b·∫±ng c√°ch in ra `height` array m·ªói h√†ng
3. Ki·ªÉm tra edge cases: K=1, to√†n `.`, to√†n `#`
4. T·ªëi ∆∞u v·ªõi early termination khi `width > K`

üîç **Ki·∫øn th·ª©c li√™n quan:**
- Largest Rectangle in Histogram
- Dynamic Programming on rectangles  
- Prefix Sum for 2D arrays
- Combinatorics v·ªõi r√†ng bu·ªôc

### C√¥ng th·ª©c to√°n h·ªçc h·ªó tr·ª£

**Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát - to√†n √¥ tr·ªëng:**
S·ªë h√¨nh ch·ªØ nh·∫≠t $(w, h)$ v·ªõi $w \times h \leq K$:
$\sum_{w=1}^{M} \sum_{h=1}^{min(N, \lfloor K/w \rfloor)} (N-h+1)(M-w+1)$

**Optimization insight:**
V·ªõi m·ªói chi·ªÅu r·ªông $w$, chi·ªÅu cao t·ªëi ƒëa l√† $\lfloor K/w \rfloor$.

---

## Test cases ƒë·∫∑c bi·ªát ƒë·ªÉ debug

### Test 1: Grid ƒë∆°n gi·∫£n
```
Input:
2 2 2
..
..

Expected: 6
(c√°c h√¨nh ch·ªØ nh·∫≠t 1x1: 4 c√°i, 1x2: 2 c√°i, 2x1: 2 c√°i, t·ªïng = 8)
Th·ª±c t·∫ø: 6 (do 2x2 c√≥ di·ªán t√≠ch 4 > 2)
```

### Test 2: C√≥ v·∫≠t c·∫£n
```
Input:  
2 3 3
..#
...

Expected: 8
(Ph√¢n t√≠ch t·ª´ng h√†ng l√†m ƒë√°y)
```

### Test 3: K = 1
```
Input:
2 2 1
..
.#

Expected: 3  
(Ch·ªâ ƒë·∫øm √¥ ƒë∆°n l·∫ª c√≥ '.')
```


# B√†i G: sqrt(n¬≤+n+X) (CƒÉn b·∫≠c hai nguy√™n)

## ƒê·ªÅ b√†i

**ƒêi·ªÉm s·ªë**: 575 ƒëi·ªÉm  
**Th·ªùi gian**: 2 gi√¢y  
**B·ªô nh·ªõ**: 1024 MiB

### M√¥ t·∫£ b√†i to√°n
Cho s·ªë nguy√™n $X$.

T√¨m t·∫•t c·∫£ s·ªë nguy√™n $n$ sao cho $\sqrt{n^2 + n + X}$ l√† s·ªë nguy√™n.

### R√†ng bu·ªôc
- $-10^{14} \leq X \leq 10^{14}$

### D·ªØ li·ªáu v√†o
```
X
```

### D·ªØ li·ªáu ra
G·ªçi $N_1, N_2, \ldots, N_K$ l√† c√°c s·ªë nguy√™n $n$ th·ªèa m√£n ƒëi·ªÅu ki·ªán, s·∫Øp x·∫øp tƒÉng d·∫ßn.
```
K
N_1 N_2 ... N_K
```

### V√≠ d·ª•

**V√≠ d·ª• 1:**
```
V√†o: 4
Ra: 
4
-4 -1 0 3
```

**V√≠ d·ª• 2:**  
```
V√†o: -10000
Ra:
8
-10001 -773 -593 -101 100 592 772 10000
```

---

## H∆∞·ªõng d·∫´n ti·∫øp c·∫≠n b√†i to√°n

### B∆∞·ªõc 1: Hi·ªÉu b√†i to√°n
üí° **Ph√¢n t√≠ch**: C·∫ßn t√¨m $n$ sao cho $n^2 + n + X = k^2$ v·ªõi $k$ nguy√™n.

**Bi·∫øn ƒë·ªïi:** $n^2 + n + X = k^2$
$\Leftrightarrow 4n^2 + 4n + 4X = 4k^2$
$\Leftrightarrow (2n + 1)^2 + 4X - 1 = 4k^2$
$\Leftrightarrow (2n + 1)^2 - 4k^2 = 1 - 4X$
$\Leftrightarrow (2n + 1)^2 - (2k)^2 = 1 - 4X$

### B∆∞·ªõc 2: Ph√¢n t√≠ch s·ªë h·ªçc
ƒê·∫∑t $a = 2n + 1, b = 2k$, ta c√≥:
$a^2 - b^2 = 1 - 4X$
$(a - b)(a + b) = 1 - 4X$

**ƒêi·ªÅu ki·ªán:**
- $a$ l·∫ª (v√¨ $a = 2n + 1$)
- $b$ ch·∫µn (v√¨ $b = 2k$)
- $a^2 - b^2 = 1 - 4X$

### B∆∞·ªõc 3: T√¨m ∆∞·ªõc c·ªßa $(1 - 4X)$
G·ªçi $D = 1 - 4X$, c·∫ßn t√¨m c√°c c·∫∑p $(d_1, d_2)$ sao cho:
- $d_1 \times d_2 = D$
- $a = \frac{d_1 + d_2}{2}$, $b = \frac{d_2 - d_1}{2}$
- $a$ l·∫ª, $b$ ch·∫µn

**ƒêi·ªÅu ki·ªán t∆∞∆°ng ƒë∆∞∆°ng:**
- $d_1 + d_2$ ch·∫µn v√† $d_2 - d_1$ chia h·∫øt cho 4
- Hay $d_1 \equiv d_2 \pmod{4}$ ho·∫∑c $d_1 \equiv d_2 + 2 \pmod{4}$

---

## Gi·∫£i thu·∫≠t v√† ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

### Thu·∫≠t to√°n
```
1. T√≠nh D = 1 - 4X
2. T√¨m t·∫•t c·∫£ ∆∞·ªõc c·ªßa D
3. V·ªõi m·ªói c·∫∑p ∆∞·ªõc (d1, d2) v·ªõi d1 * d2 = D:
   a. Ki·ªÉm tra ƒëi·ªÅu ki·ªán d1 ‚â° d2 (mod 4)
   b. T√≠nh a = (d1 + d2)/2, b = (d2 - d1)/2  
   c. Ki·ªÉm tra a l·∫ª, b ch·∫µn
   d. T√≠nh n = (a - 1)/2
   e. Th√™m n v√†o k·∫øt qu·∫£
4. Lo·∫°i b·ªè tr√πng l·∫∑p v√† s·∫Øp x·∫øp
```

### T·ªëi ∆∞u t√¨m ∆∞·ªõc s·ªë:
```cpp
vector<long long> get_divisors(long long D) {
    vector<long long> divisors;
    if (D == 0) return divisors;
    
    for (long long d = 1; d * d <= abs(D); d++) {
        if (D % d == 0) {
            divisors.push_back(d);
            divisors.push_back(-d);
            if (d != abs(D) / d) {
                divisors.push_back(D / d);
                divisors.push_back(-D / d);
            }
        }
    }
    return divisors;
}
```

### ƒê·ªô ph·ª©c t·∫°p
- **Th·ªùi gian**: $O(\sqrt{|D|})$ - T√¨m ∆∞·ªõc c·ªßa $D = 1 - 4X$
- **B·ªô nh·ªõ**: $O(\sqrt{|D|})$ - L∆∞u danh s√°ch ∆∞·ªõc

---

## Code tham kh·∫£o

### C++
```cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

vector<long long> get_divisors(long long D) {
    vector<long long> divisors;
    if (D == 0) return divisors;
    
    long long abs_D = abs(D);
    for (long long d = 1; d * d <= abs_D; d++) {
        if (abs_D % d == 0) {
            divisors.push_back(d);
            divisors.push_back(-d);
            if (d * d != abs_D) {
                divisors.push_back(D / d);
                divisors.push_back(-D / d);
            }
        }
    }
    return divisors;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    long long X;
    cin >> X;
    
    long long D = 1 - 4 * X;
    vector<long long> divisors = get_divisors(D);
    
    set<long long> solutions;
    
    // Thu tat ca cap uoc (d1, d2) voi d1 * d2 = D
    for (long long d1 : divisors) {
        if (d1 == 0) continue;
        long long d2 = D / d1;
        
        // Kiem tra dieu kien d1 ‚â° d2 (mod 4)
        if ((d1 % 4) != (d2 % 4)) continue;
        
        // Tinh a, b
        if ((d1 + d2) % 2 != 0) continue; // a phai nguyen
        long long a = (d1 + d2) / 2;
        long long b = (d2 - d1) / 2;
        
        // Kiem tra a le, b chan
        if (a % 2 == 0) continue; // a phai le
        if (b % 2 != 0) continue; // b phai chan
        
        // Tinh n
        long long n = (a - 1) / 2;
        solutions.insert(n);
    }
    
    // Chuyen thanh vector va sap xep
    vector<long long> result(solutions.begin(), solutions.end());
    
    cout << result.size() << endl;
    for (int i = 0; i < result.size(); i++) {
        if (i > 0) cout << " ";
        cout << result[i];
    }
    if (!result.empty()) cout << endl;
    
    return 0;
}
```

### Python
```python
def get_divisors(D):
    divisors = []
    if D == 0:
        return divisors
    
    abs_D = abs(D)
    d = 1
    while d * d <= abs_D:
        if abs_D % d == 0:
            divisors.extend([d, -d])
            if d * d != abs_D:
                divisors.extend([D // d, -D // d])
        d += 1
    
    return divisors

# Nhap du lieu
X = int(input())

D = 1 - 4 * X
divisors = get_divisors(D)

solutions = set()

# Thu tat ca cap uoc (d1, d2) voi d1 * d2 = D
for d1 in divisors:
    if d1 == 0:
        continue
    d2 = D // d1
    
    # Kiem tra dieu kien d1 ‚â° d2 (mod 4)
    if (d1 % 4) != (d2 % 4):
        continue
    
    # Tinh a, b
    if (d1 + d2) % 2 != 0:
        continue  # a phai nguyen
    a = (d1 + d2) // 2
    b = (d2 - d1) // 2
    
    # Kiem tra a le, b chan
    if a % 2 == 0:
        continue  # a phai le
    if b % 2 != 0:
        continue  # b phai chan
    
    # Tinh n
    n = (a - 1) // 2
    solutions.add(n)

# Chuyen thanh list va sap xep
result = sorted(list(solutions))

print(len(result))
if result:
    print(*result)
```

---

## Ph√¢n t√≠ch to√°n h·ªçc s√¢u h∆°n

### T·∫°i sao ƒëi·ªÅu ki·ªán $d_1 \equiv d_2 \pmod{4}$?

**Gi·∫£i th√≠ch:**
- $a = \frac{d_1 + d_2}{2}$ ph·∫£i l·∫ª
- $b = \frac{d_2 - d_1}{2}$ ph·∫£i ch·∫µn

ƒê·ªÉ $a$ l·∫ª: $d_1 + d_2 \equiv 2 \pmod{4}$
ƒê·ªÉ $b$ ch·∫µn: $d_2 - d_1 \equiv 0 \pmod{4}$

T·ª´ ƒëi·ªÅu ki·ªán th·ª© 2: $d_2 \equiv d_1 \pmod{4}$
Thay v√†o ƒëi·ªÅu ki·ªán th·ª© 1: $2d_1 \equiv 2 \pmod{4}$, nghƒ©a l√† $d_1 \equiv 1 \pmod{2}$

### S·ªë l∆∞·ª£ng nghi·ªám

**ƒê·ªãnh l√Ω:** V·ªõi $D = 1 - 4X$:
- N·∫øu $D > 0$: c√≥ $O(\sqrt{D})$ nghi·ªám
- N·∫øu $D < 0$: c√≥ √≠t nghi·ªám (th∆∞·ªùng ‚â§ 8)
- N·∫øu $D = 0$: tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát

### Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát $D = 0$:
$D = 0 \Leftrightarrow X = \frac{1}{4}$ (kh√¥ng nguy√™n v·ªõi r√†ng bu·ªôc ƒë·ªÅ b√†i)

---

## B·ªô test ch·∫•m ƒëi·ªÉm

### Test cases ƒë·∫∑c bi·ªát
```
Test 1: X = 0 ‚Üí D = 1, √≠t nghi·ªám
Test 2: X d∆∞∆°ng l·ªõn ‚Üí D √¢m, √≠t nghi·ªám  
Test 3: X √¢m l·ªõn ‚Üí D d∆∞∆°ng l·ªõn, nhi·ªÅu nghi·ªám
Test 4: X = 1/4 ‚Üí D = 0 (kh√¥ng x·∫£y ra v·ªõi X nguy√™n)
Test 5: X = -10^14 ‚Üí D ‚âà 4√ó10^14
```

### Subtask v√† ƒëi·ªÉm s·ªë

**Subtask 1** (25 ƒëi·ªÉm): $|X| \leq 10^6$
- 10 test cases
- $D$ nh·ªè, c√≥ th·ªÉ brute force

**Subtask 2** (35 ƒëi·ªÉm): $|X| \leq 10^{10}$
- 14 test cases
- C·∫ßn thu·∫≠t to√°n t·ªëi ∆∞u

**Subtask 3** (40 ƒëi·ªÉm): Kh√¥ng r√†ng bu·ªôc th√™m  
- 16 test cases
- $|X| \leq 10^{14}$, c·∫ßn x·ª≠ l√Ω s·ªë l·ªõn

### Generator test t·ª± ƒë·ªông

#### C++
```cpp
#include <iostream>
#include <random>
#include <fstream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

// Ham giai chinh xac
vector<long long> solve(long long X) {
    long long D = 1 - 4 * X;
    set<long long> solutions;
    
    if (D == 0) return vector<long long>(solutions.begin(), solutions.end());
    
    long long abs_D = abs(D);
    for (long long d = 1; d * d <= abs_D; d++) {
        if (abs_D % d == 0) {
            vector<long long> divisors = {d, -d};
            if (d * d != abs_D) {
                divisors.push_back(D / d);
                divisors.push_back(-D / d);
            }
            
            for (long long d1 : divisors) {
                long long d2 = D / d1;
                
                if ((d1 % 4) != (d2 % 4)) continue;
                if ((d1 + d2) % 2 != 0) continue;
                
                long long a = (d1 + d2) / 2;
                long long b = (d2 - d1) / 2;
                
                if (a % 2 == 0 || b % 2 != 0) continue;
                
                long long n = (a - 1) / 2;
                solutions.insert(n);
            }
        }
    }
    
    return vector<long long>(solutions.begin(), solutions.end());
}

int main() {
    random_device rd;
    mt19937_64 gen(rd());
    
    for (int t = 1; t <= 40; t++) {
        ofstream input("input" + to_string(t) + ".txt");
        ofstream output("output" + to_string(t) + ".txt");
        
        long long X;
        if (t <= 10) {
            X = uniform_int_distribution<long long>(-1000000, 1000000)(gen);
        } else if (t <= 24) {
            X = uniform_int_distribution<long long>(-10000000000LL, 10000000000LL)(gen);
        } else {
            X = uniform_int_distribution<long long>(-100000000000000LL, 100000000000000LL)(gen);
        }
        
        input << X << endl;
        
        vector<long long> result = solve(X);
        
        output << result.size() << endl;
        for (int i = 0; i < result.size(); i++) {
            if (i > 0) output << " ";
            output << result[i];
        }
        if (!result.empty()) output << endl;
        
        input.close();
        output.close();
    }
    
    return 0;
}
```

#### Python
```python
import random

def solve(X):
    D = 1 - 4 * X
    solutions = set()
    
    if D == 0:
        return sorted(list(solutions))
    
    abs_D = abs(D)
    d = 1
    while d * d <= abs_D:
        if abs_D % d == 0:
            divisors = [d, -d]
            if d * d != abs_D:
                divisors.extend([D // d, -D // d])
            
            for d1 in divisors:
                d2 = D // d1
                
                if (d1 % 4) != (d2 % 4):
                    continue
                if (d1 + d2) % 2 != 0:
                    continue
                
                a = (d1 + d2) // 2
                b = (d2 - d1) // 2
                
                if a % 2 == 0 or b % 2 != 0:
                    continue
                
                n = (a - 1) // 2
                solutions.add(n)
        d += 1
    
    return sorted(list(solutions))

# Tao 40 test cases
for t in range(1, 41):
    if t <= 10:
        X = random.randint(-1000000, 1000000)
    elif t <= 24:
        X = random.randint(-10**10, 10**10)
    else:
        X = random.randint(-10**14, 10**14)
    
    with open(f"input{t}.txt", "w") as f:
        f.write(f"{X}\n")
    
    result = solve(X)
    
    with open(f"output{t}.txt", "w") as f:
        f.write(f"{len(result)}\n")
        if result:
            f.write(" ".join(map(str, result)) + "\n")
```

### Ch·∫•m ƒëi·ªÉm chi ti·∫øt
- **AC (Accepted)**: 575 ƒëi·ªÉm - T√¨m ∆∞·ªõc v√† ƒëi·ªÅu ki·ªán modular ch√≠nh x√°c
- **WA (Wrong Answer)**: 0 ƒëi·ªÉm - Sai ƒëi·ªÅu ki·ªán $d_1 \equiv d_2 \pmod{4}$ ho·∫∑c logic t√¨m ∆∞·ªõc
- **TLE (Time Limit)**: 0 ƒëi·ªÉm - Brute force $O(|D|)$ v·ªõi $|D|$ l·ªõn
- **RE (Runtime Error)**: 0 ƒëi·ªÉm - Overflow ho·∫∑c chia cho 0

---

## L∆∞u √Ω v√† m·∫πo

‚ö†Ô∏è **C√°c l·ªói th∆∞·ªùng g·∫∑p:**
1. Qu√™n tr∆∞·ªùng h·ª£p $D < 0$ - c·∫ßn x·ª≠ l√Ω ∆∞·ªõc √¢m
2. Sai ƒëi·ªÅu ki·ªán modular: $d_1 \equiv d_2 \pmod{4}$
3. Overflow khi t√≠nh $1 - 4X$ v·ªõi $X = -10^{14}$
4. Kh√¥ng lo·∫°i b·ªè ∆∞·ªõc tr√πng l·∫∑p khi $d^2 = |D|$

üí° **M·∫πo l√†m b√†i:**
1. Ki·ªÉm tra k·ªπ v·ªõi v√≠ d·ª• nh·ªè: $X = 4$
2. S·ª≠ d·ª•ng `long long` cho t·∫•t c·∫£ t√≠nh to√°n
3. Debug b·∫±ng c√°ch in ra t·∫•t c·∫£ c·∫∑p $(d_1, d_2)$ h·ª£p l·ªá
4. Ki·ªÉm tra ƒëi·ªÅu ki·ªán $a$ l·∫ª, $b$ ch·∫µn ri√™ng bi·ªát

üîç **Ki·∫øn th·ª©c li√™n quan:**
- Ph∆∞∆°ng tr√¨nh Pell v√† bi·∫øn th·ªÉ
- Ph√¢n t√≠ch ∆∞·ªõc s·ªë (Divisor enumeration)
- Modular arithmetic
- Quadratic forms $ax^2 + bxy + cy^2$

# T·ªïng k·∫øt AtCoder Beginner Contest 420

## Nh·∫≠n x√©t v·ªÅ t·ª´ng b√†i

### **B√†i A - What month is it? (100 ƒëi·ªÉm)**
**ƒê·ªô kh√≥**: ‚òÖ‚òÜ‚òÜ‚òÜ‚òÜ  
**K·ªπ nƒÉng**: Modular arithmetic c∆° b·∫£n

**ƒêi·ªÉm m·∫°nh:**
- B√†i kh·ªüi ƒë·ªông t·ªët, d·ªÖ hi·ªÉu
- R√®n luy·ªán k·ªπ nƒÉng chuy·ªÉn ƒë·ªïi 0-indexed ‚Üî 1-indexed
- Th·ªùi gian l√†m b√†i: 2-3 ph√∫t

**L∆∞u √Ω:** C√¥ng th·ª©c `(X + Y - 1) % 12 + 1` c·∫ßn nh·ªõ cho c√°c b√†i t∆∞∆°ng t·ª±.

---

### **B√†i B - Most Minority (200 ƒëi·ªÉm)**
**ƒê·ªô kh√≥**: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ  
**K·ªπ nƒÉng**: Simulation, x·ª≠ l√Ω chu·ªói

**ƒêi·ªÉm m·∫°nh:**
- R√®n luy·ªán k·ªπ nƒÉng ƒë·ªçc hi·ªÉu ƒë·ªÅ ph·ª©c t·∫°p
- M√¥ ph·ªèng c√°c quy t·∫Øc logic
- X·ª≠ l√Ω nhi·ªÅu tr∆∞·ªùng h·ª£p ƒëi·ªÅu ki·ªán

**Th√°ch th·ª©c:**
- Quy t·∫Øc trao ƒëi·ªÉm kh√° ph·ª©c t·∫°p
- C·∫ßn c·∫©n th·∫≠n v·ªõi tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát ($x = 0$ ho·∫∑c $y = 0$)
- Th·ªùi gian l√†m b√†i: 8-12 ph√∫t

---

### **B√†i C - Sum of Min Query (300 ƒëi·ªÉm)**
**ƒê·ªô kh√≥**: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ  
**K·ªπ nƒÉng**: Point update, t·ªëi ∆∞u h√≥a

**ƒêi·ªÉm m·∫°nh:**
- D·∫°ng b√†i c∆° b·∫£n v·ªÅ c·∫≠p nh·∫≠t v√† truy v·∫•n
- H·ªçc c√°ch t·ªëi ∆∞u t·ª´ $O(QN)$ xu·ªëng $O(Q)$
- K·ªπ thu·∫≠t maintain state thay v√¨ t√≠nh l·∫°i to√†n b·ªô

**Th√°ch th·ª©c:**
- C√≥ th·ªÉ b·∫´y h·ªçc sinh v·ªõi approach naive
- C·∫ßn ch√∫ √Ω overflow v·ªõi `long long`
- Th·ªùi gian l√†m b√†i: 10-15 ph√∫t

---

### **B√†i D - Toggle Maze (400 ƒëi·ªÉm)**
**ƒê·ªô kh√≥**: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ  
**K·ªπ nƒÉng**: BFS v·ªõi state space, graph traversal

**ƒêi·ªÉm m·∫°nh:**
- B√†i BFS n√¢ng cao v·ªõi multiple states
- R√®n luy·ªán k·ªπ nƒÉng m√¥ h√¨nh h√≥a state space
- Toggle mechanism th√∫ v·ªã v√† th·ª±c t·∫ø

**Th√°ch th·ª©c:**
- State space $(r, c, door\_state)$ kh√¥ng d·ªÖ nh·∫≠n ra
- Logic toggle c·ª≠a c√≥ th·ªÉ g√¢y nh·∫ßm l·∫´n
- C·∫ßn c·∫©n th·∫≠n v·ªõi visited array 3 chi·ªÅu
- Th·ªùi gian l√†m b√†i: 20-30 ph√∫t

---

### **B√†i E - Reachability Query (450 ƒëi·ªÉm)**
**ƒê·ªô kh√≥**: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ  
**K·ªπ nƒÉng**: Union-Find, dynamic connectivity

**
