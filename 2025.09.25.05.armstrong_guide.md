# CHUYÊN ĐỀ: SỐ ARMSTRONG (ARMSTRONG NUMBERS)
## Dành cho học sinh lớp 10 Chuyên Tin

---

## 1. ĐỊNH NGHĨA VÀ KHÁI NIỆM CƠ BẢN

### 1.1. Định nghĩa số Armstrong
**Số Armstrong** (hay còn gọi là số Narcissistic) là số nguyên dương n có k chữ số thỏa mãn:
```
n = a₁ᵏ + a₂ᵏ + a₃ᵏ + ... + aₖᵏ
```
Trong đó a₁, a₂, a₃, ..., aₖ là các chữ số của n.

### 1.2. Công thức tổng quát
Cho số n có k chữ số: d₁d₂d₃...dₖ
```
Số Armstrong ⟺ n = d₁ᵏ + d₂ᵏ + d₃ᵏ + ... + dₖᵏ
```

### 1.3. Minh họa bằng sơ đồ

```
Kiểm tra 153 có phải số Armstrong?

153 có 3 chữ số: 1, 5, 3

┌─────────────────────────────────────┐
│  Bước 1: Đếm số chữ số k = 3        │
│  Bước 2: Tính từng lũy thừa:        │
│     1³ = 1 × 1 × 1 = 1              │
│     5³ = 5 × 5 × 5 = 125             │
│     3³ = 3 × 3 × 3 = 27              │
│  Bước 3: Tính tổng:                 │
│     1 + 125 + 27 = 153              │
│  Bước 4: So sánh:                   │
│     153 = 153 ✓                     │
│  ⟹ 153 là số Armstrong              │
└─────────────────────────────────────┘
```

## 2. CÁC VÍ DỤ MINH HỌA

### Ví dụ 1: Kiểm tra 153
- **Input**: n = 153
- **Phân tích**: 153 có 3 chữ số: 1, 5, 3
- **Tính toán**: 1³ + 5³ + 3³ = 1 + 125 + 27 = 153
- **Kết quả**: 153 = 153 → **TRUE** (là số Armstrong)

### Ví dụ 2: Kiểm tra 9474
- **Input**: n = 9474  
- **Phân tích**: 9474 có 4 chữ số: 9, 4, 7, 4
- **Tính toán**: 9⁴ + 4⁴ + 7⁴ + 4⁴ = 6561 + 256 + 2401 + 256 = 9474
- **Kết quả**: 9474 = 9474 → **TRUE** (là số Armstrong)

### Ví dụ 3: Kiểm tra 123
- **Input**: n = 123
- **Phân tích**: 123 có 3 chữ số: 1, 2, 3
- **Tính toán**: 1³ + 2³ + 3³ = 1 + 8 + 27 = 36
- **Kết quả**: 36 ≠ 123 → **FALSE** (không phải số Armstrong)

## 3. DANH SÁCH MỘT SỐ ARMSTRONG ĐẦU TIÊN

### 3.1. Số Armstrong 1 chữ số
```
1 = 1¹ = 1 ✓
2 = 2¹ = 2 ✓
3 = 3¹ = 3 ✓
4 = 4¹ = 4 ✓
5 = 5¹ = 5 ✓
6 = 6¹ = 6 ✓
7 = 7¹ = 7 ✓
8 = 8¹ = 8 ✓
9 = 9¹ = 9 ✓
```

### 3.2. Số Armstrong 3 chữ số
```
153 = 1³ + 5³ + 3³ = 1 + 125 + 27 = 153 ✓
371 = 3³ + 7³ + 1³ = 27 + 343 + 1 = 371 ✓
407 = 4³ + 0³ + 7³ = 64 + 0 + 343 = 407 ✓
```

### 3.3. Số Armstrong 4 chữ số
```
1634 = 1⁴ + 6⁴ + 3⁴ + 4⁴ = 1 + 1296 + 81 + 256 = 1634 ✓
8208 = 8⁴ + 2⁴ + 0⁴ + 8⁴ = 4096 + 16 + 0 + 4096 = 8208 ✓
9474 = 9⁴ + 4⁴ + 7⁴ + 4⁴ = 6561 + 256 + 2401 + 256 = 9474 ✓
```

## 4. PHƯƠNG PHÁP 1: THUẬT TOÁN CƠ BẢN

### 4.1. Các bước thuật toán

#### 4.1.1. Sơ đồ thuật toán
```
┌─────────────────┐
│   Bắt đầu       │
└─────┬───────────┘
      │
┌─────▼───────────┐
│   Nhập số n     │
└─────┬───────────┘
      │
┌─────▼───────────┐
│ Đếm số chữ số k │
│ của n           │
└─────┬───────────┘
      │
┌─────▼───────────┐
│ temp = n        │
│ sum = 0         │
└─────┬───────────┘
      │
┌─────▼───────────┐
│   temp > 0?     │◄─────┐
└─────┬───────────┘      │
      │ Yes              │
┌─────▼───────────┐      │
│ digit = temp%10 │      │
│ sum += digit^k  │      │
│ temp = temp/10  │──────┘
└─────────────────┘
      │ No
┌─────▼───────────┐
│   sum == n?     │
└─────┬───────────┘
      │
┌─────▼───────────┐
│ Xuất kết quả    │
└─────┬───────────┘
      │
┌─────▼───────────┐
│   Kết thúc      │
└─────────────────┘
```

### 4.2. Code mẫu phương pháp cơ bản

**C++:**
```cpp
#include <iostream>
#include <cmath>
using namespace std;

// Hàm tính lũy thừa (có thể dùng pow() thay thế)
int power(int base, int exp) {
    if (exp == 0) return 1;
    if (exp % 2 == 0) {
        int half = power(base, exp / 2);
        return half * half;
    }
    return base * power(base, exp - 1);
}

// Hàm đếm số chữ số
int countDigits(int n) {
    int count = 0;
    while (n > 0) {
        count++;
        n /= 10;
    }
    return count;
}

// Hàm kiểm tra số Armstrong
bool isArmstrong(int n) {
    int originalNum = n;
    int numDigits = countDigits(n);
    int sum = 0;
    
    // Tính tổng các lũy thừa
    while (n > 0) {
        int digit = n % 10;
        sum += power(digit, numDigits);
        n /= 10;
    }
    
    return sum == originalNum;
}

// Hàm demo chi tiết
void demonstrateArmstrong(int n) {
    cout << "\n=== DEMO KIEM TRA " << n << " ===" << endl;
    
    int originalNum = n;
    int numDigits = countDigits(n);
    int sum = 0;
    
    cout << "So chu so: " << numDigits << endl;
    cout << "Cac chu so va luy thua:" << endl;
    
    // Lưu các chữ số để hiển thị
    int temp = n;
    int digits[10], digitCount = 0;
    while (temp > 0) {
        digits[digitCount] = temp % 10;
        temp /= 10;
        digitCount++;
    }
    
    // Tính và hiển thị từng bước
    for (int i = digitCount - 1; i >= 0; i--) {
        int digitPower = power(digits[i], numDigits);
        cout << "  " << digits[i] << "^" << numDigits << " = " << digitPower << endl;
        sum += digitPower;
    }
    
    cout << "Tong = " << sum << endl;
    cout << "Ket qua: " << sum << (sum == originalNum ? " = " : " ≠ ") << originalNum;
    cout << " => " << (sum == originalNum ? "LA" : "KHONG PHAI") << " so Armstrong" << endl;
}

int main() {
    int n;
    cout << "Nhap so can kiem tra: ";
    cin >> n;
    
    if (isArmstrong(n)) {
        cout << n << " la so Armstrong" << endl;
    } else {
        cout << n << " khong phai la so Armstrong" << endl;
    }
    
    // Demo chi tiết
    demonstrateArmstrong(n);
    
    return 0;
}
```

**Python:**
```python
def power(base, exp):
    """Tính lũy thừa bằng đệ quy"""
    if exp == 0:
        return 1
    if exp % 2 == 0:
        half = power(base, exp // 2)
        return half * half
    return base * power(base, exp - 1)

def count_digits(n):
    """Đếm số chữ số"""
    count = 0
    while n > 0:
        count += 1
        n //= 10
    return count

def is_armstrong(n):
    """Kiểm tra số Armstrong"""
    original_num = n
    num_digits = count_digits(n)
    sum_powers = 0
    
    # Tính tổng các lũy thừa
    while n > 0:
        digit = n % 10
        sum_powers += power(digit, num_digits)
        n //= 10
    
    return sum_powers == original_num

def demonstrate_armstrong(n):
    """Demo chi tiết quá trình kiểm tra"""
    print(f"\n=== DEMO KIỂM TRA {n} ===")
    
    original_num = n
    num_digits = count_digits(n)
    sum_powers = 0
    
    print(f"Số chữ số: {num_digits}")
    print("Các chữ số và lũy thừa:")
    
    # Lấy các chữ số
    digits = []
    temp = n
    while temp > 0:
        digits.append(temp % 10)
        temp //= 10
    digits.reverse()
    
    # Tính và hiển thị từng bước
    for digit in digits:
        digit_power = power(digit, num_digits)
        print(f"  {digit}^{num_digits} = {digit_power}")
        sum_powers += digit_power
    
    print(f"Tổng = {sum_powers}")
    print(f"Kết quả: {sum_powers} {'=' if sum_powers == original_num else '≠'} {original_num}")
    print(f"=> {'LÀ' if sum_powers == original_num else 'KHÔNG PHẢI'} số Armstrong")

def main():
    n = int(input("Nhập số cần kiểm tra: "))
    
    if is_armstrong(n):
        print(f"{n} là số Armstrong")
    else:
        print(f"{n} không phải là số Armstrong")
    
    # Demo chi tiết
    demonstrate_armstrong(n)

if __name__ == "__main__":
    main()
```

### 4.3. Phân tích độ phức tạp
- **Thời gian**: O(d × log d), với d là số chữ số
- **Không gian**: O(1)

## 5. PHƯƠNG PHÁP 2: SỬ DỤNG CHUỖI (STRING)

### 5.1. Ý tưởng
Chuyển số thành chuỗi để dễ dàng truy cập từng chữ số và đếm số lượng chữ số.

### 5.2. Code mẫu sử dụng string

**C++:**
```cpp
#include <iostream>
#include <string>
#include <cmath>
using namespace std;

bool isArmstrongString(int n) {
    // Chuyển số thành chuỗi
    string numStr = to_string(n);
    int numDigits = numStr.length();
    int sum = 0;
    
    // Duyệt qua từng ký tự
    for (char c : numStr) {
        int digit = c - '0';  // Chuyển char thành int
        sum += (int)pow(digit, numDigits);
    }
    
    return sum == n;
}

void demonstrateStringMethod(int n) {
    cout << "\n=== DEMO PHUONG PHAP STRING CHO " << n << " ===" << endl;
    
    string numStr = to_string(n);
    int numDigits = numStr.length();
    int sum = 0;
    
    cout << "Chuoi: \"" << numStr << "\"" << endl;
    cout << "So chu so: " << numDigits << endl;
    cout << "Tinh toan:" << endl;
    
    for (int i = 0; i < numStr.length(); i++) {
        int digit = numStr[i] - '0';
        int digitPower = (int)pow(digit, numDigits);
        cout << "  numStr[" << i << "] = '" << numStr[i] << "' -> " 
             << digit << "^" << numDigits << " = " << digitPower << endl;
        sum += digitPower;
    }
    
    cout << "Tong = " << sum << endl;
    cout << "Ket qua: " << (sum == n ? "Armstrong" : "Khong phai Armstrong") << endl;
}

int main() {
    int n;
    cout << "Nhap so: ";
    cin >> n;
    
    if (isArmstrongString(n)) {
        cout << n << " la so Armstrong (String method)" << endl;
    } else {
        cout << n << " khong phai la so Armstrong (String method)" << endl;
    }
    
    demonstrateStringMethod(n);
    
    return 0;
}
```

**Python:**
```python
def is_armstrong_string(n):
    """Kiểm tra Armstrong bằng phương pháp string"""
    # Chuyển số thành chuỗi
    num_str = str(n)
    num_digits = len(num_str)
    sum_powers = 0
    
    # Duyệt qua từng ký tự
    for char in num_str:
        digit = int(char)  # Chuyển char thành int
        sum_powers += digit ** num_digits
    
    return sum_powers == n

def demonstrate_string_method(n):
    """Demo phương pháp string"""
    print(f"\n=== DEMO PHƯƠNG PHÁP STRING CHO {n} ===")
    
    num_str = str(n)
    num_digits = len(num_str)
    sum_powers = 0
    
    print(f"Chuỗi: \"{num_str}\"")
    print(f"Số chữ số: {num_digits}")
    print("Tính toán:")
    
    for i, char in enumerate(num_str):
        digit = int(char)
        digit_power = digit ** num_digits
        print(f"  num_str[{i}] = '{char}' -> {digit}^{num_digits} = {digit_power}")
        sum_powers += digit_power
    
    print(f"Tổng = {sum_powers}")
    print(f"Kết quả: {'Armstrong' if sum_powers == n else 'Không phải Armstrong'}")

def main():
    n = int(input("Nhập số: "))
    
    if is_armstrong_string(n):
        print(f"{n} là số Armstrong (String method)")
    else:
        print(f"{n} không phải là số Armstrong (String method)")
    
    demonstrate_string_method(n)

if __name__ == "__main__":
    main()
```

### 5.3. Ưu nhược điểm phương pháp string
#### Ưu điểm:
- Dễ hiểu và implement
- Truy cập chữ số trực tiếp
- Tính số chữ số đơn giản

#### Nhược điểm:
- Tốn bộ nhớ cho string
- Chậm hơn phương pháp số học

## 6. TÌM TẤT CẢ SỐ ARMSTRONG TRONG KHOẢNG

### 6.1. Code tìm tất cả số Armstrong

**C++:**
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

class ArmstrongFinder {
private:
    int power(int base, int exp) {
        if (exp == 0) return 1;
        if (exp % 2 == 0) {
            int half = power(base, exp / 2);
            return half * half;
        }
        return base * power(base, exp - 1);
    }
    
    int countDigits(int n) {
        int count = 0;
        while (n > 0) {
            count++;
            n /= 10;
        }
        return count;
    }
    
public:
    bool isArmstrong(int n) {
        int originalNum = n;
        int numDigits = countDigits(n);
        int sum = 0;
        
        while (n > 0) {
            int digit = n % 10;
            sum += power(digit, numDigits);
            n /= 10;
        }
        
        return sum == originalNum;
    }
    
    vector<int> findArmstrongInRange(int start, int end) {
        vector<int> armstrongNumbers;
        
        for (int i = start; i <= end; i++) {
            if (isArmstrong(i)) {
                armstrongNumbers.push_back(i);
            }
        }
        
        return armstrongNumbers;
    }
    
    void displayArmstrongByDigits(int maxDigits) {
        cout << "\n=== SO ARMSTRONG THEO SO CHU SO ===" << endl;
        
        for (int digits = 1; digits <= maxDigits; digits++) {
            cout << "\nSo Armstrong " << digits << " chu so:" << endl;
            
            int start = (digits == 1) ? 1 : power(10, digits - 1);
            int end = power(10, digits) - 1;
            
            vector<int> numbers = findArmstrongInRange(start, end);
            
            if (numbers.empty()) {
                cout << "  Khong co" << endl;
            } else {
                cout << "  ";
                for (int i = 0; i < numbers.size(); i++) {
                    cout << numbers[i];
                    if (i < numbers.size() - 1) cout << ", ";
                }
                cout << endl;
            }
        }
    }
};

int main() {
    ArmstrongFinder finder;
    
    int choice;
    cout << "Chon chuc nang:" << endl;
    cout << "1. Kiem tra 1 so" << endl;
    cout << "2. Tim trong khoang" << endl;
    cout << "3. Hien thi theo so chu so" << endl;
    cout << "Lua chon: ";
    cin >> choice;
    
    switch (choice) {
        case 1: {
            int n;
            cout << "Nhap so: ";
            cin >> n;
            
            if (finder.isArmstrong(n)) {
                cout << n << " la so Armstrong" << endl;
            } else {
                cout << n << " khong phai la so Armstrong" << endl;
            }
            break;
        }
        
        case 2: {
            int start, end;
            cout << "Nhap khoang [start, end]: ";
            cin >> start >> end;
            
            vector<int> results = finder.findArmstrongInRange(start, end);
            
            cout << "So Armstrong trong khoang [" << start << ", " << end << "]:" << endl;
            if (results.empty()) {
                cout << "Khong co so Armstrong nao" << endl;
            } else {
                for (int num : results) {
                    cout << num << " ";
                }
                cout << endl;
            }
            break;
        }
        
        case 3: {
            int maxDigits;
            cout << "Nhap so chu so toi da: ";
            cin >> maxDigits;
            
            finder.displayArmstrongByDigits(maxDigits);
            break;
        }
        
        default:
            cout << "Lua chon khong hop le!" << endl;
    }
    
    return 0;
}
```

**Python:**
```python
class ArmstrongFinder:
    def power(self, base, exp):
        """Tính lũy thừa"""
        if exp == 0:
            return 1
        if exp % 2 == 0:
            half = self.power(base, exp // 2)
            return half * half
        return base * self.power(base, exp - 1)
    
    def count_digits(self, n):
        """Đếm số chữ số"""
        count = 0
        while n > 0:
            count += 1
            n //= 10
        return count
    
    def is_armstrong(self, n):
        """Kiểm tra số Armstrong"""
        original_num = n
        num_digits = self.count_digits(n)
        sum_powers = 0
        
        while n > 0:
            digit = n % 10
            sum_powers += self.power(digit, num_digits)
            n //= 10
        
        return sum_powers == original_num
    
    def find_armstrong_in_range(self, start, end):
        """Tìm tất cả số Armstrong trong khoảng"""
        armstrong_numbers = []
        
        for i in range(start, end + 1):
            if self.is_armstrong(i):
                armstrong_numbers.append(i)
        
        return armstrong_numbers
    
    def display_armstrong_by_digits(self, max_digits):
        """Hiển thị số Armstrong theo số chữ số"""
        print("\n=== SỐ ARMSTRONG THEO SỐ CHỮ SỐ ===")
        
        for digits in range(1, max_digits + 1):
            print(f"\nSố Armstrong {digits} chữ số:")
            
            start = 1 if digits == 1 else 10 ** (digits - 1)
            end = 10 ** digits - 1
            
            numbers = self.find_armstrong_in_range(start, end)
            
            if not numbers:
                print("  Không có")
            else:
                print(f"  {', '.join(map(str, numbers))}")

def main():
    finder = ArmstrongFinder()
    
    print("Chọn chức năng:")
    print("1. Kiểm tra 1 số")
    print("2. Tìm trong khoảng")
    print("3. Hiển thị theo số chữ số")
    choice = int(input("Lựa chọn: "))
    
    if choice == 1:
        n = int(input("Nhập số: "))
        
        if finder.is_armstrong(n):
            print(f"{n} là số Armstrong")
        else:
            print(f"{n} không phải là số Armstrong")
    
    elif choice == 2:
        start = int(input("Nhập start: "))
        end = int(input("Nhập end: "))
        
        results = finder.find_armstrong_in_range(start, end)
        
        print(f"Số Armstrong trong khoảng [{start}, {end}]:")
        if not results:
            print("Không có số Armstrong nào")
        else:
            print(" ".join(map(str, results)))
    
    elif choice == 3:
        max_digits = int(input("Nhập số chữ số tối đa: "))
        finder.display_armstrong_by_digits(max_digits)
    
    else:
        print("Lựa chọn không hợp lệ!")

if __name__ == "__main__":
    main()
```

## 7. BÀI TẬP THỰC HÀNH

### Bài tập 1 (Cơ bản)
Viết chương trình kiểm tra một số có phải là số Armstrong hay không.

### Bài tập 2 (Nâng cao)
Tìm tất cả số Armstrong có 3 chữ số (từ 100 đến 999).

### Bài tập 3 (Ứng dụng)
Viết chương trình đếm số lượng số Armstrong trong khoảng [A, B].

### Bài tập 4 (Thử thách)
Tìm số Armstrong lớn nhất có n chữ số.

### Bài tập 5 (Tư duy)
Chứng minh rằng không có số Armstrong nào có 2 chữ số.

## 8. GỢI Ý GIẢI BÀI TẬP

### Bài tập 1:
```cpp
// Sử dụng hàm isArmstrong() đã viết
bool result = isArmstrong(n);
```

### Bài tập 2:
```python
def find_3_digit_armstrong():
    result = []
    for i in range(100, 1000):
        if is_armstrong(i):
            result.append(i)
    return result
```

### Bài tập 3:
```cpp
int countArmstrongInRange(int A, int B) {
    int count = 0;
    for (int i = A; i <= B; i++) {
        if (isArmstrong(i)) {
            count++;
        }
    }
    return count;
}
```

### Bài tập 5:
```
Chứng minh: Không có số Armstrong 2 chữ số

Số 2 chữ số có dạng: ab = 10a + b (1 ≤ a ≤ 9, 0 ≤ b ≤ 9)

Để là Armstrong: 10a + b = a² + b²
⟺ 10a + b - a² - b² = 0
⟺ a(10 - a) + b(1 - b) = 0

Vì a ≥ 1 nên 10 - a ≤ 9, do đó a(10 - a) ≤ 9a
Vì b ≤ 9 nên 1 - b ≥ -8, do đó b(1 - b) ≥ -8b

Không tồn tại a, b thỏa mãn phương trình trên.
```

## 9. CÁC SỐ ARMSTRONG ĐẶC BIỆT

### 9.1. Số Armstrong nhỏ nhất theo chữ số
```
1 chữ số: 1
3 chữ số: 153
4 chữ số: 1634
5 chữ số: 54748
6 chữ số: 548834
```

### 9.2. Tính chất đặc biệt
- Không có số Armstrong 2 chữ số
- Số Armstrong lớn nhất: 9,474,073 (7 chữ số)
- Tổng cộng có 88 số Armstrong

### 9.3. Ứng dụng
- Kiểm tra tính toàn vẹn dữ liệu
- Bài toán số học giải trí
- Nghiên cứu lý thuyết số

## 10. SO SÁNH CÁC PHƯƠNG PHÁP

| Phương pháp | Ưu điểm | Nhược điểm | Độ phức tạp |
|------------|---------|-----------|------------|
| **Số học cơ bản** | Hiệu quả, ít bộ nhớ | Code phức tạp hơn | O(d × log d) |
| **Sử dụng string** | Dễ hiểu, trực quan | Tốn bộ nhớ, chậm hơn | O(d × log d) |
| **Sử dụng pow()** | Ngắn gọn | Có thể sai số floating | O(d × log d) |

## 11. TỐI ỨU HÓA VÀ CẢI TIẾN

### 11.1. Tối ưu hóa tính lũy thừa
```cpp
// Thay vì dùng pow() có thể sai số
int fastPower(int base, int exp) {
    int result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result *= base;
        }
        base *= base;
        exp /= 2;
    }
    return result;
}
```

### 11.2. Precompute lũy thừa
```python
def precompute_powers(max_digits):
    """Tính trước các lũy thừa để tối ưu"""
    powers = {}
    for digit in range(10):  # 0-9
        for exp in range(1, max_digits + 1):
            powers[(digit, exp)] = digit ** exp
    return powers

def is_armstrong_optimized(n, powers):
    """Kiểm tra Armstrong với lũy thừa đã tính trước"""
    num_str = str(n)
    num_digits = len(num_str)
    
    sum_powers = sum(powers[(int(char), num_digits)] for char in num_str)
    return sum_powers == n
```

### 11.3. Kiểm tra sớm (Early termination)
```cpp
bool isArmstrongEarlyStop(int n) {
    int originalNum = n;
    int numDigits = countDigits(n);
    int sum = 0;
    
    while (n > 0) {
        int digit = n % 10;
        sum += power(digit, numDigits);
        
        // Kiểm tra sớm - nếu sum đã vượt quá originalNum
        if (sum > originalNum) {
            return false;
        }
        
        n /= 10;
    }
    
    return sum == originalNum;
}
```

## 12. CÁC BIẾN THỂ CỦA SỐ ARMSTRONG

### 12.1. Số Perfect Digital Invariant (PDI)
Tương tự Armstrong nhưng với lũy thừa cố định:
```
153 = 1³ + 5³ + 3³ (PDI bậc 3)
8208 = 8⁴ + 2⁴ + 0⁴ + 8⁴ (PDI bậc 4)
```

### 12.2. Số Munchausen
Mỗi chữ số được lũy thừa chính nó:
```
3435 = 3³ + 4⁴ + 3³ + 5⁵
```

### 12.3. Số Kaprekar
```cpp
bool isKaprekar(int n) {
    int square = n * n;
    string sqStr = to_string(square);
    int len = sqStr.length();
    
    for (int i = 1; i < len; i++) {
        int left = stoi(sqStr.substr(0, i));
        int right = stoi(sqStr.substr(i));
        
        if (right > 0 && left + right == n) {
            return true;
        }
    }
    return false;
}
```

## 13. CHƯƠNG TRÌNH TỔNG HỢP

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <chrono>
using namespace std;
using namespace chrono;

class ComprehensiveArmstrong {
private:
    // Cache để lưu kết quả lũy thừa
    int powerCache[10][10]; // powerCache[digit][exp]
    
public:
    ComprehensiveArmstrong() {
        // Khởi tạo cache lũy thừa
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                powerCache[i][j] = (int)pow(i, j);
            }
        }
    }
    
    bool isArmstrongBasic(int n) {
        // Phương pháp cơ bản
        return checkArmstrong(n, false);
    }
    
    bool isArmstrongOptimized(int n) {
        // Phương pháp tối ưu với cache
        return checkArmstrong(n, true);
    }
    
private:
    bool checkArmstrong(int n, bool useCache) {
        int originalNum = n;
        int numDigits = countDigits(n);
        int sum = 0;
        
        while (n > 0) {
            int digit = n % 10;
            
            if (useCache && numDigits < 10) {
                sum += powerCache[digit][numDigits];
            } else {
                sum += (int)pow(digit, numDigits);
            }
            
            // Early termination
            if (sum > originalNum) {
                return false;
            }
            
            n /= 10;
        }
        
        return sum == originalNum;
    }
    
    int countDigits(int n) {
        int count = 0;
        while (n > 0) {
            count++;
            n /= 10;
        }
        return count;
    }
    
public:
    void benchmarkMethods(int n) {
        cout << "\n=== BENCHMARK CHUONG TRINH ===" << endl;
        
        // Test phương pháp cơ bản
        auto start = high_resolution_clock::now();
        bool result1 = isArmstrongBasic(n);
        auto end = high_resolution_clock::now();
        auto time1 = duration_cast<microseconds>(end - start);
        
        cout << "Phuong phap co ban:  " << result1 << " (" << time1.count() << " μs)" << endl;
        
        // Test phương pháp tối ưu
        start = high_resolution_clock::now();
        bool result2 = isArmstrongOptimized(n);
        end = high_resolution_clock::now();
        auto time2 = duration_cast<microseconds>(end - start);
        
        cout << "Phuong phap toi uu: " << result2 << " (" << time2.count() << " μs)" << endl;
    }
    
    void findAllArmstrong(int maxDigits) {
        cout << "\n=== TIM TAT CA SO ARMSTRONG ===" << endl;
        
        for (int digits = 1; digits <= maxDigits; digits++) {
            cout << "\n" << digits << " chu so:" << endl;
            
            int start = (digits == 1) ? 1 : (int)pow(10, digits - 1);
            int end = (int)pow(10, digits) - 1;
            
            vector<int> found;
            for (int i = start; i <= end; i++) {
                if (isArmstrongOptimized(i)) {
                    found.push_back(i);
                }
            }
            
            if (found.empty()) {
                cout << "  Khong co" << endl;
            } else {
                cout << "  ";
                for (int i = 0; i < found.size(); i++) {
                    cout << found[i];
                    if (i < found.size() - 1) cout << ", ";
                }
                cout << endl;
            }
        }
    }
};

int main() {
    ComprehensiveArmstrong armstrong;
    
    cout << "CHUONG TRINH TONG HOP SO ARMSTRONG" << endl;
    cout << "=================================" << endl;
    
    int choice;
    do {
        cout << "\nMenu:" << endl;
        cout << "1. Kiem tra 1 so" << endl;
        cout << "2. Benchmark phuong phap" << endl;
        cout << "3. Tim tat ca Armstrong" << endl;
        cout << "0. Thoat" << endl;
        cout << "Lua chon: ";
        cin >> choice;
        
        switch (choice) {
            case 1: {
                int n;
                cout << "Nhap so: ";
                cin >> n;
                
                if (armstrong.isArmstrongOptimized(n)) {
                    cout << n << " la so Armstrong" << endl;
                } else {
                    cout << n << " khong phai la so Armstrong" << endl;
                }
                break;
            }
            
            case 2: {
                int n;
                cout << "Nhap so de benchmark: ";
                cin >> n;
                armstrong.benchmarkMethods(n);
                break;
            }
            
            case 3: {
                int maxDigits;
                cout << "Nhap so chu so toi da: ";
                cin >> maxDigits;
                armstrong.findAllArmstrong(maxDigits);
                break;
            }
            
            case 0:
                cout << "Tam biet!" << endl;
                break;
                
            default:
                cout << "Lua chon khong hop le!" << endl;
        }
        
    } while (choice != 0);
    
    return 0;
}
```

## 14. BÀI TẬP NÂNG CAO

### Bài tập 6 (Optimization)
Tối ưu thuật toán để tìm tất cả số Armstrong từ 1 đến 1,000,000 trong thời gian ngắn nhất.

### Bài tập 7 (Mathematical)
Chứng minh rằng số Armstrong lớn nhất là 9,474,073.

### Bài tập 8 (Algorithm Design)  
Thiết kế thuật toán song song để tìm số Armstrong trên nhiều core CPU.

### Bài tập 9 (Data Structure)
Sử dụng Hash Table để cache kết quả lũy thừa và so sánh hiệu suất.

### Bài tập 10 (Extension)
Mở rộng để kiểm tra số Munchausen và số Perfect Digital Invariant.

---
