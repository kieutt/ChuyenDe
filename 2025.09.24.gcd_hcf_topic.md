# CHUYÊN ĐỀ: TÌM GCD/HCF CỦA HAI SỐ

## 1. MỤC TIÊU HỌC TẬP

Sau khi hoàn thành chuyên đề này, học sinh sẽ có thể:
- Hiểu khái niệm GCD (Greatest Common Divisor) và HCF (Highest Common Factor)
- So sánh và phân tích 5 phương pháp khác nhau để tìm GCD
- Nắm vững thuật toán Euclid và các biến thể của nó
- Phân tích độ phức tạp và tối ưu hóa thuật toán
- Áp dụng GCD vào các bài toán thực tế trong số học và mật mã học

## 2. CƠ SỞ LÝ THUYẾT

### 2.1. Định nghĩa
**GCD (Greatest Common Divisor)** hay **HCF (Highest Common Factor)** của hai số nguyên dương a và b là số nguyên dương lớn nhất chia hết cho cả a và b.

**Ký hiệu:** gcd(a, b) hoặc (a, b)

### 2.2. Tính chất cơ bản
1. **Tính giao hoán:** gcd(a, b) = gcd(b, a)
2. **Tính kết hợp:** gcd(gcd(a, b), c) = gcd(a, gcd(b, c))
3. **Với số 0:** gcd(a, 0) = a (với a > 0)
4. **Tính đồng nhất:** gcd(a, a) = a
5. **Tính chia hết:** Nếu a | b thì gcd(a, b) = a

### 2.3. Định lý Euclid cơ bản
**gcd(a, b) = gcd(b, a mod b)** với b ≠ 0

Đây là nền tảng của thuật toán Euclid hiệu quả nhất.

## 3. CÁC VÍ DỤ MINH HỌA

### Ví dụ 1:
**Input:** a = 20, b = 28
**Các ước của 20:** 1, 2, 4, 5, 10, 20
**Các ước của 28:** 1, 2, 4, 7, 14, 28
**Ước chung:** 1, 2, 4
**GCD:** 4

### Ví dụ 2:
**Input:** a = 60, b = 36
**Phân tích ra thừa số nguyên tố:**
- 60 = 2² × 3 × 5
- 36 = 2² × 3²
**GCD:** 2² × 3 = 12

### Ví dụ 3:
**Input:** a = 17, b = 13
**Kết quả:** gcd(17, 13) = 1 (hai số nguyên tố cùng nhau)

## 4. HIỆN THỰC CÁC THUẬT TOÁN

### 4.1. Phương pháp 1: Brute Force - O(min(a,b))

**Ý tưởng:** Duyệt từ min(a,b) xuống 1 và tìm số lớn nhất chia hết cả a và b.

**Code C++:**
```cpp
#include <iostream>
#include <algorithm>
#include <chrono>
#include <vector>
using namespace std;

// Phương pháp 1: Brute Force
int gcd_bruteforce(int a, int b) {
    int result = min(a, b);
    
    cout << "=== BRUTE FORCE METHOD ===\n";
    cout << "Tìm GCD của " << a << " và " << b << "\n";
    cout << "Duyệt từ " << result << " xuống 1:\n";
    
    while (result > 0) {
        if (a % result == 0 && b % result == 0) {
            cout << "Tìm thấy: " << result << " chia hết cả " << a << " và " << b << "\n";
            break;
        }
        cout << result << " không chia hết cả hai số\n";
        result--;
    }
    
    return result;
}

// Phương pháp 2: Euclidean by Subtraction (Recursive)
int gcd_subtraction(int a, int b) {
    // Base cases
    if (a == 0) return b;
    if (b == 0) return a;
    if (a == b) return a;
    
    // Recursive cases
    if (a > b)
        return gcd_subtraction(a - b, b);
    else
        return gcd_subtraction(a, b - a);
}

// Phương pháp 3: Euclidean with Modulo (Recursive)
int gcd_euclidean_recursive(int a, int b) {
    return b == 0 ? a : gcd_euclidean_recursive(b, a % b);
}

// Phương pháp 4: Euclidean with Modulo (Iterative)
int gcd_euclidean_iterative(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// Hàm demo với steps cho Euclidean algorithm
int gcd_with_steps(int a, int b) {
    cout << "\n=== EUCLIDEAN ALGORITHM STEPS ===\n";
    cout << "Tìm GCD(" << a << ", " << b << "):\n";
    
    int original_a = a, original_b = b;
    int step = 1;
    
    while (b != 0) {
        int quotient = a / b;
        int remainder = a % b;
        
        cout << "Bước " << step << ": " << a << " = " << b << " × " 
             << quotient << " + " << remainder << "\n";
        
        a = b;
        b = remainder;
        step++;
    }
    
    cout << "GCD(" << original_a << ", " << original_b << ") = " << a << "\n";
    return a;
}

// Hàm benchmark để so sánh hiệu suất
void benchmark_gcd_methods(int a, int b) {
    cout << "\n" << string(50, '=') << "\n";
    cout << "BENCHMARK COMPARISON cho GCD(" << a << ", " << b << ")\n";
    cout << string(50, '=') << "\n";
    
    vector<pair<string, function<int(int, int)>>> methods = {
        {"Brute Force", gcd_bruteforce},
        {"Euclidean (Recursive)", gcd_euclidean_recursive},
        {"Euclidean (Iterative)", gcd_euclidean_iterative}
    };
    
    for (auto& method : methods) {
        auto start = chrono::high_resolution_clock::now();
        
        int result = method.second(a, b);
        
        auto end = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
        
        cout << method.first << ":\n";
        cout << "  Kết quả: " << result << "\n";
        cout << "  Thời gian: " << duration.count() << " microseconds\n\n";
    }
}

// Hàm tìm tất cả ước chung
vector<int> find_all_common_divisors(int a, int b) {
    vector<int> divisors;
    int gcd_val = gcd_euclidean_iterative(a, b);
    
    cout << "Tất cả ước chung của " << a << " và " << b << ":\n";
    
    for (int i = 1; i <= gcd_val; i++) {
        if (gcd_val % i == 0) {
            divisors.push_back(i);
            cout << i << " ";
        }
    }
    
    cout << "\nGCD = " << gcd_val << " (ước chung lớn nhất)\n";
    return divisors;
}

int main() {
    cout << "CHUYÊN ĐỀ: TÌM GCD/HCF CỦA HAI SỐ\n";
    cout << string(50, '=') << "\n";
    
    // Test với ví dụ từ GeeksforGeeks
    vector<pair<int, int>> test_cases = {{20, 28}, {60, 36}, {17, 13}, {48, 18}};
    
    for (auto& test : test_cases) {
        int a = test.first, b = test.second;
        
        cout << "\n" << string(40, '-') << "\n";
        cout << "TEST CASE: a = " << a << ", b = " << b << "\n";
        cout << string(40, '-') << "\n";
        
        // Demo step-by-step Euclidean
        int result = gcd_with_steps(a, b);
        
        // Tìm tất cả ước chung
        find_all_common_divisors(a, b);
        
        // So sánh các phương pháp (chỉ với số nhỏ)
        if (min(a, b) <= 100) {
            benchmark_gcd_methods(a, b);
        }
    }
    
    // Nhập từ người dùng
    cout << "\n" << string(50, '=') << "\n";
    cout << "NHẬP TỪNG SỐ ĐỂ TÍNH GCD:\n";
    
    int user_a, user_b;
    cout << "Nhập số thứ nhất: ";
    cin >> user_a;
    cout << "Nhập số thứ hai: ";
    cin >> user_b;
    
    if (user_a <= 0 || user_b <= 0) {
        cout << "Lỗi: Vui lòng nhập số nguyên dương!\n";
        return 1;
    }
    
    cout << "\nCác phương pháp tính GCD(" << user_a << ", " << user_b << "):\n";
    
    cout << "\n1. Euclidean Algorithm (Iterative): " 
         << gcd_euclidean_iterative(user_a, user_b) << "\n";
    
    cout << "2. Euclidean Algorithm (Recursive): " 
         << gcd_euclidean_recursive(user_a, user_b) << "\n";
    
    cout << "3. Built-in function: " << __gcd(user_a, user_b) << "\n";
    
    // Demo step-by-step
    gcd_with_steps(user_a, user_b);
    
    // Tìm tất cả ước chung
    find_all_common_divisors(user_a, user_b);
    
    return 0;
}
```

### 4.2. Phương pháp tối ưu: Euclidean Algorithm

**Code Python:**
```python
import math
import time
from typing import List, Tuple

def gcd_euclidean_recursive(a: int, b: int) -> int:
    """
    Tính GCD bằng thuật toán Euclid đệ quy
    
    Args:
        a, b: Hai số nguyên dương
    
    Returns:
        GCD của a và b
    """
    return a if b == 0 else gcd_euclidean_recursive(b, a % b)

def gcd_euclidean_iterative(a: int, b: int) -> int:
    """
    Tính GCD bằng thuật toán Euclid lặp
    
    Args:
        a, b: Hai số nguyên dương
    
    Returns:
        GCD của a và b
    """
    while b != 0:
        a, b = b, a % b
    return a

def gcd_with_detailed_steps(a: int, b: int) -> int:
    """
    Tính GCD với hiển thị từng bước chi tiết
    """
    print(f"\n=== THUẬT TOÁN EUCLID CHO GCD({a}, {b}) ===")
    
    original_a, original_b = a, b
    steps = []
    step = 1
    
    while b != 0:
        quotient = a // b
        remainder = a % b
        
        step_info = f"Bước {step}: {a} = {b} × {quotient} + {remainder}"
        print(step_info)
        steps.append((a, b, quotient, remainder))
        
        a, b = b, remainder
        step += 1
    
    print(f"\nKết quả: GCD({original_a}, {original_b}) = {a}")
    
    # Hiển thị quá trình ngược lại để hiểu Extended Euclidean
    print(f"\nQuá trình ngược lại (để hiểu Extended Euclidean):")
    print(f"{a} là GCD cuối cùng")
    
    return a

def extended_euclidean(a: int, b: int) -> Tuple[int, int, int]:
    """
    Extended Euclidean Algorithm
    Tìm gcd(a,b) và các hệ số x, y sao cho ax + by = gcd(a,b)
    
    Returns:
        (gcd, x, y) where ax + by = gcd
    """
    if b == 0:
        return a, 1, 0
    
    gcd, x1, y1 = extended_euclidean(b, a % b)
    
    x = y1
    y = x1 - (a // b) * y1
    
    return gcd, x, y

def find_all_divisors(n: int) -> List[int]:
    """Tìm tất cả các ước của n"""
    divisors = []
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sorted(divisors)

def analyze_gcd_properties(a: int, b: int):
    """Phân tích các tính chất của GCD"""
    gcd_val = gcd_euclidean_iterative(a, b)
    
    print(f"\n=== PHÂN TÍCH TÍNH CHẤT GCD({a}, {b}) = {gcd_val} ===")
    
    # Tìm LCM
    lcm_val = (a * b) // gcd_val
    print(f"LCM({a}, {b}) = {lcm_val}")
    print(f"Kiểm tra: GCD × LCM = {gcd_val} × {lcm_val} = {gcd_val * lcm_val}")
    print(f"          a × b = {a} × {b} = {a * b}")
    print(f"Đúng: GCD × LCM = a × b ✓")
    
    # Ước của GCD
    print(f"\nTất cả ước của GCD({gcd_val}):")
    divisors = find_all_divisors(gcd_val)
    print(f"Các ước: {divisors}")
    print(f"Số lượng ước: {len(divisors)}")
    
    # Extended Euclidean
    gcd_ext, x, y = extended_euclidean(a, b)
    print(f"\nExtended Euclidean:")
    print(f"{a} × {x} + {b} × {y} = {gcd_ext}")
    print(f"Kiểm tra: {a}×{x} + {b}×{y} = {a*x} + {b*y} = {a*x + b*y}")
    
    # Tính chất số học
    print(f"\nTính chất:")
    print(f"- gcd({a}, {b}) = gcd({b}, {a}) = {gcd_euclidean_iterative(b, a)} ✓")
    print(f"- gcd({a}, 0) = {a} ✓")
    print(f"- Hai số nguyên tố cùng nhau: {'Có' if gcd_val == 1 else 'Không'}")

def performance_comparison(test_cases: List[Tuple[int, int]]):
    """So sánh hiệu suất các phương pháp"""
    print(f"\n{'='*60}")
    print("SO SÁNH HIỆU SUẤT CÁC PHƯƠNG PHÁP")
    print(f"{'='*60}")
    
    methods = {
        "Built-in": math.gcd,
        "Iterative": gcd_euclidean_iterative,
        "Recursive": gcd_euclidean_recursive
    }
    
    for name, func in methods.items():
        print(f"\n{name}:")
        total_time = 0
        
        for a, b in test_cases:
            start_time = time.time()
            result = func(a, b)
            end_time = time.time()
            
            elapsed = (end_time - start_time) * 1000000  # microseconds
            total_time += elapsed
            
            print(f"  GCD({a:6d}, {b:6d}) = {result:4d} | {elapsed:8.2f} μs")
        
        print(f"  Tổng thời gian: {total_time:8.2f} μs")

def fibonacci_worst_case():
    """Demo worst case cho Euclidean algorithm với số Fibonacci"""
    print(f"\n{'='*50}")
    print("WORST CASE: SỐ FIBONACCI")
    print(f"{'='*50}")
    
    # Tạo dãy Fibonacci
    fib = [1, 1]
    for i in range(8):
        fib.append(fib[-1] + fib[-2])
    
    print("Thuật toán Euclid chậm nhất với các cặp số Fibonacci liên tiếp:")
    
    for i in range(len(fib) - 1):
        a, b = fib[i+1], fib[i]
        if a > b:  # Đảm bảo a > b
            print(f"\nGCD({a}, {b}):")
            gcd_with_detailed_steps(a, b)

# Chương trình chính
def main():
    print("CHUYÊN ĐỀ: TÌM GCD/HCF CỦA HAI SỐ")
    print("="*50)
    
    # Test cases từ GeeksforGeeks
    test_cases = [(20, 28), (60, 36), (17, 13), (48, 18), (100, 75)]
    
    for a, b in test_cases:
        print(f"\n{'-'*40}")
        print(f"PHÂN TÍCH CHO a = {a}, b = {b}")
        print(f"{'-'*40}")
        
        # Tính GCD với các bước
        gcd_with_detailed_steps(a, b)
        
        # Phân tích tính chất
        analyze_gcd_properties(a, b)
    
    # Demo worst case
    fibonacci_worst_case()
    
    # So sánh hiệu suất
    performance_comparison(test_cases)
    
    # Interactive part
    print(f"\n{'='*50}")
    print("TÍNH GCD CHO SỐ TỰ NHẬP:")
    
    try:
        a = int(input("Nhập số thứ nhất: "))
        b = int(input("Nhập số thứ hai: "))
        
        if a <= 0 or b <= 0:
            print("Lỗi: Vui lòng nhập số nguyên dương!")
            return
        
        # Tính và phân tích
        gcd_with_detailed_steps(a, b)
        analyze_gcd_properties(a, b)
        
    except ValueError:
        print("Lỗi: Vui lòng nhập số nguyên hợp lệ!")

if __name__ == "__main__":
    main()
```

## 5. PHÂN TÍCH ĐỘ PHỨC TẠP

### 5.1. So sánh các phương pháp

| Phương pháp | Thời gian | Không gian | Ưu điểm | Nhược điểm |
|-------------|-----------|------------|----------|------------|
| **Brute Force** | O(min(a,b)) | O(1) | Đơn giản, dễ hiểu | Chậm với số lớn |
| **Euclidean Subtraction** | O(max(a,b)) | O(max(a,b)) | Trực quan | Rất chậm |
| **Euclidean Modulo** | O(log(min(a,b))) | O(log(min(a,b))) | Nhanh nhất | Cần hiểu modulo |
| **Euclidean Iterative** | O(log(min(a,b))) | O(1) | Nhanh + tiết kiệm | Ít trực quan |
| **Built-in** | O(log(min(a,b))) | O(1) | Tối ưu nhất | Không học được gì |

### 5.2. Phân tích Euclidean Algorithm

**Tại sao O(log(min(a,b)))?**

1. **Fibonacci numbers** tạo worst case
2. Mỗi bước giảm kích thước input đáng kể
3. Sau 2 bước: gcd(a,b) → gcd(b, a mod b) → gcd(a mod b, b mod (a mod b))
4. Số bước tối đa ≈ 5 × log₁₀(min(a,b))

**Ví dụ cụ thể:**
```
GCD(1071, 462):
1071 = 462 × 2 + 147  →  GCD(462, 147)
 462 = 147 × 3 + 21   →  GCD(147, 21)
 147 = 21 × 7 + 0     →  GCD(21, 0) = 21

Chỉ 3 bước cho số 4 chữ số!
```

## 6. EXTENDED EUCLIDEAN ALGORITHM

### 6.1. Định lý Bézout
Với gcd(a,b) = d, tồn tại các số nguyên x, y sao cho:
**ax + by = d**

### 6.2. Ứng dụng
```cpp
// Tìm nghịch đảo modular: a⁻¹ (mod m)
int modular_inverse(int a, int m) {
    int gcd, x, y;
    tie(gcd, x, y) = extended_gcd(a, m);
    
    if (gcd != 1) {
        return -1; // Không tồn tại nghịch đảo
    }
    
    return (x % m + m) % m;
}

// Giải phương trình Diophantine: ax + by = c
bool solve_diophantine(int a, int b, int c, int &x, int &y) {
    int gcd, x0, y0;
    tie(gcd, x0, y0) = extended_gcd(a, b);
    
    if (c % gcd != 0) {
        return false; // Không có nghiệm
    }
    
    x = x0 * (c / gcd);
    y = y0 * (c / gcd);
    return true;
}
```

## 7. BÀI TẬP THỰC HÀNH

### Bài tập 1: Cơ bản
Viết chương trình tìm GCD của n số (GCD của array).

### Bài tập 2: Ứng dụng
Tìm LCM (Least Common Multiple) bằng công thức: LCM(a,b) = (a×b)/GCD(a,b).

### Bài tập 3: Nâng cao
Implement Extended Euclidean để giải phương trình ax + by = gcd(a,b).

### Bài tập 4: Thách thức
Tối ưu Euclidean Algorithm cho các số rất lớn (BigInteger).

## 8. MỞ RỘNG VÀ ỨNG DỤNG

### 8.1. Ứng dụng trong Mật mã học
```cpp
// RSA Key Generation
pair<int, int> generate_rsa_keys(int p, int q) {
    int n = p * q;
    int phi = (p - 1) * (q - 1);
    
    // Chọn e sao cho gcd(e, phi) = 1
    int e = 3;
    while (gcd(e, phi) != 1) {
        e += 2;
    }
    
    // Tính d = e⁻¹ (mod phi)
    int d = modular_inverse(e, phi);
    
    return {e, d}; // Public key: (e, n), Private key: (d, n)
}
```

### 8.2. Tối ưu hóa phân số
```cpp
// Rút gọn phân số a/b về dạng tối giản
pair<int, int> simplify_fraction(int numerator, int denominator) {
    int gcd_val = gcd(numerator, denominator);
    return {numerator / gcd_val, denominator / gcd_val};
}
```

### 8.3. Thuật toán Binary GCD (Stein's Algorithm)
```cpp
// GCD sử dụng phép shift thay vì modulo (nhanh hơn trên một số hệ thống)
int binary_gcd(int a, int b) {
    if (a == 0) return b;
    if (b == 0) return a;
    
    // Đếm số lần chia hết cho 2
    int shift = 0;
    while (((a | b) & 1) == 0) {
        shift++;
        a >>= 1;
        b >>= 1;
    }
    
    // Loại bỏ các thừa số 2 từ a
    while ((a & 1) == 0) a >>= 1;
    
    do {
        // Loại bỏ các thừa số 2 từ b
        while ((b & 1) == 0) b >>= 1;
        
        // Đảm bảo a >= b
        if (a > b) swap(a, b);
        
        b = b - a;
    } while (b != 0);
    
    return a << shift;
}
```

## 9. BẢNG THAM KHẢO NHANH

### 9.1. Complexity Comparison
| Input Size | Brute Force | Euclidean |
|------------|-------------|-----------|
| 100 | 100 ops | ~7 ops |
| 1,000 | 1,000 ops | ~10 ops |
| 10,000 | 10,000 ops | ~13 ops |
| 100,000 | 100,000 ops | ~17 ops |
| 1,000,000 | 1,000,000 ops | ~20 ops |

### 9.2. Special Cases
```
gcd(a, 0) = a
gcd(0, b) = b
gcd(a, 1) = 1
gcd(a, a) = a
gcd(1, anything) = 1
```

## 10. KẾT LUẬN

Bài toán tìm GCD là một ví dụ kinh điển về:

**Algorithm Evolution:**
- Từ brute force O(n) đến elegant O(log n)
- Sự khác biệt giữa intuitive và optimal

**Mathematical Beauty:**
- Thuật toán Euclid: 2300+ năm tuổi vẫn tối ưu
- Kết nối giữa number theory và computer science

**Practical Applications:**
- Cryptography (RSA, DSA)
- Fraction simplification
- Modular arithmetic
- Algorithm building blocks

**Programming Lessons:**
- Recursive vs iterative trade-offs
- Mathematical analysis của algorithms
- Real-world performance optimization

**Key Takeaways:**
1. **Euclidean Algorithm** là must-know cho mọi programmer
2. **Extended Euclidean** mở ra cánh cửa cryptography
3. **GCD** xuất hiện trong rất nhiều advanced algorithms
4. Hiểu sâu về **mathematical properties** giúp optimize code

Đây là kiến thức nền tảng cực kỳ quan trọng trong competitive programming, cryptography, và algorithm design - một trong những thuật toán đẹp nhất trong toán học!